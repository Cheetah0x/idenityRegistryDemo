{
  "transpiled": true,
  "noir_version": "1.0.0-beta.4+0000000000000000000000000000000000000000",
  "name": "IdentityRegistry",
  "functions": [
    {
      "name": "public_dispatch",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "selector",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "72026683357237545": {
            "error_kind": "string",
            "string": "Function is_valid_address can only be called statically"
          },
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "2233873454491509486": {
            "error_kind": "string",
            "string": "Initializer address is not the contract deployer"
          },
          "2830029349304997821": {
            "error_kind": "fmtstring",
            "length": 27,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "3842422468523945747": {
            "error_kind": "string",
            "string": "Function _remove_zkID can only be called internally"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "7995561580326778049": {
            "error_kind": "string",
            "string": "Function _add_zkID can only be called internally"
          },
          "11032241527761073405": {
            "error_kind": "string",
            "string": "Function is_valid_zkID can only be called statically"
          },
          "12285239479773811347": {
            "error_kind": "string",
            "string": "Function get_zkID_from_address can only be called statically"
          },
          "12749937572827500595": {
            "error_kind": "string",
            "string": "No zkID found for address"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "15100788409809688557": {
            "error_kind": "string",
            "string": "Function get_address_from_zkID can only be called statically"
          },
          "17618083556256589634": {
            "error_kind": "string",
            "string": "Initialization hash does not match"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "public_dispatch"
      ]
    },
    {
      "name": "get_zkID_from_address",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "view"
      ],
      "abi": {
        "parameters": [
          {
            "name": "address",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "field"
          },
          "visibility": "public"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "12285239479773811347": {
            "error_kind": "string",
            "string": "Function get_zkID_from_address can only be called statically"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "JwACBAEoAAABBIBKJwAABAMnAgIEAScCAwQAHxgAAwACgEguCIBIAAElAAAASyUAAABvLgQAAYBJKAIAAgSASScCAwQBOw0AAgADKACAQwQAAygAgEQBAAAoAIBFBAAAKACARgEAASgAgEcEAAEmJQAAAmUeAgACAB4CAAMAMzgAAgADAAQkAgAEAAAAkyUAAAKOHgIAAgknAgMAAQo4AgMEJAIABAAAAK8lAAACoCcCAgAALQgBAycCBAQEABABBAEnAwMEAQAoAwIELQwEBS0OAgUAKAUCBS0OAgUAKAUCBS0OAgUtDQMEACgEAgQtDgQDKwIABAAAAAAAAAAAAgAAAAAAAAAALQgBBScCBgQFABABBgEnAwUEAQAoBQIGLQwGBy0OAgcAKAcCBy0OAgcAKAcCBy0OAgcAKAcCBy0OBActDQMEACgEAgQtDgQDLQ0FBAAoBAIELQ4EBS0IAQQAAAECAS0OAwQtCAEDAAABAgEtDgUDLQgBBQAAAQIBLgqARQAFLQgBBgAAAQIBLgqARAAGJwIHAAMnAggECS0IAAktDAQKLQwDCy0MBQwtDAYNLQwHDgAQAAgAJQAAArItBAAAJwIHBAgtCAAILQwECS0MAwotDAULLQwGDC0MAQ0AEAAHACUAAAKyLQQAAC0NBgELKAABgEQAByQCAAcAAAINJwIIBAA8CQEIJwIBBActCAAHLQwECC0MAwktDAUKLQwGCwAQAAEAJQAAA9stBAAALQ0DAQEoAAGARwAELQ0EAwo4AwIBCygAAYBEAAIkAgACAAACXiUAAATuLwwAAwABJigAgAQEeAANAAAAgASAAyQAgAMAAAKNKgEAAQX3ofOvpa3UyjwBAQImKgEAAQW+Hj//PqT2+jwBAQImKgEAAQWqffA3hIXSkzwBAQImJQAAAmUtDQMGLQ0EBwsoAAeARAAIJAIACAAAAtgnAgkEADwJAQkLKAAGgEMAByQCAAcAAANnIwAAAu0tDQEGLQ0CBy0NAwgtDQQJDSgACIBDAAokAgAKAAADEiUAAAUALgQABoADKACABAQABCUAAAUSLgiABQAKACgKAgsAOAsIDC0OBQwBKAAIgEcABQ44CAUGJAIABgAAA1IlAAAFoC0OCgEtDgcCLQ4FAy0OCQQjAAAD2icCBgQHLQgABy0MAQgtDAIJLQwDCi0MBAsAEAAGACUAAAPbLQQAAC0NAQYtDQIHLQ0ECC4EAAaAAygAgAQEAAQlAAAFEi4IgAUACQAoCQIKASgACoBFAAstDgULLQ4JAS0OBwIuCoBHAAMtDggEIwAAA9omJQAAAmUuCIBFAAUjAAAD6w0oAAWAQwAGJAIABgAABFsjAAAEAC0NAQUtDQIGLQ0DBy0NBAgnAgkEBC0IAQonAgsEBQAQAQsBJwMKBAEAKAYCCycCDAQEACgKAg0/DwALAA0tDQoGACgGAgYtDgYKLQ4FAS0OCgItDgcDLQ4IBCYtDQMGDDgFBgcBKAAFgEcABiQCAAcAAAR5IwAABOUtDQEHLQ0CCC0NAwktDQQKACgIAgwAOAwFDS0NDQsAKAcCDQA4DQUOLQ0ODAA4CwwNLgQACIADKACABAQABSUAAAUSLgiABQALACgLAgwAOAwFDi0ODQ4tDgcBLQ4LAi0OCQMtDgoEIwAABOUtDAYFIwAAA+sqAQABBQLcbieAdhKdPAEBAiYqAQABBcVrxFoOEAACPAEBAiYuAYADgAYLAIAGAAKAByQAgAcAAAUtIwAABTguAIADgAUjAAAFny4AAAGABQEAAAGABAABAQCAA4AEgAkuAIADgAouAIAFgAsLAIAKgAmADCQAgAwAAAWLLgGACoAILgKACIALAQCACgACgAoBAIALAAKACyMAAAVaKAGABQQAAQMAgAYAAoAGIwAABZ8mKgEAAQVFp8pxGUHkFTwBAQIm",
      "debug_symbols": "7Z1RbuM4DIbvkuc+iJRESb3KYFGkbaYIECRFmi6wKHr3tbuR40ZMNKaCWQzMl2Iy5h/KnyWRomPrY/G8enx/eVhvf+7eFvc/Phab3dPysN5tu08fn3eLx/16s1m/PIz/e2H6PwD0JXh7XW77z2+H5f6wuAeL3twtVtvn/t82+u5Lfq43q8V9os+70twgZmvj8GRsGWNHBEdjR8EMxgSMcfTGH42jRxgb/3W3AISbtD6lbA2QfmPrb8Pex4F9rLAHH0I2Jmuvtz75lE81kXXnrbfuxq0H/Nb63ofD3+AjsD6wu2BZhd7Z6z5C14mO1qEzr4BFysMlYfTnYD3+SoO+nfSXLIhkJPMWjEzmORkayt0Su8E4iLxhLyfZ03A9XRfwnu3xNHzz6dJbCNxFTC4P15DS6Zsxcu2wIfdBNxocyJkiQv5ixNGwY429yyy8i2PTnl80yq+Jn1N+TfyS8mvhl7T/tfHT/tfCD432vzZ+Ufm18ANUfk38gvJr4ccXDJTfL/Mj5dfCz+r6rcov5gqCH5WzMj+n/Jr4af7cxM9Z5VfhR4MtfTft+ZGO3zZ+uv5o4hd0/Lbx0/7XxC9q/2vjp/2viV/S+ksbP13/tvCzRusvbfz0/nkTP9D6Sxs/p/ya+Gn9pYkfav7MQNGbQiUUq5kuA0XT1xKK05yAgaKJJgNFo3cJxWtIZqBonaqEQhqSGSgakksoQctEDBQNyQwUDcklFH3KgYGSNM1noGhPYaDonFJAcTO982AhNxkt0jmUmd5OqEDRnsJAmeecch3KTKv5FSjzrOZfh2LnuSCsQNGJloGiE20JxTmFUkLRnlJCmWk1vwJlntX861BmWs2vQJlnNf86lKCrZAaKhmQGik60JZSoEy0DRVfJJZSZPt1RgTLPkBxctsXg5cYdQW/mGb+nEASKLp9fMFgQnGdcuyFB0FHcSHCmr765JcF51lsnEQxpeMFwhPNY7Gf6+ptbEnRKsJGgxuJGgm6ey4xbEtRsppGg10jSSlCzmUaCpH2wlaBTgo0ENZupEkx2OL/kCoJBY3EjwVtsSgFx2KMFR9uG8AS9T7nxFPHU+N5LiXDYsCeE0/tYgdx/bfd/btuT/WPbTrd4EdD/1vbqjDGeBC60fRjXAKNtpHoXTHP8UJcKZCq7CwUb82ANbrTdEWvcNTTQ0BBn0ti8P9fEjg8ww+wBJqazCYH4Byiui4JhezOAdydQ5yW5ACARJYEInUQUeVEcmKMpQPC/SwN32llpfFmPIv53WzVREIgIJCIvEAXJOUVJ8yK/E5t3w8X1Ac5F/N3WmihNF0XjBCL+2ZSayAtEKPF0YTx1QS2LCM4fQooWJaIgEDkvEHkjEUlA8L9IrIhIQi9c2GLxlBFaj4WIBCI+jayJnEQUBaILw70iEoBIBiQiiScwEpGTiATIE15ATkPeZyMUoigQ8Y9SVETOSEQkEHmQiJJARIKYm0iQR6QAEpHAExg+texS6SGpdoWGj09pWOinQKUmTtfwIa2ioemaC531ak7eHfUiVZKoLgTCmkrki0S+SOQriHwFka8oul5R5CuJzitFgaobWiIVSVRgRCo/eY4BfiGaMJcGkis1gnkJ+FF83Y8TtI1fhFY0YbqGX4JeZ0DT50wIAj/8W3pSzP3gWxX3qOEz34pG4idVzofRpOn9DfkfjFY0YboGUKCZHqORf069ohH4EeQCKMgF0Amuj5vYDz67T38v9+vl42b11in6g+/bp8N6tz1+PPzzmo887tebzfrl4XW/e1o9v+9XD5vdU39sYY5/fmBXaOvuVHzFkO5jdyHvAOmri/ZHuyomhth57Tz/Cw==",
      "brillig_names": [
        "get_zkID_from_address"
      ]
    },
    {
      "name": "is_valid_zkID",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "view"
      ],
      "abi": {
        "parameters": [
          {
            "name": "zkID",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "boolean"
          },
          "visibility": "public"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "11032241527761073405": {
            "error_kind": "string",
            "string": "Function is_valid_zkID can only be called statically"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "7Z3dbuMqEMffJde54Bumr7I6qtI2W0WKkipNj3RU9d0PiQJ2A5j14HNWK+am2qznH/DPMDOMY/O5etk+fbw+7g4/j++rhx+fq/3xeXPeHQ/+0+fXevV02u33u9fH8X+v2OUPF/IqeH/bHC6f38+b03n1wKXQbL3aHl4u/5ZO+y/5udtvVw9gvtapORMiWDMlBmOZMVbG8JuxMpZFY8Mzxk4zfTN2WvCx8V9r33u3SO8BgjXn8P/1Xi7DXrvI3lXYc21tMDZSTvceNIRTBSPVfe8VX7j3XHzr/bUN+O/b0CrbhvAXLKiEVnK6DesH0c3aevMKWGHCdAHh9D1YDb/SoW8nfZEZhZPhWrMWJXMiJ3MQr6cDaxORQYiAY0T5s1JchZNSykSRZtnRZuTgTYZhw7XOTkhzMxZsGJmS29wYAxW8iQUYvlm4XD+kDSeqRnNX5EyF4OGLhRh5hayxVsGDaOXGpp6fYJz4NfEzxK+FH6fx18aPxl8TP0Hjr42fJn4t/CSNvzZ+5P+a+ClB/Jr40fqjiZ+WxK/Gz4UFuh5ViwI/Gn9N/Az5vzZ+FH9r/Ey0Nd9NL/wczd8mfkD5cxs/mr8t/CTVTxv50fhr4kf100Z+VL9q4kf100Z+5P+a+Elav7Xxo/VHEz9F9as2fo74tfDT5P8yUCioplAMZWoZKJT+Z6AAQUmgWEVQUigUvVMojkJyBgqtM1IodPMiB4VCcgJFMUZQUigUkjNQKCSnUDhVaTJQKM1PoQgaKRko5FNSKLLP6CN56LLwN68SKH36lGkoikZKBkqfPmUaSqfV/AqUPqv501BMnwvCChRytBko5GhTKLbPNL8ChUZKCqXTan4FSp/V/GkonVbzK1D6rOZXoNAqOYGiGYXkDBRytCmUTp95qEChVXIKpdOnEypQ+gzJVgVbYTXe+Eqwz/g9hyA3LsKw7P6xcd3pYwcLElQ0ixsJ6j5LqEsSVESwRtBCfH+v40ks1hRJGgmaPpeNSxKkWNxI0Pa5zFiSIGUzrQQpkjQSdIoINhKkMdhIECibaSVI2UwbQdPpK62WJEjZTCtBiiSNBDt95GVJghRJGgl2+jDNLIIg4/mBSgh2uj3AkgQXiMXcxe3IxGiHrDxBX9MNnTdODJ0HyCGMe9NZO7wbnRt17fsSL5f6XX3X/A/uO/y5ff+F38BrW+t7nNecj3ZMvDSR6Y6O94isz3yjdXYjPStdmKxWjXb2yxp7b2VN7IhiMDa/nKst3MGzcW9LBXr6XCH6O4Bhu0dhxLWB0k86iw14kb9PhhAVSicsOkLOHNz5NluoFlRE+bSGazVc8/s7fa6wopkWFVLQisghRCKPnLs4fAS7B+FK3nXYD3E8QoPIIkQlXzgt0hgRIEQGc04W0z2Xn7BaxYvr76UkIoMQFaZGReTmi4ApjAgQIo5pqTCffKUxiAy/f7YZCm+lnRYVctWKCBCiwgO1FREGROGBzIoIQ6/wJjo5JLdS388nKATAikhhRA4hKjw7UxEZhAgwIACBnDPGUCqFUjmMiguUqsDdxDxWOp6oCpG3pgKMqvDGhYpKMZRKY1SF3axqKkT89at6jlJpjMqi2spnmn6REJcL97+s9QWK7IiHWMIAaxJNfgxWNGa+RjKERs1P0b0KMColUSqHUWlUWxrVlkG1ZVBtWVRbFnW9HKothzovECiVQahEIULWVAqlgtk+RuTXpSBC0cPnl6lmvl8S+Vk83Y5C9C2/Jp3W5JekFY2ez8AwhAbTTp61Y7G6IxNNPhGuaBDt5Of56HxyGsR4AzVbU9i/qqKZHzslFwiNna9B5AISkQtIRC4gJeL6yJnj4Mt/+ntz2m2e9tt3r7gc/Dg8n3fHw+3j+Z+3cOTptNvvd6+Pb6fj8/bl47R93B+fL8dW7Pbnh59YawHsms/5jz6VXfta8jU4XI4C90elb9W3/C8=",
      "brillig_names": [
        "is_valid_zkID"
      ]
    },
    {
      "name": "_add_zkID",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "internal"
      ],
      "abi": {
        "parameters": [
          {
            "name": "zk_id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "address",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "7995561580326778049": {
            "error_kind": "string",
            "string": "Function _add_zkID can only be called internally"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "_add_zkID"
      ]
    },
    {
      "name": "verify_zkID",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "circuitInputs",
            "type": {
              "kind": "struct",
              "path": "types::SubProofInputs",
              "fields": [
                {
                  "name": "vkeys",
                  "type": {
                    "kind": "struct",
                    "path": "types::Vkeys",
                    "fields": [
                      {
                        "name": "vkey_a",
                        "type": {
                          "kind": "array",
                          "length": 128,
                          "type": {
                            "kind": "field"
                          }
                        }
                      },
                      {
                        "name": "vkey_b",
                        "type": {
                          "kind": "array",
                          "length": 128,
                          "type": {
                            "kind": "field"
                          }
                        }
                      },
                      {
                        "name": "vkey_c",
                        "type": {
                          "kind": "array",
                          "length": 128,
                          "type": {
                            "kind": "field"
                          }
                        }
                      },
                      {
                        "name": "vkey_d",
                        "type": {
                          "kind": "array",
                          "length": 128,
                          "type": {
                            "kind": "field"
                          }
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "proofs",
                  "type": {
                    "kind": "struct",
                    "path": "types::Proofs",
                    "fields": [
                      {
                        "name": "proof_a",
                        "type": {
                          "kind": "array",
                          "length": 459,
                          "type": {
                            "kind": "field"
                          }
                        }
                      },
                      {
                        "name": "proof_b",
                        "type": {
                          "kind": "array",
                          "length": 459,
                          "type": {
                            "kind": "field"
                          }
                        }
                      },
                      {
                        "name": "proof_c",
                        "type": {
                          "kind": "array",
                          "length": 459,
                          "type": {
                            "kind": "field"
                          }
                        }
                      },
                      {
                        "name": "proof_d",
                        "type": {
                          "kind": "array",
                          "length": 459,
                          "type": {
                            "kind": "field"
                          }
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "public_inputs",
                  "type": {
                    "kind": "struct",
                    "path": "types::PubInputs",
                    "fields": [
                      {
                        "name": "input_a",
                        "type": {
                          "kind": "array",
                          "length": 2,
                          "type": {
                            "kind": "field"
                          }
                        }
                      },
                      {
                        "name": "input_b",
                        "type": {
                          "kind": "array",
                          "length": 2,
                          "type": {
                            "kind": "field"
                          }
                        }
                      },
                      {
                        "name": "input_c",
                        "type": {
                          "kind": "array",
                          "length": 2,
                          "type": {
                            "kind": "field"
                          }
                        }
                      },
                      {
                        "name": "input_d",
                        "type": {
                          "kind": "array",
                          "length": 2,
                          "type": {
                            "kind": "field"
                          }
                        }
                      }
                    ]
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "zk_id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "add_zkID",
            "type": {
              "kind": "boolean"
            },
            "visibility": "private"
          },
          {
            "name": "remove_zkID",
            "type": {
              "kind": "boolean"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::max_block_number::MaxBlockNumber",
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "kind": "struct",
                        "path": "std::option::Option",
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::note_hash::NoteHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::nullifier::Nullifier",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::call_context::CallContext",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "calldata_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::eth_address::EthAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_log::PrivateLogData",
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log::Log",
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::log_hash::LogHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "length",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "783436594657808921": {
            "error_kind": "string",
            "string": "comm_out of proof_c does not match comm_in of proof_d"
          },
          "2224917424955179192": {
            "error_kind": "string",
            "string": "scoped nullifier of proof_d does not match zk_id"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "15712935051881954152": {
            "error_kind": "string",
            "string": "comm_out of proof_a does not match comm_in of proof_b"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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nDYm7RYbXdw2urhtdHHbDJu00cVto4vbRhe3jS5uG12cNsbtFhtd3Da6uG10cdsMm7TRxW2ji9tGF7eNLm4bXZw2Zu4WG13cNrq4bXRx2wybtNHFbaOL20YXt40ubhtdXDYXe3eLjS5uG13cNrq4bYZN2ujittHFbaOL20YXt40uTht7d4uNLm4bXdw2urhthk3a6OK20cVto4vbRhe3jS5OG3t3i40ubhtd3Da6uG2GTdro4rbRxW2ji9tGF7eNLk4be3eLjS5uG13cNrq4bYZN2ujittHFbaOL20YXt40uTht7d4uNLm4bXdw2urhthk3a6OK20cVto4vbRhe3jS5OG3t3i40ubhtd3Da6uG2GTdro4rbRxW2ji9tGF7eNLk4be3eLjS5uG13cNrq4bYZN2ujittHFbaOL20YXt40uTht7d4uNLm4bXdw2urhthk3a6OK20cVto4vbRhe3jS5OG3t3i40ubhtd3Da6uG2GTdro4rbRxW2ji9tGF7eNLk4be3eLjS5uG13cNrq4bYZN2ujittHFbaOL20YXt40uLpurvbvFRhe3jS5uG13cNsMmbXRx2+jittHFbaOL20YXp429u8VGF7eNLm4bXdw2wyZtdHHb6OK20cVto4vbRhenjb27xUYXt40ubhtd3DbDJm10cdvo4rbRxW2ji9tGF6eNvbvFRhe3jS5uG13cNsMmbXRx2+jittHFbaOL20YXp429u8VGF7eNLm4bXdw2wyZtdHHb6OK20cVto4vbRhenjb27xUYXt40ubhtd3DbDJm10cdvo4rbRxW2ji9tGF6eNvbvFRhe3jS5uG13cNsMmbXRx2+jittHFbaOL20YXp429u8VGF7eNLm4bXdw2wyZtdHHb6OK20cVto4vbRhenjb27xUYXt40ubhtd3DbDJm10cdvo4rbRxW2ji9tGF6eNvbvFRhe3jS5uG13cNsMmbXRx2+jittHFbaOL20YXl829vbvFRhe3jS5uG13cNsMmbXRx2+jittHFbaOL20YXp429u8VGF7eNLm4bXdw2wyZtdHHb6OK20cVto4vbRhenjb27xUYXt40ubhtd3DbDJm10cdvo4rbRxW2ji9tGF6eNvbvFRhe3jS5uG13cNsMmbXRx2+jittHFbaOL20YXp429u8VGF7eNLm4bXdw2wyZtdHHb6OK20cVto4vbRhen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G13cNrq4bXRx2wybtNHFbaOL20YXt40ubhtdXDZXe3eLjS5uG13cNrq4bYZN2ujittHFbaOL20YXt40uTht7d4uNLm4bXdw2urhthk3a6OK20cVto4vbRhe3jS5OG3t3i40ubhtd3Da6uG2GTdro4rbRxW2ji9tGF7eNLk4be3eLjS5uG13cNrq4bYZN2ujittHFbaOL20YXt40uTht7d4uNLm4bXdw2urhthk3a6OK20cVto4vbRhe3jS5OG3t3i40ubhtd3Da6uG2GTdro4rbRxW2ji9tGF7eNLk4be3eLjS5uG13cNrq4bYZN2ujittHFbaOL20YXt40uTht7d4uNLm4bXdw2urhthk3a6OK20cVto4vbRhe3jS5OG3t3i40ubhtd3Da6uG2GTdro4rbRxW2ji9tGF7eNLk4be3eLjS5uG13cNrq4bYZN2ujittHFbaOL20YXt40uLpt7e3eLjS5uG13cNrq4bYZN2ujittHFbaOL20YXt40uTht7d4uNLm4bXdw2urhthk3a6OK20cVto4vbRhe3jS5OG3t3i40ubhtd3Da6uG2GTdro4rbRxW2ji9tGF7eNLk4be3eLjS5uG13cNrq4bYZN2ujittHFbaOL20YXt40uTht7d4uNLm4bXdw2urhthk3a6OK20cVto4vbRhe3jS5OG3t3i40ubhtd3Da6uG2GTdro4rbRxW2ji9tGF7eNLk4be3eLjS5uG13cNrq4bYZN2ujittHFbaOL20YXt40uTht7d4uNLm4bXdw2urhthk3a6OK20cVto4vbRhe3jS5OG3t3i40ubhtd3Da6uG2GTdro4rbRxW2ji9tGF7eNLk4be3eLjS5uG13cNrq4bYZN2ujittHFbaOL20YXt40uLpuxd7fY6OK20cVto4vbZtikjS5uG13cNrq4bXRx2+jitLF3t9jo4rbRxW2ji9tm2KSNLm4bXdw2urhtdHHb6OK0sXe32OjittHFbaOL22bYpI0ubhtd3Da6uG10cdvo4rSxd7fY6OK20cVto4vbZtikjS5uG13cNrq4bXRx2+jitLF3t9jo4rbRxW2ji9tm2KSNLm4bXdw2urhtdHHb6OK0sXe32OjittHFbaOL22bYpI0ubhtd3Da6uG10cdvo4rSxd7fY6OK20cVto4vbZtikjS5uG13cNrq4bXRx2+jitLF3t9jo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nUXnZM35lXVOVqhfV+fpZD37lXVOVr9fWUcrbzpaedMZOouOVt50tPKmc9utfPAX2k+33cpHOlp5+c561sqbjlbedLTypqOVN52hs+ho5U1HK286HlfedDyuvOlo5UXn5aZb+egJfC833cqHOjfdyoc6J2vlg6mi+5eT1e/heU/Ws4fnPVmhHp73ZM15eN6TVeTheU/WhQfnnbuTld7heU/WbofnPVmNHUwVzd3J+urwvHNj5z1ZXx2e92R9dXjek/XV4XlP1leH5z1ZXx1M98zlZH11eN6T9dXheU/WV4fnPVlfHZ53buy8J+urw/OerK8Oz3uyvjp4RehcbusV3XO5rVd0z/W2XtE919t6RfdcT9ZXh+f1XLofbv3W8xLmerIa+8o6nku36Xgu3abjuXSbjufSbTq3/Vy6/VU5c3/brzs50rnt150c6dz2606OdG67lY90hs6ic9utfKRz2618pKOVlxq818qbjtedLDrjNdqbjtdobzpeo73peFx50xm9070zWnnT0cqbjusZbTquZ7TpeFx50XnwuPKm43HlTUcrLzX4oJU3naGz6HgOxqbjORibjseVNx2PK286WnnpnbPtPn1lHa286XgOxqajlZefyre9KXVwLay57U2pQ52bbuVDnZtu5UOdm27lQ50buwbB2VaiDs97Y9d4OtuS0+F5b+samnO2taXD897WNTTnbItIh+e9rWtoztlWiw7Pe7K+Orqm1dmWhQ7Pe7K+OjzvjV1D82x7PofnnRs7741dQ/NsKzqH572xa2iebenm6PGNs23XHJ33bGs0h+e9sWtonm0x5vC8N3YNzbNtwBye98auofnxN2Ae5st5H58Pznt9/bv8H29+vczD3533jfd+9ByAj78Y8646H77d3lXnw5feO+o8fPztmnfV+fAV+a46H745/6U6+7P6Hj7+is676gydRefD1++76tx2Kx/p3HYrH+lo5e0eXSsvOh9/h+hddbTypnPbrXykc9utfKQzdBYdrbz0zsffZnpXHa286dx2Kx/p3HYrH+h8/E2pd9XRyss9+sffq3pXHa286QydRee2W/lIRytv91laedPRypuOVl50Pv661bvq3HYrH+ncdCvf71epePj461bvqjN0Fp2bbuVDnZtu5UOdr9LKL9fPOi/3Lwc6T5/f9f0Xm8vrm/3wCX2NPH2ZL1+ul5+8iOzNT+jy8vDy5Snvj5cvpo9vfwHm4Sdfgee/u/kPR3j52R/hq0wzvfMRLj//I1x//ke4/58/wtP17vMRnp/u9yO8PDx8ft/X55/8PHr9Afn6q1/98dvf/e7b//z3333361/++dvvfv+n79/07vt/vL2T8/qHgB/f3cPT43//6fb2eMz+Jk///Js8//Nv8vJPvsnrry7f3zL+aunp0/3B43X+G+nrL//PL//47S9/9bvffm/5/f/9y+9//Yn29Zd//r9/+PR/PuH/4Y/f/fq3v/nLH3/7/Zfhy1fg+99ar/e0c309wX894+nh8ouHxy+f2/f/6Xr5xfX1P/3t9SP/Pw==",
      "brillig_names": [
        "store_in_execution_cache_oracle_wrapper",
        "notify_enqueued_public_function_call_wrapper",
        "directive_invert",
        "directive_integer_quotient"
      ],
      "verification_key": ""
    },
    {
      "name": "constructor",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "initializer"
      ],
      "abi": {
        "parameters": [
          {
            "name": "admin",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "2233873454491509486": {
            "error_kind": "string",
            "string": "Initializer address is not the contract deployer"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "17618083556256589634": {
            "error_kind": "string",
            "string": "Initialization hash does not match"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "constructor"
      ]
    },
    {
      "name": "is_valid_address",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "view"
      ],
      "abi": {
        "parameters": [
          {
            "name": "address",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "boolean"
          },
          "visibility": "public"
        },
        "error_types": {
          "72026683357237545": {
            "error_kind": "string",
            "string": "Function is_valid_address can only be called statically"
          },
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "7Z3bbuM4DIbfJde5EHVmX2WwKNI2UwQIkiJNF1gUffe1s/GhMRWtKWMGA/GmGI/5R9JnSqLogz5XL9unj9fH3eHn8X318ONztT8+b86746E5+vxar55Ou/1+9/o4/u+Vav8A+Ivg/W1zaI/fz5vTefUARju1Xm0PL+2/TXTNj/zc7berB/Rf66m50rqzVlYPxoYwtt7D1dj6oHpjD4RxdMpdjaPTMDb+a70CDYvUHrGzBsBfWPtl2LvYs48Z9uBC6Iy9Mfdrjw67pqI39rb2xi5ce9Dfat+WYfUvKCOQZejmgnUq7ay5X0ZonOhqHRrzDFjtu+6COrpbsE7/nwp9a/RFFlgyzystKJ7MUbKI/fWMGMJEhAxRtAwR0q3yaLpGhdHFdYr0Nm+G0WRwG3CO7JD+aqzV4JkGAuVjaLvRJCAOv6wjVQ8TuobaUd/VlKnW0P2w1qNRgTR2thtBnI1j0ws/J/yK+KHwK+CnlRV+RfzE/4r4gfhfGT/xvyJ+2gi/In5B+JXwM1r4FfHzwq+EnwXhV8RP1m9ZfrFLcLhRtq3jJ/FLET9nhV8Rvyj8Mvx8b+u/m7b8gvTfIn5R1h9l/KT/FvFD8b8yfuJ/JfyMEv8r4yf5lyJ+IOvfMn6Sfynip+X+eRk/yb+U8ZP1WxE/I/mXMn4SP0+hWLkpRECRSHcKxUn4SkCRmGAKxUugSUCxAmUKRabkKZQgeSoCikzJUyhRpmQCiqSJplDk3QkKikzJBBTJ0kygWCVhPgFFPGUKRV4yIKBUeufBQFdlbbSfQKlzTLkPxYinEFDqHFMyUOpMHdyHUmk2PwOlzgXhfShOBloCigy0BJQ6w/z7UCrN5megyJQ8hVJpNj8Dpc5s/n0olWbzM1BklUxAkSl5CqXS10syUGSgnUBxSlbJBBTxlCmUSl/ZCLaz1cHxjS8E65y/5xAEH20PQ92+Nu4q/WzQggSN9OJSgnWmUBckaOvMt84iGLD//nGEyVxc6edvliRY57JxQYJO5uJSgnUuMxYk6CWaKSUoM0khwSDRTClB8cFSghLNFBKs9INgSxKUaKaQIEo0U0pQZpJSgjKTlBH0lX5abUmC4oNZgmj69qGdEASZiwsJ6gXmYoj9dm56tMMYTdA57Crvox4qj0gh7Pf2C2H4Njp4+1/d/Z9b9yXe7/hddV/ijYPfVvf8iGEwV/e+XwOMdpxsiyCq4/p7RMGroaXkRoTBxK4ewY52RiSNm9Eq+L4iVuHYvG1rInPdDBl9W70Zt7UVBWCIop4vCp6e/lQ/uIGKeDNehcSjtRkRfdFhqF7jsbeixFOI90WJB9IyojhfFBMPNEHsXUKrWxAx8VyBHfaIHHtdJwoMUeL+e0bkOCJkiCynTY5TvcSHkZztL64LMBF5hijRNTKiyBDRW3nmRMgQIaekRH9ywxjv4fZ9ZVSeIUo8K5YRIUOkLUfEAZHYMioj4tBL3N03Q8Bq3G1/wsRLbBmR5YgiQ5TYvTcj8gxR4IAIHOSRU1LkII8c5MhBjgnkvg9LTbwdWEAlJt2cCjmqxFclMqrEZxdyKsdRGcNSMabeJr4DlspxVI5VFh1kNjF/H/3biYaeqbDPSGC4XbAD0D6Y0fj5GlAMjZ0fnTcq5Ki0YakiR2VYZRlWWZZVlmWV5VhlOdb18qyyPKtdQbNUnqNKzI45Faun0DH03TEG6CUp6i6HgZbQzB+XElsF3y0nsT1uRhPma+jVaEbj5jOwiqHhlEOzjp0ffEs3XzV0DJzRMMqh+/moPZSG4W/BztfQr9tmNPPnTo2aoQmzNYYRCxhGLGAYsYABy9DM9IOv5ujvzWm3edpv3xtFe/Lj8HzeHQ/Xw/M/b92Zp9Nuv9+9Pr6djs/bl4/T9nF/fG7PrdT1zw/tca1RXWKz5rAJZddg4TIktmcRmrOmKbUp+V8=",
      "brillig_names": [
        "is_valid_address"
      ]
    },
    {
      "name": "remove_zkID_with_address",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [],
        "return_type": null,
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "12749937572827500595": {
            "error_kind": "string",
            "string": "No zkID found for address"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "remove_zkID_with_address"
      ]
    },
    {
      "name": "sync_notes",
      "is_unconstrained": true,
      "custom_attributes": [
        "aztec::macros::functions::utility"
      ],
      "abi": {
        "parameters": [],
        "return_type": null,
        "error_types": {
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "H4sIAAAAAAAA/7WTPQ+CMBCGi2KUjzjgoD+jBAyM+LG4OLpXCkpUSAB3frqQXENtwKjAJU17FJ5736OVUB0SzDLqEAyyglmBecTtj8vhQY67hakIdfvku9i2lQZ/Peq3FGBKw/Ax4w/UfzwFzr6o+bwXVndWDo1b66g+H0P5Z/9vSP+LD5418GpAXnmew/oS5Nt74t+Oz8c5SNnXTR1EgnIxdK5CSd0lcZ4SP99QmgZZJhJGDWTUQlU56pVE8YG26fmRdgrSLEpikSZ/Sav6yu6lXLyr8eA57hCOizHTMAb+BDV3X+b2+feXkKuCJ+bT+1Nn6BAztEhI1oRS2yeGwK+CP38vlizs4eEFAAA=",
      "debug_symbols": "rZLNqoMwEEbfJWsX+c/EVymXEjWWQIgS9UIR372xxCK1tBs3QyYchpPMN6PGVtPt6kLbDai8zMh3tRldF1I3LwWqovPe3a77a4TXQtiTH3oT1nYYTRxRSTAnUCAbmudZqTSjdd6iUsulOOAKZIYB8xcq2QdUUJFRIfALJQyWvwIRfoIMMLXJCP1dhjOdUS7hICPOkAG+yWj4LiPx9jOSyoOMPEFGU5phzcQPGcAZVfhtTUtq/010pvI2x6udQr1L23jv7Vvw+tjVtpmiXSO4S1+ql/QEytLYNPoB",
      "brillig_names": [
        "sync_notes"
      ]
    },
    {
      "name": "_remove_zkID",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "internal"
      ],
      "abi": {
        "parameters": [
          {
            "name": "zk_id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "address",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "3842422468523945747": {
            "error_kind": "string",
            "string": "Function _remove_zkID can only be called internally"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "_remove_zkID"
      ]
    },
    {
      "name": "get_address_from_zkID",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "view"
      ],
      "abi": {
        "parameters": [
          {
            "name": "zkID",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
            "fields": [
              {
                "name": "inner",
                "type": {
                  "kind": "field"
                }
              }
            ]
          },
          "visibility": "public"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "15100788409809688557": {
            "error_kind": "string",
            "string": "Function get_address_from_zkID can only be called statically"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "JwACBAEoAAABBIBKJwAABAMnAgIEAScCAwQAHxgAAwACgEguCIBIAAElAAAASyUAAABvLgQAAYBJKAIAAgSASScCAwQBOw0AAgADKACAQwQAAygAgEQBAAAoAIBFBAAAKACARgEAASgAgEcEAAEmJQAAAmUeAgACAB4CAAMAMzgAAgADAAQkAgAEAAAAkyUAAAKOHgIAAgknAgMAAQo4AgMEJAIABAAAAK8lAAACoCcCAgAALQgBAycCBAQEABABBAEnAwMEAQAoAwIELQwEBS0OAgUAKAUCBS0OAgUAKAUCBS0OAgUtDQMEACgEAgQtDgQDKwIABAAAAAAAAAAAAgAAAAAAAAAALQgBBScCBgQFABABBgEnAwUEAQAoBQIGLQwGBy0OAgcAKAcCBy0OAgcAKAcCBy0OAgcAKAcCBy0OBActDQMEACgEAgQtDgQDLQ0FBAAoBAIELQ4EBS0IAQQAAAECAS0OAwQtCAEDAAABAgEtDgUDLQgBBQAAAQIBLgqARQAFLQgBBgAAAQIBLgqARAAGJwIHAAInAggECS0IAAktDAQKLQwDCy0MBQwtDAYNLQwHDgAQAAgAJQAAArItBAAAJwIHBAgtCAAILQwECS0MAwotDAULLQwGDC0MAQ0AEAAHACUAAAKyLQQAAC0NBgELKAABgEQAByQCAAcAAAINJwIIBAA8CQEIJwIBBActCAAHLQwECC0MAwktDAUKLQwGCwAQAAEAJQAAA9stBAAALQ0DAQEoAAGARwAELQ0EAwo4AwIBCygAAYBEAAIkAgACAAACXiUAAATuLwwAAwABJigAgAQEeAANAAAAgASAAyQAgAMAAAKNKgEAAQX3ofOvpa3UyjwBAQImKgEAAQW+Hj//PqT2+jwBAQImKgEAAQXRkMcNIwrX7TwBAQImJQAAAmUtDQMGLQ0EBwsoAAeARAAIJAIACAAAAtgnAgkEADwJAQkLKAAGgEMAByQCAAcAAANnIwAAAu0tDQEGLQ0CBy0NAwgtDQQJDSgACIBDAAokAgAKAAADEiUAAAUALgQABoADKACABAQABCUAAAUSLgiABQAKACgKAgsAOAsIDC0OBQwBKAAIgEcABQ44CAUGJAIABgAAA1IlAAAFoC0OCgEtDgcCLQ4FAy0OCQQjAAAD2icCBgQHLQgABy0MAQgtDAIJLQwDCi0MBAsAEAAGACUAAAPbLQQAAC0NAQYtDQIHLQ0ECC4EAAaAAygAgAQEAAQlAAAFEi4IgAUACQAoCQIKASgACoBFAAstDgULLQ4JAS0OBwIuCoBHAAMtDggEIwAAA9omJQAAAmUuCIBFAAUjAAAD6w0oAAWAQwAGJAIABgAABFsjAAAEAC0NAQUtDQIGLQ0DBy0NBAgnAgkEBC0IAQonAgsEBQAQAQsBJwMKBAEAKAYCCycCDAQEACgKAg0/DwALAA0tDQoGACgGAgYtDgYKLQ4FAS0OCgItDgcDLQ4IBCYtDQMGDDgFBgcBKAAFgEcABiQCAAcAAAR5IwAABOUtDQEHLQ0CCC0NAwktDQQKACgIAgwAOAwFDS0NDQsAKAcCDQA4DQUOLQ0ODAA4CwwNLgQACIADKACABAQABSUAAAUSLgiABQALACgLAgwAOAwFDi0ODQ4tDgcBLQ4LAi0OCQMtDgoEIwAABOUtDAYFIwAAA+sqAQABBQLcbieAdhKdPAEBAiYqAQABBcVrxFoOEAACPAEBAiYuAYADgAYLAIAGAAKAByQAgAcAAAUtIwAABTguAIADgAUjAAAFny4AAAGABQEAAAGABAABAQCAA4AEgAkuAIADgAouAIAFgAsLAIAKgAmADCQAgAwAAAWLLgGACoAILgKACIALAQCACgACgAoBAIALAAKACyMAAAVaKAGABQQAAQMAgAYAAoAGIwAABZ8mKgEAAQVFp8pxGUHkFTwBAQIm",
      "debug_symbols": "7Z3bbuM4DIbfJde9EKkj+yqDRdFDpggQJEXaLrAo+u5rd+NDI9oaU8EsBuZNMRnzD+VPB1J0bH9snrYP7893u8PP4+vm9sfHZn98vH/bHQ/Np4/Pm83Dabff757vxv+9Me0fgPAleH25P7SfX9/uT2+bW7Dozc1me3hq/22Tb77k526/3dxS+LzJzQ1iZ20cDsaWMXYhwNnYhWh64wCMcfLGn42TRxgb/3WzAYSrtJ6oswag39j667D3qWefCuzBx9gZB2vnW0+eulOlYN1l6627cusBv7W+9eHwN/iIrA9sOqxToXd23kdsBtHZOjbmBbAYuulCmPwlWI+/0qBvJ/0liyJZkHmLRibzrIygH5bkhhnoDdudwQ7TdegX8J4d8eFsjGboeguR60Ry3XSNRMM3Y+LaYWM3Bt1ociBnigjdFyOOph1r7F3Hwrs0Nm35JaP8qvg55VfFj5RfDT/S8VfHT8dfDT80Ov7q+CXlV8MPUPlV8YvKr4bfRMFA+f0qv6D8avhZ3b8V+aWuguBH5ayOn1N+Vfw0f67i56zyK/ALvW34btryCzp/6/jp/qOKX9T5W8dPx18Vv6Tjr46fjr8qfqT1lzp+uv+t4WeN1l/q+On18yp+oPWXOn5O+VXx0/pLFT/U/JmBoheFcihWM10GiqavORSnOQEDRRNNBopG7xyK15DMQNE6VQ4laEhmoGhIzqFELRMxUDQkM1A0JOdQ9C4HBgppms9A0ZHCQNE1JYPiVnrlwULXZLQYLqGs9HJCAYqOFAbKOteUeSgrreYXoKyzmj8Pxa5zQ1iAogstA0UX2hyKcwolh6IjJYey0mp+Aco6q/nzUFZazS9AWWc1fx5K1F0yA0VDMgNFF9ocStKFloGiu+Qcykrv7ihAWWdIjq6zxejlxg1Bb9YZv5cQhJBcd37RYEZwnXHtigRBZ3ElwZU++uaaBNdZb11EMFIPI8FlLPYrffzNNQk6JVhJUGNxJUG3zm3GNQlqNlNJ0GskqSWo2UwlwaBjsJagU4KVBDWbKRIkawcYGcGosbiS4DVeSgGpf0cLjl4bwhP0nrrGh4RD44k4hP0Le2IcnscKwf3Xdv/ntp3sH9v2cI0HAf1vbS+vGMGU2t7Pa4DRa6RaF0xzfF+XisEU3i4Ubeoma3Sj1x2xxs1qFUPfEGdobN6eK/Hzw/SrB5hEFwtCmLiBYlYUDT+awbsB1GVJLgJIRCQQoZOI+OgMqWeOJgMx8bs0N7xZadytZ9HE77YKoigQBZCIvEAUJeeUJM1L/Iz2ru9cH+FSNHG1tSCi5aJknEA0cW9KQeQFIpR4mphPTVDrRAEub0JKEw91KYiiQDTx/It50URRoiCSgJj4ReK8KEjoTdyKbYeM0HrMREEgmkgjCyInESWBaGK6F0QCEGRAIpJ4AiMROYlIgJxwAnno8z6bIBMlgWjiVop50cSDgwqiIBB5kIhIIAqCmEtBkEdQBIlI4AkMn1o2qXSfVLtMw8cn6jf6FEOuScs1fEgraMJyzcRgnc3Jm6NepCKJaiIQllQiX0HkK4h8RZGvKPKVRP2VRL5IdF6UBKpmaolUQaICI1L5xWsM8BtRwq40QC7XCNYl4GfxvB8naBu/CS1o4nINvwWdZxCWr5kQBX74p/RQ6sbBtyruWcNnvgWNxA8VzofR0PLxhvwPRguauFwDKNAsj9HI36de0Aj8CHIBFOQC6AT94xaOg8/m09/3p939w3772ijag++Hx7fd8XD++PbPS3fk4bTb73fPdy+n4+P26f20vdsfH9tjG3P+8wObQltzpeIrhjQfm468AQxfQ7Q92lQxMabGa+P5Xw==",
      "brillig_names": [
        "get_address_from_zkID"
      ]
    }
  ],
  "outputs": {
    "globals": {
      "storage": [
        {
          "fields": [
            {
              "name": "contract_name",
              "value": {
                "kind": "string",
                "value": "IdentityRegistry"
              }
            },
            {
              "name": "fields",
              "value": {
                "fields": [
                  {
                    "name": "admin",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000001"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "zkPassportIDtoAddress",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000002"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "addressToZKPassportID",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000003"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  }
                ],
                "kind": "struct"
              }
            }
          ],
          "kind": "struct"
        }
      ]
    },
    "structs": {
      "functions": [
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "admin",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "IdentityRegistry::constructor_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "IdentityRegistry::constructor_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "zk_id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "address",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "IdentityRegistry::_add_zkID_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "IdentityRegistry::_add_zkID_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "address",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "IdentityRegistry::get_zkID_from_address_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "field"
              }
            }
          ],
          "kind": "struct",
          "path": "IdentityRegistry::get_zkID_from_address_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "circuitInputs",
                    "type": {
                      "fields": [
                        {
                          "name": "vkeys",
                          "type": {
                            "fields": [
                              {
                                "name": "vkey_a",
                                "type": {
                                  "kind": "array",
                                  "length": 128,
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              },
                              {
                                "name": "vkey_b",
                                "type": {
                                  "kind": "array",
                                  "length": 128,
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              },
                              {
                                "name": "vkey_c",
                                "type": {
                                  "kind": "array",
                                  "length": 128,
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              },
                              {
                                "name": "vkey_d",
                                "type": {
                                  "kind": "array",
                                  "length": 128,
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              }
                            ],
                            "kind": "struct",
                            "path": "types::Vkeys"
                          }
                        },
                        {
                          "name": "proofs",
                          "type": {
                            "fields": [
                              {
                                "name": "proof_a",
                                "type": {
                                  "kind": "array",
                                  "length": 459,
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              },
                              {
                                "name": "proof_b",
                                "type": {
                                  "kind": "array",
                                  "length": 459,
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              },
                              {
                                "name": "proof_c",
                                "type": {
                                  "kind": "array",
                                  "length": 459,
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              },
                              {
                                "name": "proof_d",
                                "type": {
                                  "kind": "array",
                                  "length": 459,
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              }
                            ],
                            "kind": "struct",
                            "path": "types::Proofs"
                          }
                        },
                        {
                          "name": "public_inputs",
                          "type": {
                            "fields": [
                              {
                                "name": "input_a",
                                "type": {
                                  "kind": "array",
                                  "length": 2,
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              },
                              {
                                "name": "input_b",
                                "type": {
                                  "kind": "array",
                                  "length": 2,
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              },
                              {
                                "name": "input_c",
                                "type": {
                                  "kind": "array",
                                  "length": 2,
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              },
                              {
                                "name": "input_d",
                                "type": {
                                  "kind": "array",
                                  "length": 2,
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              }
                            ],
                            "kind": "struct",
                            "path": "types::PubInputs"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "types::SubProofInputs"
                    }
                  },
                  {
                    "name": "zk_id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "add_zkID",
                    "type": {
                      "kind": "boolean"
                    }
                  },
                  {
                    "name": "remove_zkID",
                    "type": {
                      "kind": "boolean"
                    }
                  }
                ],
                "kind": "struct",
                "path": "IdentityRegistry::verify_zkID_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "IdentityRegistry::verify_zkID_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "IdentityRegistry::remove_zkID_with_address_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "IdentityRegistry::remove_zkID_with_address_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "zk_id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "address",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "IdentityRegistry::_remove_zkID_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "IdentityRegistry::_remove_zkID_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "address",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "IdentityRegistry::is_valid_address_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "boolean"
              }
            }
          ],
          "kind": "struct",
          "path": "IdentityRegistry::is_valid_address_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "zkID",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "IdentityRegistry::is_valid_zkID_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "boolean"
              }
            }
          ],
          "kind": "struct",
          "path": "IdentityRegistry::is_valid_zkID_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "zkID",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "IdentityRegistry::get_address_from_zkID_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "fields": [
                  {
                    "name": "inner",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
              }
            }
          ],
          "kind": "struct",
          "path": "IdentityRegistry::get_address_from_zkID_abi"
        }
      ]
    }
  },
  "file_map": {
    "137": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.2/noir-projects/aztec-nr/aztec/src/oracle/enqueue_public_function_call.nr",
      "source": "use dep::protocol_types::address::AztecAddress;\n\n#[oracle(notifyEnqueuedPublicFunctionCall)]\nunconstrained fn notify_enqueued_public_function_call_oracle(\n    _contract_address: AztecAddress,\n    _calldata_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n) {}\n\nunconstrained fn notify_enqueued_public_function_call_wrapper(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    notify_enqueued_public_function_call_oracle(\n        contract_address,\n        calldata_hash,\n        side_effect_counter,\n        is_static_call,\n    )\n}\n\npub fn notify_enqueued_public_function_call(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    // Safety: Notifies the simulator that a public call has been enqueued, allowing it to prepare hints for the AVM to process this call.\n    unsafe {\n        notify_enqueued_public_function_call_wrapper(\n            contract_address,\n            calldata_hash,\n            side_effect_counter,\n            is_static_call,\n        )\n    }\n}\n\n#[oracle(notifySetPublicTeardownFunctionCall)]\nunconstrained fn notify_set_public_teardown_function_call_oracle(\n    _contract_address: AztecAddress,\n    _calldata_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n) {}\n\nunconstrained fn notify_set_public_teardown_function_call_wrapper(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    notify_set_public_teardown_function_call_oracle(\n        contract_address,\n        calldata_hash,\n        side_effect_counter,\n        is_static_call,\n    )\n}\n\npub fn notify_set_public_teardown_function_call(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    // Safety: Notifies the simulator that a teardown call has been set, allowing it to prepare hints for the AVM to process this call.\n    unsafe {\n        notify_set_public_teardown_function_call_wrapper(\n            contract_address,\n            calldata_hash,\n            side_effect_counter,\n            is_static_call,\n        )\n    }\n}\n\npub fn notify_set_min_revertible_side_effect_counter(counter: u32) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter) };\n}\n\npub unconstrained fn notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter: u32) {\n    notify_set_min_revertible_side_effect_counter_oracle(counter);\n}\n\n#[oracle(notifySetMinRevertibleSideEffectCounter)]\nunconstrained fn notify_set_min_revertible_side_effect_counter_oracle(_counter: u32) {}\n"
    },
    "138": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.2/noir-projects/aztec-nr/aztec/src/oracle/execution.nr",
      "source": "use dep::protocol_types::address::AztecAddress;\n\n#[oracle(getContractAddress)]\nunconstrained fn get_contract_address_oracle() -> AztecAddress {}\n\n#[oracle(getBlockNumber)]\nunconstrained fn get_block_number_oracle() -> u32 {}\n\n#[oracle(getChainId)]\nunconstrained fn get_chain_id_oracle() -> Field {}\n\n#[oracle(getVersion)]\nunconstrained fn get_version_oracle() -> Field {}\n\npub unconstrained fn get_contract_address() -> AztecAddress {\n    get_contract_address_oracle()\n}\n\npub unconstrained fn get_block_number() -> u32 {\n    get_block_number_oracle()\n}\n\npub unconstrained fn get_chain_id() -> Field {\n    get_chain_id_oracle()\n}\n\npub unconstrained fn get_version() -> Field {\n    get_version_oracle()\n}\n"
    },
    "139": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.2/noir-projects/aztec-nr/aztec/src/oracle/execution_cache.nr",
      "source": "/// Stores values represented as slice in execution cache to be later obtained by its hash.\npub fn store(values: [Field], hash: Field) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call. When loading the values, however, the caller must check that the values are indeed the preimage.\n    unsafe { store_in_execution_cache_oracle_wrapper(values, hash) };\n}\n\nunconstrained fn store_in_execution_cache_oracle_wrapper(values: [Field], hash: Field) {\n    store_in_execution_cache_oracle(values, hash);\n}\n\npub unconstrained fn load<let N: u32>(hash: Field) -> [Field; N] {\n    load_from_execution_cache_oracle(hash)\n}\n\n#[oracle(storeInExecutionCache)]\nunconstrained fn store_in_execution_cache_oracle(_values: [Field], _hash: Field) {}\n\n#[oracle(loadFromExecutionCache)]\nunconstrained fn load_from_execution_cache_oracle<let N: u32>(_hash: Field) -> [Field; N] {}\n"
    },
    "140": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.2/noir-projects/aztec-nr/aztec/src/oracle/get_contract_instance.nr",
      "source": "use protocol_types::{\n    address::AztecAddress, contract_class_id::ContractClassId, contract_instance::ContractInstance,\n    traits::FromField,\n};\n\n// NOTE: this is for use in private only\n#[oracle(getContractInstance)]\nunconstrained fn get_contract_instance_oracle(_address: AztecAddress) -> ContractInstance {}\n\n// NOTE: this is for use in private only\nunconstrained fn get_contract_instance_internal(address: AztecAddress) -> ContractInstance {\n    get_contract_instance_oracle(address)\n}\n\n// NOTE: this is for use in private only\npub fn get_contract_instance(address: AztecAddress) -> ContractInstance {\n    // Safety: The to_address function combines all values in the instance object to produce an address,\n    // so by checking that we get the expected address we validate the entire struct.\n    let instance = unsafe { get_contract_instance_internal(address) };\n    assert_eq(instance.to_address(), address);\n\n    instance\n}\n\n// These oracles each return a ContractInstance member\n// plus a boolean indicating whether the instance was found.\n#[oracle(avmOpcodeGetContractInstanceDeployer)]\nunconstrained fn get_contract_instance_deployer_oracle_avm(\n    _address: AztecAddress,\n) -> (Field, bool) {}\n#[oracle(avmOpcodeGetContractInstanceClassId)]\nunconstrained fn get_contract_instance_class_id_oracle_avm(\n    _address: AztecAddress,\n) -> (Field, bool) {}\n#[oracle(avmOpcodeGetContractInstanceInitializationHash)]\nunconstrained fn get_contract_instance_initialization_hash_oracle_avm(\n    _address: AztecAddress,\n) -> (Field, bool) {}\n\npub unconstrained fn get_contract_instance_deployer_internal_avm(\n    address: AztecAddress,\n) -> (Field, bool) {\n    get_contract_instance_deployer_oracle_avm(address)\n}\npub unconstrained fn get_contract_instance_class_id_internal_avm(\n    address: AztecAddress,\n) -> (Field, bool) {\n    get_contract_instance_class_id_oracle_avm(address)\n}\npub unconstrained fn get_contract_instance_initialization_hash_internal_avm(\n    address: AztecAddress,\n) -> (Field, bool) {\n    get_contract_instance_initialization_hash_oracle_avm(address)\n}\n\npub fn get_contract_instance_deployer_avm(address: AztecAddress) -> Option<AztecAddress> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let (member, exists) = unsafe { get_contract_instance_deployer_internal_avm(address) };\n    if exists {\n        Option::some(AztecAddress::from_field(member))\n    } else {\n        Option::none()\n    }\n}\npub fn get_contract_instance_class_id_avm(address: AztecAddress) -> Option<ContractClassId> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let (member, exists) = unsafe { get_contract_instance_class_id_internal_avm(address) };\n    if exists {\n        Option::some(ContractClassId::from_field(member))\n    } else {\n        Option::none()\n    }\n}\npub fn get_contract_instance_initialization_hash_avm(address: AztecAddress) -> Option<Field> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let (member, exists) =\n        unsafe { get_contract_instance_initialization_hash_internal_avm(address) };\n    if exists {\n        Option::some(member)\n    } else {\n        Option::none()\n    }\n}\n"
    },
    "155": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.2/noir-projects/aztec-nr/aztec/src/state_vars/map.nr",
      "source": "use crate::state_vars::storage::Storage;\nuse dep::protocol_types::{storage::map::derive_storage_slot_in_map, traits::{Packable, ToField}};\n\n// docs:start:map\npub struct Map<K, V, Context> {\n    context: Context,\n    storage_slot: Field,\n    state_var_constructor: fn(Context, Field) -> V,\n}\n// docs:end:map\n\nimpl<K, T, Context, let N: u32> Storage<N> for Map<K, T, Context>\nwhere\n    T: Packable<N>,\n{\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<K, V, Context> Map<K, V, Context> {\n    // docs:start:new\n    pub fn new(\n        context: Context,\n        storage_slot: Field,\n        state_var_constructor: fn(Context, Field) -> V,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Map { context, storage_slot, state_var_constructor }\n    }\n    // docs:end:new\n\n    // docs:start:at\n    pub fn at(self, key: K) -> V\n    where\n        K: ToField,\n    {\n        // TODO(#1204): use a generator index for the storage slot\n        let derived_storage_slot = derive_storage_slot_in_map(self.storage_slot, key);\n\n        let state_var_constructor = self.state_var_constructor;\n        state_var_constructor(self.context, derived_storage_slot)\n    }\n    // docs:end:at\n}\n"
    },
    "164": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.2/noir-projects/aztec-nr/aztec/src/state_vars/public_mutable.nr",
      "source": "use crate::context::{PublicContext, UtilityContext};\nuse crate::state_vars::storage::Storage;\nuse dep::protocol_types::traits::Packable;\n\n// docs:start:public_mutable_struct\npub struct PublicMutable<T, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:public_mutable_struct\n\nimpl<T, Context, let N: u32> Storage<N> for PublicMutable<T, Context>\nwhere\n    T: Packable<N>,\n{\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<T, Context> PublicMutable<T, Context> {\n    // docs:start:public_mutable_struct_new\n    pub fn new(\n        // Note: Passing the contexts to new(...) just to have an interface compatible with a Map.\n        context: Context,\n        storage_slot: Field,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PublicMutable { context, storage_slot }\n    }\n    // docs:end:public_mutable_struct_new\n}\n\nimpl<T> PublicMutable<T, &mut PublicContext> {\n    // docs:start:public_mutable_struct_read\n    pub fn read<let T_PACKED_LEN: u32>(self) -> T\n    where\n        T: Packable<T_PACKED_LEN>,\n    {\n        self.context.storage_read(self.storage_slot)\n    }\n    // docs:end:public_mutable_struct_read\n\n    // docs:start:public_mutable_struct_write\n    pub fn write<let T_PACKED_LEN: u32>(self, value: T)\n    where\n        T: Packable<T_PACKED_LEN>,\n    {\n        self.context.storage_write(self.storage_slot, value);\n    }\n    // docs:end:public_mutable_struct_write\n}\n\nimpl<T> PublicMutable<T, UtilityContext> {\n    pub unconstrained fn read<let T_PACKED_LEN: u32>(self) -> T\n    where\n        T: Packable<T_PACKED_LEN>,\n    {\n        self.context.storage_read(self.storage_slot)\n    }\n}\n"
    },
    "20": {
      "path": "std/hash/poseidon2.nr",
      "source": "use crate::default::Default;\nuse crate::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub(crate) struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub(crate) fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub(crate) struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n"
    },
    "219": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.2/noir-projects/noir-protocol-circuits/crates/types/src/abis/function_selector.nr",
      "source": "use crate::traits::{Deserialize, Empty, FromField, Serialize, ToField};\n\npub struct FunctionSelector {\n    // 1st 4-bytes of abi-encoding of function.\n    pub inner: u32,\n}\n\nimpl Eq for FunctionSelector {\n    fn eq(self, function_selector: FunctionSelector) -> bool {\n        function_selector.inner == self.inner\n    }\n}\n\nimpl Serialize<1> for FunctionSelector {\n    fn serialize(self: Self) -> [Field; 1] {\n        [self.inner as Field]\n    }\n}\n\nimpl Deserialize<1> for FunctionSelector {\n    fn deserialize(fields: [Field; 1]) -> Self {\n        Self { inner: fields[0] as u32 }\n    }\n}\n\nimpl FromField for FunctionSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for FunctionSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for FunctionSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl FunctionSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = crate::hash::poseidon2_hash_bytes(bytes);\n\n        // `hash` is automatically truncated to fit within 32 bits.\n        FunctionSelector::from_field(hash)\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n\n#[test]\nfn test_is_valid_selector() {\n    let selector = FunctionSelector::from_signature(\"IS_VALID()\");\n    assert_eq(selector.to_field(), 0x73cdda47);\n}\n\n#[test]\nfn test_long_selector() {\n    let selector =\n        FunctionSelector::from_signature(\"foo_and_bar_and_baz_and_foo_bar_baz_and_bar_foo\");\n    assert_eq(selector.to_field(), 0x7590a997);\n}\n"
    },
    "22": {
      "path": "std/lib.nr",
      "source": "pub mod hash;\npub mod aes128;\npub mod array;\npub mod slice;\npub mod ecdsa_secp256k1;\npub mod ecdsa_secp256r1;\npub mod embedded_curve_ops;\npub mod field;\npub mod collections;\npub mod compat;\npub mod convert;\npub mod option;\npub mod string;\npub mod test;\npub mod cmp;\npub mod ops;\npub mod default;\npub mod prelude;\npub mod runtime;\npub mod meta;\npub mod append;\npub mod mem;\npub mod panic;\npub mod hint;\n\nuse convert::AsPrimitive;\n\n// Oracle calls are required to be wrapped in an unconstrained function\n// Thus, the only argument to the `println` oracle is expected to always be an ident\n#[oracle(print)]\nunconstrained fn print_oracle<T>(with_newline: bool, input: T) {}\n\nunconstrained fn print_unconstrained<T>(with_newline: bool, input: T) {\n    print_oracle(with_newline, input);\n}\n\npub fn println<T>(input: T) {\n    // Safety: a print statement cannot be constrained\n    unsafe {\n        print_unconstrained(true, input);\n    }\n}\n\npub fn print<T>(input: T) {\n    // Safety: a print statement cannot be constrained\n    unsafe {\n        print_unconstrained(false, input);\n    }\n}\n\npub fn verify_proof<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n) {\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, 0);\n}\n\npub fn verify_proof_with_type<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {\n    if !crate::runtime::is_unconstrained() {\n        crate::assert_constant(proof_type);\n    }\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, proof_type);\n}\n\n#[foreign(recursive_aggregation)]\nfn verify_proof_internal<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {}\n\n// Asserts that the given value is known at compile-time.\n// Useful for debugging for-loop bounds.\n#[builtin(assert_constant)]\npub fn assert_constant<T>(x: T) {}\n\n// Asserts that the given value is both true and known at compile-time\n#[builtin(static_assert)]\npub fn static_assert<let N: u32>(predicate: bool, message: str<N>) {}\n\npub fn wrapping_add<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() + y.as_())\n}\n\npub fn wrapping_sub<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    //340282366920938463463374607431768211456 is 2^128, it is used to avoid underflow\n    AsPrimitive::as_(x.as_() + 340282366920938463463374607431768211456 - y.as_())\n}\n\npub fn wrapping_mul<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() * y.as_())\n}\n\n#[builtin(as_witness)]\npub fn as_witness(x: Field) {}\n\nmod tests {\n    use super::wrapping_mul;\n\n    #[test(should_fail_with = \"custom message\")]\n    fn test_static_assert_custom_message() {\n        super::static_assert(1 == 2, \"custom message\");\n    }\n\n    #[test(should_fail)]\n    fn test_wrapping_mul() {\n        // This currently fails.\n        // See: https://github.com/noir-lang/noir/issues/7528\n        let zero: u128 = 0;\n        let one: u128 = 1;\n        let two_pow_64: u128 = 0x10000000000000000;\n        let u128_max: u128 = 0xffffffffffffffffffffffffffffffff;\n\n        // 1*0==0\n        assert_eq(zero, wrapping_mul(zero, one));\n\n        // 0*1==0\n        assert_eq(zero, wrapping_mul(one, zero));\n\n        // 1*1==1\n        assert_eq(one, wrapping_mul(one, one));\n\n        // 0 * ( 1 << 64 ) ==  0\n        assert_eq(zero, wrapping_mul(zero, two_pow_64));\n\n        // ( 1 << 64 ) * 0 == 0\n        assert_eq(zero, wrapping_mul(two_pow_64, zero));\n\n        // 1 * ( 1 << 64 ) == 1 << 64\n        assert_eq(two_pow_64, wrapping_mul(two_pow_64, one));\n\n        // ( 1 << 64 ) * 1 == 1 << 64\n        assert_eq(two_pow_64, wrapping_mul(one, two_pow_64));\n\n        // ( 1 << 64 ) * ( 1 << 64 ) == 1 << 64\n        assert_eq(zero, wrapping_mul(two_pow_64, two_pow_64));\n        // -1 * -1 == 1\n        assert_eq(one, wrapping_mul(u128_max, u128_max));\n    }\n}\n"
    },
    "262": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.2/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr",
      "source": "use crate::{\n    address::{\n        partial_address::PartialAddress, salted_initialization_hash::SaltedInitializationHash,\n    },\n    constants::{\n        AZTEC_ADDRESS_LENGTH, GENERATOR_INDEX__CONTRACT_ADDRESS_V1, MAX_FIELD_VALUE,\n        MAX_PROTOCOL_CONTRACTS,\n    },\n    contract_class_id::ContractClassId,\n    hash::poseidon2_hash_with_separator,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, ToPoint, TpkM},\n    traits::{Deserialize, Empty, FromField, Packable, Serialize, ToField},\n    utils::field::{pow, sqrt},\n};\n\n// We do below because `use crate::point::Point;` does not work\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\n\nuse crate::public_keys::AddressPoint;\nuse std::{\n    embedded_curve_ops::{EmbeddedCurveScalar, fixed_base_scalar_mul as derive_public_key},\n    ops::Add,\n};\n\n// Aztec address\npub struct AztecAddress {\n    pub inner: Field,\n}\n\nimpl Eq for AztecAddress {\n    fn eq(self, other: Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self { inner: 0 }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for AztecAddress {\n    fn from_field(value: Field) -> AztecAddress {\n        AztecAddress { inner: value }\n    }\n}\n\nimpl Serialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn serialize(self: Self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn deserialize(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        FromField::from_field(fields[0])\n    }\n}\n\n/// We implement the Packable trait for AztecAddress because it can be stored in contract's storage (and there\n/// the implementation of Packable is required).\nimpl Packable<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn pack(self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        self.serialize()\n    }\n\n    fn unpack(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        Self::deserialize(fields)\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn to_address_point(self) -> AddressPoint {\n        // We compute the address point by taking our address, setting it to x, and then solving for y in the\n        // equation which defines our bn curve:\n        // y^2 = x^3 - 17; x = address\n        let x = self.inner;\n        let y_squared = pow(x, 3) - 17;\n\n        // TODO (#8970): Handle cases where we cannot recover a point from an address\n        let mut y = sqrt(y_squared);\n\n        // If we get a negative y coordinate (any y where y > MAX_FIELD_VALUE / 2), we pin it to the\n        // positive one (any value where y <= MAX_FIELD_VALUE / 2) by subtracting it from the Field modulus\n        // note: The field modulus is MAX_FIELD_VALUE + 1\n        if (!(y.lt(MAX_FIELD_VALUE / 2) | y.eq(MAX_FIELD_VALUE / 2))) {\n            y = (MAX_FIELD_VALUE + 1) - y;\n        }\n\n        AddressPoint { inner: Point { x: self.inner, y, is_infinite: false } }\n    }\n\n    pub fn compute(public_keys: PublicKeys, partial_address: PartialAddress) -> AztecAddress {\n        let public_keys_hash = public_keys.hash();\n\n        let pre_address = poseidon2_hash_with_separator(\n            [public_keys_hash.to_field(), partial_address.to_field()],\n            GENERATOR_INDEX__CONTRACT_ADDRESS_V1,\n        );\n\n        let address_point = derive_public_key(EmbeddedCurveScalar::from_field(pre_address)).add(\n            public_keys.ivpk_m.to_point(),\n        );\n\n        // Note that our address is only the x-coordinate of the full address_point. This is okay because when people want to encrypt something and send it to us\n        // they can recover our full point using the x-coordinate (our address itself). To do this, they recompute the y-coordinate according to the equation y^2 = x^3 - 17.\n        // When they do this, they may get a positive y-coordinate (a value that is less than or equal to MAX_FIELD_VALUE / 2) or\n        // a negative y-coordinate (a value that is more than MAX_FIELD_VALUE), and we cannot dictate which one they get and hence the recovered point may sometimes be different than the one\n        // our secret can decrypt. Regardless though, they should and will always encrypt using point with the positive y-coordinate by convention.\n        // This ensures that everyone encrypts to the same point given an arbitrary x-coordinate (address). This is allowed because even though our original point may not have a positive y-coordinate,\n        // with our original secret, we will be able to derive the secret to the point with the flipped (and now positive) y-coordinate that everyone encrypts to.\n        AztecAddress::from_field(address_point.x)\n    }\n\n    pub fn compute_from_class_id(\n        contract_class_id: ContractClassId,\n        salted_initialization_hash: SaltedInitializationHash,\n        public_keys: PublicKeys,\n    ) -> Self {\n        let partial_address = PartialAddress::compute_from_salted_initialization_hash(\n            contract_class_id,\n            salted_initialization_hash,\n        );\n\n        AztecAddress::compute(public_keys, partial_address)\n    }\n\n    pub fn is_protocol_contract(self) -> bool {\n        self.inner.lt(MAX_PROTOCOL_CONTRACTS as Field)\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n\n#[test]\nfn compute_address_from_partial_and_pub_keys() {\n    let public_keys = PublicKeys {\n        npk_m: NpkM {\n            inner: Point {\n                x: 0x22f7fcddfa3ce3e8f0cc8e82d7b94cdd740afa3e77f8e4a63ea78a239432dcab,\n                y: 0x0471657de2b6216ade6c506d28fbc22ba8b8ed95c871ad9f3e3984e90d9723a7,\n                is_infinite: false,\n            },\n        },\n        ivpk_m: IvpkM {\n            inner: Point {\n                x: 0x111223493147f6785514b1c195bb37a2589f22a6596d30bb2bb145fdc9ca8f1e,\n                y: 0x273bbffd678edce8fe30e0deafc4f66d58357c06fd4a820285294b9746c3be95,\n                is_infinite: false,\n            },\n        },\n        ovpk_m: OvpkM {\n            inner: Point {\n                x: 0x09115c96e962322ffed6522f57194627136b8d03ac7469109707f5e44190c484,\n                y: 0x0c49773308a13d740a7f0d4f0e6163b02c5a408b6f965856b6a491002d073d5b,\n                is_infinite: false,\n            },\n        },\n        tpk_m: TpkM {\n            inner: Point {\n                x: 0x00d3d81beb009873eb7116327cf47c612d5758ef083d4fda78e9b63980b2a762,\n                y: 0x2f567d22d2b02fe1f4ad42db9d58a36afd1983e7e2909d1cab61cafedad6193a,\n                is_infinite: false,\n            },\n        },\n    };\n\n    let partial_address = PartialAddress::from_field(\n        0x0a7c585381b10f4666044266a02405bf6e01fa564c8517d4ad5823493abd31de,\n    );\n\n    let address = AztecAddress::compute(public_keys, partial_address);\n\n    // The following value was generated by `derivation.test.ts`.\n    // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n    let expected_computed_address_from_partial_and_pubkeys =\n        0x24e4646f58b9fbe7d38e317db8d5636c423fbbdfbe119fc190fe9c64747e0c62;\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkeys);\n}\n\n#[test]\nfn compute_preaddress_from_partial_and_pub_keys() {\n    let pre_address = poseidon2_hash_with_separator([1, 2], GENERATOR_INDEX__CONTRACT_ADDRESS_V1);\n    let expected_computed_preaddress_from_partial_and_pubkey =\n        0x23ce9be3fa3c846b0f9245cc796902e731d04f086e8a42473bb29e405fc98075;\n    assert(pre_address == expected_computed_preaddress_from_partial_and_pubkey);\n}\n\n#[test]\nfn from_field_to_field() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(FromField::from_field(address.to_field()), address);\n}\n\n#[test]\nfn serde() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(Deserialize::deserialize(address.serialize()), address);\n}\n"
    },
    "280": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.2/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr",
      "source": "use crate::{\n    abis::{\n        contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n        contract_class_log::ContractClassLog,\n        function_selector::FunctionSelector,\n        note_hash::ScopedNoteHash,\n        nullifier::ScopedNullifier,\n        private_log::{PrivateLog, PrivateLogData},\n        side_effect::{OrderedValue, scoped::Scoped},\n    },\n    address::{AztecAddress, EthAddress},\n    constants::{\n        FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__NOTE_HASH_NONCE, GENERATOR_INDEX__OUTER_NULLIFIER,\n        GENERATOR_INDEX__SILOED_NOTE_HASH, GENERATOR_INDEX__UNIQUE_NOTE_HASH, TWO_POW_64,\n    },\n    merkle_tree::root::root_from_sibling_path,\n    messaging::l2_to_l1_message::{L2ToL1Message, ScopedL2ToL1Message},\n    poseidon2::Poseidon2Sponge,\n    traits::{FromField, Hash, ToField},\n    utils::{\n        arrays::{array_concat, unsafe_padded_array_length},\n        field::{field_from_bytes, field_from_bytes_32_trunc},\n    },\n};\n\npub fn sha256_to_field<let N: u32>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = sha256::digest(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT],\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(\n        function_leaf,\n        function_leaf_index,\n        function_leaf_sibling_path,\n    )\n}\n\npub fn compute_note_hash_nonce(first_nullifier_in_tx: Field, note_index_in_tx: u32) -> Field {\n    // Hashing the first nullifier with note index in tx is guaranteed to be unique (because all nullifiers are also\n    // unique).\n    poseidon2_hash_with_separator(\n        [first_nullifier_in_tx, note_index_in_tx as Field],\n        GENERATOR_INDEX__NOTE_HASH_NONCE,\n    )\n}\n\npub fn compute_unique_note_hash(nonce: Field, siloed_note_hash: Field) -> Field {\n    let inputs = [nonce, siloed_note_hash];\n    poseidon2_hash_with_separator(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\npub fn compute_siloed_note_hash(app: AztecAddress, note_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), note_hash],\n        GENERATOR_INDEX__SILOED_NOTE_HASH,\n    )\n}\n\n/// Computes unique note hashes from siloed note hashes\npub fn compute_unique_siloed_note_hash(\n    siloed_note_hash: Field,\n    first_nullifier: Field,\n    note_index_in_tx: u32,\n) -> Field {\n    if siloed_note_hash == 0 {\n        0\n    } else {\n        let nonce = compute_note_hash_nonce(first_nullifier, note_index_in_tx);\n        compute_unique_note_hash(nonce, siloed_note_hash)\n    }\n}\n\n/// Siloing in the context of Aztec refers to the process of hashing a note hash with a contract address (this way\n/// the note hash is scoped to a specific contract). This is used to prevent intermingling of notes between contracts.\npub fn silo_note_hash(note_hash: ScopedNoteHash) -> Field {\n    if note_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_note_hash(note_hash.contract_address, note_hash.value())\n    }\n}\n\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), nullifier],\n        GENERATOR_INDEX__OUTER_NULLIFIER,\n    )\n}\n\npub fn silo_nullifier(nullifier: ScopedNullifier) -> Field {\n    if nullifier.contract_address.is_zero() {\n        nullifier.value() // Return value instead of 0 because the first nullifier's contract address is zero.\n    } else {\n        compute_siloed_nullifier(nullifier.contract_address, nullifier.value())\n    }\n}\n\npub fn compute_siloed_private_log_field(contract_address: AztecAddress, field: Field) -> Field {\n    poseidon2_hash([contract_address.to_field(), field])\n}\n\npub fn silo_private_log(private_log: Scoped<PrivateLogData>) -> PrivateLog {\n    if private_log.contract_address.is_zero() {\n        private_log.inner.log\n    } else {\n        let mut fields = private_log.inner.log.fields;\n        fields[0] = compute_siloed_private_log_field(private_log.contract_address, fields[0]);\n        PrivateLog { fields }\n    }\n}\n\nfn compute_siloed_contract_class_log_field(\n    contract_address: AztecAddress,\n    first_field: Field,\n) -> Field {\n    poseidon2_hash([contract_address.to_field(), first_field])\n}\n\npub fn silo_contract_class_log(contract_class_log: ContractClassLog) -> ContractClassLog {\n    if contract_class_log.contract_address.is_zero() {\n        contract_class_log\n    } else {\n        let mut log = contract_class_log;\n        log.log.fields[0] = compute_siloed_contract_class_log_field(\n            contract_class_log.contract_address,\n            log.log.fields[0],\n        );\n        log\n    }\n}\n\npub fn compute_contract_class_log_hash(contract_class_log: ContractClassLog) -> Field {\n    let array = contract_class_log.log.fields;\n    // Safety: The below length is constrained in the base rollup.\n    let length = unsafe { unsafe_padded_array_length(array) };\n    if length == 0 {\n        0\n    } else {\n        poseidon2_hash(array)\n    }\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    poseidon2_hash([left, right])\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    recipient: EthAddress,\n    content: Field,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    let mut bytes: [u8; 160] = std::mem::zeroed();\n\n    let inputs =\n        [contract_address.to_field(), rollup_version_id, recipient.to_field(), chain_id, content];\n    for i in 0..5 {\n        // TODO are bytes be in fr.to_buffer() ?\n        let item_bytes: [u8; 32] = inputs[i].to_be_bytes();\n        for j in 0..32 {\n            bytes[32 * i + j] = item_bytes[j];\n        }\n    }\n\n    sha256_to_field(bytes)\n}\n\npub fn silo_l2_to_l1_message(\n    msg: ScopedL2ToL1Message,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    if msg.contract_address.is_zero() {\n        0\n    } else {\n        compute_l2_to_l1_hash(\n            msg.contract_address,\n            msg.message.recipient,\n            msg.message.content,\n            rollup_version_id,\n            chain_id,\n        )\n    }\n}\n\n// Computes sha256 hash of 2 input hashes.\n//\n// NB: This method now takes in two 31 byte fields - it assumes that any input\n// is the result of a sha_to_field hash and => is truncated\n//\n// TODO(Jan and David): This is used for the encrypted_log hashes.\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\n//\npub fn accumulate_sha256(input: [Field; 2]) -> Field {\n    // This is a note about the cpp code, since it takes an array of Fields\n    // instead of a u128.\n    // 4 Field elements when converted to bytes will usually\n    // occupy 4 * 32 = 128 bytes.\n    // However, this function is making the assumption that each Field\n    // only occupies 128 bits.\n    //\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\n    // Concatentate two fields into 32x2 = 64 bytes\n    // accumulate_sha256 assumes that the inputs are pre-truncated 31 byte numbers\n    let mut hash_input_flattened = [0; 64];\n    for offset in 0..input.len() {\n        let input_as_bytes: [u8; 32] = input[offset].to_be_bytes();\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n\n    sha256_to_field(hash_input_flattened)\n}\n\npub fn verification_key_hash<let N: u32>(key: [Field; N]) -> Field {\n    crate::hash::poseidon2_hash(key)\n}\n\n#[inline_always]\npub fn pedersen_hash<let N: u32>(inputs: [Field; N], hash_index: u32) -> Field {\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<let N: u32>(inputs: [Field; N]) -> Field {\n    std::hash::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[no_predicates]\npub fn poseidon2_hash_with_separator<let N: u32, T>(inputs: [Field; N], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let inputs_with_separator = array_concat([separator.to_field()], inputs);\n    poseidon2_hash(inputs_with_separator)\n}\n\n// Performs a fixed length hash with a subarray of the given input.\n// Useful for SpongeBlob in which we aborb M things and want to check it vs a hash of M elts of an N-len array.\n// Using stdlib poseidon, this will always absorb an extra 1 as a 'variable' hash, and not match spongeblob.squeeze()\n// or any ts implementation. Also checks that any remaining elts not hashed are empty.\n#[no_predicates]\npub fn poseidon2_hash_subarray<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_chunks(input, in_len, false);\n    sponge.squeeze()\n}\n\n// NB the below is the same as std::hash::poseidon2::Poseidon2::hash(), but replacing a range check with a bit check,\n// and absorbing in chunks of 3 below.\n#[no_predicates]\npub fn poseidon2_cheaper_variable_hash<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_chunks(input, in_len, true);\n    // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n    // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n    // fixed-length and variable-length hashes do not collide)\n    if in_len != N {\n        sponge.absorb(1);\n    }\n    sponge.squeeze()\n}\n\n// The below fn reduces gates of a conditional poseidon2 hash by approx 3x (thank you ~* Giant Brain Dev @IlyasRidhuan *~ for the idea)\n// Why? Because when we call stdlib poseidon, we call absorb for each item. When absorbing is conditional, it seems the compiler does not know\n// what cache_size will be when calling absorb, so it assigns the permutation gates for /each i/ rather than /every 3rd i/, which is actually required.\n// The below code forces the compiler to:\n//  - absorb normally up to 2 times to set cache_size to 1\n//  - absorb in chunks of 3 to ensure perm. only happens every 3rd absorb\n//  - absorb normally up to 2 times to add any remaining values to the hash\n// In fixed len hashes, the compiler is able to tell that it will only need to perform the permutation every 3 absorbs.\n// NB: it also replaces unnecessary range checks (i < thing) with a bit check (&= i != thing), which alone reduces the gates of a var. hash by half.\n\n#[no_predicates]\nfn poseidon2_absorb_chunks<let N: u32>(\n    input: [Field; N],\n    in_len: u32,\n    variable: bool,\n) -> Poseidon2Sponge {\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    // Even though shift is always 1 here, if we input in_len = 0 we get an underflow\n    // since we cannot isolate computation branches. The below is just to avoid that.\n    let shift = if in_len == 0 { 0 } else { 1 };\n    if in_len != 0 {\n        // cache_size = 0, init absorb\n        sponge.cache[0] = input[0];\n        sponge.cache_size = 1;\n        // shift = num elts already added to make cache_size 1 = 1 for a fresh sponge\n        // M = max_chunks = (N - 1 - (N - 1) % 3) / 3: (must be written as a fn of N to compile)\n        // max_remainder = (N - 1) % 3;\n        // max_chunks = (N - 1 - max_remainder) / 3;\n        sponge = poseidon2_absorb_chunks_loop::<N, (N - 1 - (N - 1) % 3) / 3>(\n            sponge,\n            input,\n            in_len,\n            variable,\n            shift,\n        );\n    }\n    sponge\n}\n\n// NB: If it's not required to check that the non-absorbed elts of 'input' are 0s, set skip_0_check=true\n#[no_predicates]\npub fn poseidon2_absorb_chunks_existing_sponge<let N: u32>(\n    in_sponge: Poseidon2Sponge,\n    input: [Field; N],\n    in_len: u32,\n    skip_0_check: bool,\n) -> Poseidon2Sponge {\n    let mut sponge = in_sponge;\n    // 'shift' is to account for already added inputs\n    let mut shift = 0;\n    // 'stop' is to avoid an underflow when inputting in_len = 0\n    let mut stop = false;\n    for i in 0..3 {\n        if shift == in_len {\n            stop = true;\n        }\n        if (sponge.cache_size != 1) & (!stop) {\n            sponge.absorb(input[i]);\n            shift += 1;\n        }\n    }\n    sponge = if stop {\n        sponge\n    } else {\n        // max_chunks = (N - (N % 3)) / 3;\n        poseidon2_absorb_chunks_loop::<N, (N - (N % 3)) / 3>(\n            sponge,\n            input,\n            in_len,\n            skip_0_check,\n            shift,\n        )\n    };\n    sponge\n}\n\n// The below is the loop to absorb elts into a poseidon sponge in chunks of 3\n// shift - the num of elts already absorbed to ensure the sponge's cache_size = 1\n// M - the max number of chunks required to absorb N things (must be comptime to compile)\n// NB: The 0 checks ('Found non-zero field...') are messy, but having a separate loop over N to check\n// for 0s costs 3N gates. Current approach is approx 2N gates.\n#[no_predicates]\nfn poseidon2_absorb_chunks_loop<let N: u32, let M: u32>(\n    in_sponge: Poseidon2Sponge,\n    input: [Field; N],\n    in_len: u32,\n    variable: bool,\n    shift: u32,\n) -> Poseidon2Sponge {\n    assert(in_len <= N, \"Given in_len to absorb is larger than the input array len\");\n    // When we have an existing sponge, we may have a shift of 0, and the final 'k+2' below = N\n    // The below avoids an overflow\n    let skip_last = 3 * M == N;\n    // Writing in_sponge: &mut does not compile\n    let mut sponge = in_sponge;\n    let mut should_add = true;\n    // The num of things left over after absorbing in 3s\n    let remainder = (in_len - shift) % 3;\n    // The num of chunks of 3 to absorb (maximum M)\n    let chunks = (in_len - shift - remainder) / 3;\n    for i in 0..M {\n        // Now we loop through cache size = 1 -> 3\n        should_add &= i != chunks;\n        // This is the index at the start of the chunk (for readability)\n        let k = 3 * i + shift;\n        if should_add {\n            // cache_size = 1, 2 => just assign\n            sponge.cache[1] = input[k];\n            sponge.cache[2] = input[k + 1];\n            // cache_size = 3 => duplex + perm\n            for j in 0..3 {\n                sponge.state[j] += sponge.cache[j];\n            }\n            sponge.state = std::hash::poseidon2_permutation(sponge.state, 4);\n            sponge.cache[0] = input[k + 2];\n            // cache_size is now 1 again, repeat loop\n        } else if (!variable) & (i != chunks) {\n            // if we are hashing a fixed len array which is a subarray, we check the remaining elts are 0\n            // NB: we don't check at i == chunks, because that chunk contains elts to be absorbed or checked below\n            let last_0 = if (i == M - 1) & (skip_last) {\n                0\n            } else {\n                input[k + 2]\n            };\n            let all_0 = (input[k] == 0) & (input[k + 1] == 0) & (last_0 == 0);\n            assert(all_0, \"Found non-zero field after breakpoint\");\n        }\n    }\n    // we have 'remainder' num of items left to absorb\n    should_add = true;\n    // below is to avoid overflows (i.e. if inlen is close to N)\n    let mut should_check = !variable;\n    for i in 0..3 {\n        should_add &= i != remainder;\n        should_check &= in_len - remainder + i != N;\n        if should_add {\n            // we want to absorb the final 'remainder' items\n            sponge.absorb(input[in_len - remainder + i]);\n        } else if should_check {\n            assert(input[in_len - remainder + i] == 0, \"Found non-zero field after breakpoint\");\n        }\n    }\n    sponge\n}\n\npub fn poseidon2_hash_with_separator_slice<T>(inputs: [Field], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let in_len = inputs.len() + 1;\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs[i]);\n    }\n\n    sponge.squeeze()\n}\n\n#[no_predicates]\npub fn poseidon2_hash_bytes<let N: u32>(inputs: [u8; N]) -> Field {\n    let mut fields = [0; (N + 30) / 31];\n    let mut field_index = 0;\n    let mut current_field = [0; 31];\n    for i in 0..inputs.len() {\n        let index = i % 31;\n        current_field[index] = inputs[i];\n        if index == 30 {\n            fields[field_index] = field_from_bytes(current_field, false);\n            current_field = [0; 31];\n            field_index += 1;\n        }\n    }\n    if field_index != fields.len() {\n        fields[field_index] = field_from_bytes(current_field, false);\n    }\n    poseidon2_hash(fields)\n}\n\n#[test]\nfn poseidon_chunks_matches_fixed() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut fixed_input = [3; 501];\n    assert(in_len == fixed_input.len()); // sanity check\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let sub_chunk_hash = poseidon2_hash_subarray(input, in_len);\n    let fixed_len_hash = std::hash::poseidon2::Poseidon2::hash(fixed_input, fixed_input.len());\n    assert(sub_chunk_hash == fixed_len_hash);\n}\n\n#[test]\nfn poseidon_chunks_matches_variable() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let variable_chunk_hash = poseidon2_cheaper_variable_hash(input, in_len);\n    let variable_len_hash = std::hash::poseidon2::Poseidon2::hash(input, in_len);\n    assert(variable_chunk_hash == variable_len_hash);\n}\n\n#[test]\nfn existing_sponge_poseidon_chunks_matches_fixed() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut fixed_input = [3; 501];\n    assert(in_len == fixed_input.len()); // sanity check\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    // absorb 250 of the 501 things\n    let empty_sponge = Poseidon2Sponge::new((in_len as Field) * TWO_POW_64);\n    let first_sponge = poseidon2_absorb_chunks_existing_sponge(empty_sponge, input, 250, true);\n    // now absorb the final 251 (since they are all 3s, im being lazy and not making a new array)\n    let mut final_sponge = poseidon2_absorb_chunks_existing_sponge(first_sponge, input, 251, true);\n    let fixed_len_hash = Poseidon2Sponge::hash(fixed_input, fixed_input.len());\n    assert(final_sponge.squeeze() == fixed_len_hash);\n}\n\n#[test]\nfn poseidon_chunks_empty_inputs() {\n    let in_len = 0;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut constructed_empty_sponge = poseidon2_absorb_chunks(input, in_len, true);\n    let mut first_sponge =\n        poseidon2_absorb_chunks_existing_sponge(constructed_empty_sponge, input, in_len, true);\n    assert(first_sponge.squeeze() == constructed_empty_sponge.squeeze());\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n        25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,\n        48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70,\n        71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93,\n        94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112,\n        113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130,\n        131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148,\n        149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159,\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = sha256::digest(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result =\n        compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\n    assert(hash_result == 0xb393978842a0fa3d3e1470196f098f473f9678e72463cb65ec4ab5581856c2);\n\n    // Non-zero case\n    let hash_result = compute_l2_to_l1_hash(\n        AztecAddress::from_field(1),\n        EthAddress::from_field(3),\n        5,\n        2,\n        4,\n    );\n    assert(hash_result == 0x3f88c1044a05e5340ed20466276500f6d45ca5603913b9091e957161734e16);\n}\n\n#[test]\nfn silo_l2_to_l1_message_matches_typescript() {\n    let version = 4;\n    let chainId = 5;\n\n    let hash = silo_l2_to_l1_message(\n        ScopedL2ToL1Message {\n            message: L2ToL1Message { recipient: EthAddress::from_field(1), content: 2, counter: 0 },\n            contract_address: AztecAddress::from_field(3),\n        },\n        version,\n        chainId,\n    );\n\n    // The following value was generated by `l2_to_l1_message.test.ts`\n    let hash_from_typescript = 0x00c6155d69febb9d5039b374dd4f77bf57b7c881709aa524a18acaa0bd57476a;\n\n    assert_eq(hash, hash_from_typescript);\n}\n"
    },
    "297": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.2/noir-projects/noir-protocol-circuits/crates/types/src/poseidon2.nr",
      "source": "use crate::constants::TWO_POW_64;\n\n// NB: This is a clone of noir/noir-repo/noir_stdlib/src/hash/poseidon2.nr\n// It exists as we sometimes need to perform custom absorption, but the stdlib version\n// has a private absorb() method (it's also designed to just be a hasher)\n// Can be removed when standalone noir poseidon lib exists: See noir#6679\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2Sponge {\n    pub cache: [Field; 3],\n    pub state: [Field; 4],\n    pub cache_size: u32,\n    pub squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2Sponge {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2Sponge::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2Sponge {\n        let mut result =\n            Poseidon2Sponge { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = std::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    pub fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    pub fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let iv: Field = (in_len as Field) * TWO_POW_64;\n        let mut sponge = Poseidon2Sponge::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n"
    },
    "317": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.2/noir-projects/noir-protocol-circuits/crates/types/src/storage/map.nr",
      "source": "use crate::{hash::poseidon2_hash, traits::ToField};\n\npub fn derive_storage_slot_in_map<K>(storage_slot: Field, key: K) -> Field\nwhere\n    K: ToField,\n{\n    poseidon2_hash([storage_slot, key.to_field()])\n}\n\nmod test {\n    use crate::{address::AztecAddress, storage::map::derive_storage_slot_in_map, traits::FromField};\n\n    #[test]\n    fn test_derive_storage_slot_in_map_matches_typescript() {\n        let map_slot = 0x132258fb6962c4387ba659d9556521102d227549a386d39f0b22d1890d59c2b5;\n        let key = AztecAddress::from_field(\n            0x302dbc2f9b50a73283d5fb2f35bc01eae8935615817a0b4219a057b2ba8a5a3f,\n        );\n\n        let slot = derive_storage_slot_in_map(map_slot, key);\n\n        // The following value was generated by `map_slot.test.ts`\n        let slot_from_typescript =\n            0x15b9fe39449affd8b377461263e9d2b610b9ad40580553500b4e41d9cbd887ac;\n\n        assert_eq(slot, slot_from_typescript);\n    }\n}\n"
    },
    "336": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.2/noir-projects/noir-protocol-circuits/crates/types/src/type_serialization.nr",
      "source": "use crate::traits::{Deserialize, Serialize};\n\nglobal BOOL_SERIALIZED_LEN: u32 = 1;\nglobal U8_SERIALIZED_LEN: u32 = 1;\nglobal U16_SERIALIZED_LEN: u32 = 1;\nglobal U32_SERIALIZED_LEN: u32 = 1;\nglobal U64_SERIALIZED_LEN: u32 = 1;\nglobal U128_SERIALIZED_LEN: u32 = 1;\nglobal FIELD_SERIALIZED_LEN: u32 = 1;\nglobal I8_SERIALIZED_LEN: u32 = 1;\nglobal I16_SERIALIZED_LEN: u32 = 1;\nglobal I32_SERIALIZED_LEN: u32 = 1;\nglobal I64_SERIALIZED_LEN: u32 = 1;\n\nimpl Serialize<BOOL_SERIALIZED_LEN> for bool {\n    fn serialize(self) -> [Field; BOOL_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<BOOL_SERIALIZED_LEN> for bool {\n    fn deserialize(fields: [Field; BOOL_SERIALIZED_LEN]) -> bool {\n        fields[0] as bool\n    }\n}\n\nimpl Serialize<U8_SERIALIZED_LEN> for u8 {\n    fn serialize(self) -> [Field; U8_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U8_SERIALIZED_LEN> for u8 {\n    fn deserialize(fields: [Field; U8_SERIALIZED_LEN]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Serialize<U16_SERIALIZED_LEN> for u16 {\n    fn serialize(self) -> [Field; U16_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U16_SERIALIZED_LEN> for u16 {\n    fn deserialize(fields: [Field; U16_SERIALIZED_LEN]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Serialize<U32_SERIALIZED_LEN> for u32 {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U32_SERIALIZED_LEN> for u32 {\n    fn deserialize(fields: [Field; U32_SERIALIZED_LEN]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Serialize<U64_SERIALIZED_LEN> for u64 {\n    fn serialize(self) -> [Field; U64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U64_SERIALIZED_LEN> for u64 {\n    fn deserialize(fields: [Field; U64_SERIALIZED_LEN]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Serialize<U128_SERIALIZED_LEN> for u128 {\n    fn serialize(self) -> [Field; U128_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U128_SERIALIZED_LEN> for u128 {\n    fn deserialize(fields: [Field; U128_SERIALIZED_LEN]) -> Self {\n        fields[0] as u128\n    }\n}\n\nimpl Serialize<FIELD_SERIALIZED_LEN> for Field {\n    fn serialize(self) -> [Field; FIELD_SERIALIZED_LEN] {\n        [self]\n    }\n}\n\nimpl Deserialize<FIELD_SERIALIZED_LEN> for Field {\n    fn deserialize(fields: [Field; FIELD_SERIALIZED_LEN]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Serialize<I8_SERIALIZED_LEN> for i8 {\n    fn serialize(self) -> [Field; I8_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I8_SERIALIZED_LEN> for i8 {\n    fn deserialize(fields: [Field; I8_SERIALIZED_LEN]) -> Self {\n        fields[0] as i8\n    }\n}\n\nimpl Serialize<I16_SERIALIZED_LEN> for i16 {\n    fn serialize(self) -> [Field; I16_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I16_SERIALIZED_LEN> for i16 {\n    fn deserialize(fields: [Field; I16_SERIALIZED_LEN]) -> Self {\n        fields[0] as i16\n    }\n}\n\nimpl Serialize<I32_SERIALIZED_LEN> for i32 {\n    fn serialize(self) -> [Field; I32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I32_SERIALIZED_LEN> for i32 {\n    fn deserialize(fields: [Field; I32_SERIALIZED_LEN]) -> Self {\n        fields[0] as i32\n    }\n}\n\nimpl Serialize<I64_SERIALIZED_LEN> for i64 {\n    fn serialize(self) -> [Field; I64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I64_SERIALIZED_LEN> for i64 {\n    fn deserialize(fields: [Field; I64_SERIALIZED_LEN]) -> Self {\n        fields[0] as i64\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Serialize<N * M> for [T; N]\nwhere\n    T: Serialize<M>,\n{\n    fn serialize(self) -> [Field; N * M] {\n        let mut result: [Field; N * M] = std::mem::zeroed();\n        let mut serialized: [Field; M] = std::mem::zeroed();\n        for i in 0..N {\n            serialized = self[i].serialize();\n            for j in 0..M {\n                result[i * M + j] = serialized[j];\n            }\n        }\n        result\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Deserialize<N * M> for [T; N]\nwhere\n    T: Deserialize<M>,\n{\n    fn deserialize(fields: [Field; N * M]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; N] = std::mem::zeroed();\n        reader.read_struct_array::<T, M, N>(Deserialize::deserialize, result)\n    }\n}\n\n#[test]\nfn test_u16_serialization() {\n    let a: u16 = 10;\n    assert_eq(a, u16::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i8_serialization() {\n    let a: i8 = -10;\n    assert_eq(a, i8::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i16_serialization() {\n    let a: i16 = -10;\n    assert_eq(a, i16::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i32_serialization() {\n    let a: i32 = -10;\n    assert_eq(a, i32::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i64_serialization() {\n    let a: i64 = -10;\n    assert_eq(a, i64::deserialize(a.serialize()));\n}\n"
    },
    "352": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.2/noir-projects/noir-protocol-circuits/crates/types/src/utils/arrays.nr",
      "source": "pub mod assert_array_appended;\npub mod assert_array_prepended;\npub mod assert_combined_array;\npub mod assert_combined_transformed_array;\npub mod assert_exposed_sorted_transformed_value_array;\npub mod assert_sorted_array;\npub mod assert_sorted_transformed_value_array;\npub mod assert_split_sorted_transformed_value_arrays;\npub mod assert_split_transformed_value_arrays;\npub mod get_sorted_result;\npub mod get_sorted_tuple;\npub mod sort_by;\npub mod sort_by_counter;\n\n// Re-exports.\npub use assert_array_appended::{\n    assert_array_appended, assert_array_appended_and_scoped, assert_array_appended_reversed,\n    assert_array_appended_scoped,\n};\npub use assert_array_prepended::assert_array_prepended;\npub use assert_combined_array::{assert_combined_array, combine_arrays};\npub use assert_combined_transformed_array::{\n    assert_combined_transformed_array, combine_and_transform_arrays,\n};\npub use assert_exposed_sorted_transformed_value_array::{\n    assert_exposed_sorted_transformed_value_array,\n    get_order_hints::{get_order_hints_asc, get_order_hints_desc, OrderHint},\n};\npub use assert_sorted_array::assert_sorted_array;\npub use assert_sorted_transformed_value_array::{\n    assert_sorted_transformed_value_array, assert_sorted_transformed_value_array_capped_size,\n};\npub use assert_split_sorted_transformed_value_arrays::{\n    assert_split_sorted_transformed_value_arrays_asc,\n    assert_split_sorted_transformed_value_arrays_desc,\n    get_split_order_hints::{get_split_order_hints_asc, get_split_order_hints_desc, SplitOrderHints},\n};\npub use assert_split_transformed_value_arrays::assert_split_transformed_value_arrays;\npub use get_sorted_result::{get_sorted_result, SortedResult};\npub use sort_by_counter::{sort_by_counter_asc, sort_by_counter_desc};\n\nuse crate::traits::{Empty, is_empty};\n\npub fn subarray<let SRC_LEN: u32, let DST_LEN: u32>(\n    src: [Field; SRC_LEN],\n    offset: u32,\n) -> [Field; DST_LEN] {\n    assert(offset + DST_LEN <= SRC_LEN, \"offset too large\");\n\n    let mut dst: [Field; DST_LEN] = std::mem::zeroed();\n    for i in 0..DST_LEN {\n        dst[i] = src[i + offset];\n    }\n\n    dst\n}\n\n// Helper function to convert a validated array to BoundedVec.\n// Important: Only use it for validated arrays: validate_array(array) should be true.\npub unconstrained fn array_to_bounded_vec<T, let N: u32>(array: [T; N]) -> BoundedVec<T, N>\nwhere\n    T: Empty + Eq,\n{\n    let len = array_length(array);\n    BoundedVec::from_parts_unchecked(array, len)\n}\n\n// Helper function to find the index of the first element in an array that satisfies a given predicate. If the element\n// is not found, the function returns N as the index.\npub unconstrained fn find_index_hint<T, let N: u32, Env>(\n    array: [T; N],\n    find: fn[Env](T) -> bool,\n) -> u32 {\n    let mut index = N;\n    for i in 0..N {\n        // We check `index == N` to ensure that we only update the index if we haven't found a match yet.\n        if (index == N) & find(array[i]) {\n            index = i;\n        }\n    }\n    index\n}\n\n// Routine which validates that all zero values of an array form a contiguous region at the end, i.e.,\n// of the form: [*,*,*...,0,0,0,0] where any * is non-zero. Note that a full array of non-zero values is\n// valid.\npub fn validate_array<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    let mut seen_empty = false;\n    let mut length = 0;\n    for i in 0..N {\n        if is_empty(array[i]) {\n            seen_empty = true;\n        } else {\n            assert(seen_empty == false, \"invalid array\");\n            length += 1;\n        }\n    }\n    length\n}\n\n// Helper function to count the number of non-empty elements in a validated array.\n// Important: Only use it for validated arrays where validate_array(array) returns true,\n// which ensures that:\n// 1. All elements before the first empty element are non-empty\n// 2. All elements after and including the first empty element are empty\n// 3. The array forms a contiguous sequence of non-empty elements followed by empty elements\npub fn array_length<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    // We get the length by checking the index of the first empty element.\n\n    // Safety: This is safe because we have validated the array (see function doc above) and the emptiness\n    // of the element and non-emptiness of the previous element is checked below.\n    let length = unsafe { find_index_hint(array, |elem: T| is_empty(elem)) };\n    if length != 0 {\n        assert(!is_empty(array[length - 1]));\n    }\n    if length != N {\n        assert(is_empty(array[length]));\n    }\n    length\n}\n\npub fn array_concat<T, let N: u32, let M: u32>(array1: [T; N], array2: [T; M]) -> [T; N + M] {\n    let mut result = [array1[0]; N + M];\n    for i in 1..N {\n        result[i] = array1[i];\n    }\n    for i in 0..M {\n        result[i + N] = array2[i];\n    }\n    result\n}\n/// This function assumes that `array1` and `array2` contain no more than N non-empty elements between them,\n/// if this is not the case then elements from the end of `array2` will be dropped.\npub fn array_merge<T, let N: u32>(array1: [T; N], array2: [T; N]) -> [T; N]\nwhere\n    T: Empty + Eq,\n{\n    // Safety: we constrain this array below\n    let result = unsafe { array_merge_helper(array1, array2) };\n    // We assume arrays have been validated. The only use cases so far are with previously validated arrays.\n    let array1_len = array_length(array1);\n    let mut add_from_left = true;\n    for i in 0..N {\n        add_from_left &= i != array1_len;\n        if add_from_left {\n            assert_eq(result[i], array1[i]);\n        } else {\n            assert_eq(result[i], array2[i - array1_len]);\n        }\n    }\n    result\n}\n\nunconstrained fn array_merge_helper<T, let N: u32>(array1: [T; N], array2: [T; N]) -> [T; N]\nwhere\n    T: Empty + Eq,\n{\n    let mut result: [T; N] = [T::empty(); N];\n    let mut i = 0;\n    for elem in array1 {\n        if !is_empty(elem) {\n            result[i] = elem;\n            i += 1;\n        }\n    }\n    for elem in array2 {\n        if !is_empty(elem) {\n            result[i] = elem;\n            i += 1;\n        }\n    }\n    result\n}\n\n// Helper fn to create a subarray from a given array\npub fn array_splice<T, let N: u32, let M: u32>(array: [T; N], offset: u32) -> [T; M]\nwhere\n    T: Empty,\n{\n    assert(M + offset <= N, \"Subarray length larger than array length\");\n    let mut result: [T; M] = [T::empty(); M];\n    for i in 0..M {\n        result[i] = array[offset + i];\n    }\n    result\n}\n\npub fn check_permutation<T, let N: u32>(\n    original_array: [T; N],\n    permuted_array: [T; N],\n    original_indexes: [u32; N],\n)\nwhere\n    T: Eq + Empty,\n{\n    let mut seen_value = [false; N];\n    for i in 0..N {\n        let index = original_indexes[i];\n        let original_value = original_array[index];\n        assert(permuted_array[i].eq(original_value), \"Invalid index\");\n        assert(!seen_value[index], \"Duplicated index\");\n        seen_value[index] = true;\n    }\n}\n\n// Helper function to find the index of the last element in an array, allowing empty elements.\n// e.g. useful for removing trailing 0s from [1, 0, 2, 0, 0, 0] -> [1, 0, 2]\n// Nothing to do with validated arrays. Correctness constrained by padded_array_length.\npub unconstrained fn find_last_value_index<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    let mut index = N;\n    for i in 0..N {\n        let j = N - i - 1;\n        // We check `index == N` to ensure that we only update the index if we haven't found a match yet.\n        if (index == N) & !is_empty(array[j]) {\n            index = j;\n        }\n    }\n    index\n}\n\n// Routine which returns the length of an array right padded by empty elements\n// of the form: [*,*,*...,0,0,0,0] where * is any value (zeroes allowed).\n// See smoke_validate_array_trailing for examples.\n// Nothing to do with validated arrays. Correctness constrained by padded_array_length.\npub unconstrained fn unsafe_padded_array_length<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    let index = find_last_value_index(array);\n    if index == N {\n        0\n    } else {\n        index + 1\n    }\n}\n\n// Routine which validates that zero values of an array form a contiguous region at the end, i.e.,\n// of the form: [*,*,*...,0,0,0,0] where * is any value (zeroes allowed).\npub fn padded_array_length<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    // Safety: this value is constrained in the below loop.\n    let length = unsafe { unsafe_padded_array_length(array) };\n    // Check the elt just before length is non-zero:\n    if length != 0 {\n        assert(!is_empty(array[length - 1]), \"invalid right padded array\");\n    }\n    // Check all beyond length are zero:\n    let mut check_zero = false;\n    for i in 0..N {\n        check_zero |= i == length;\n        if check_zero {\n            assert(is_empty(array[i]), \"invalid right padded array\");\n        }\n    }\n    length\n}\n\n#[test]\nfn smoke_validate_array() {\n    let valid_array: [Field; 0] = [];\n    assert(validate_array(valid_array) == 0);\n\n    let valid_array = [0];\n    assert(validate_array(valid_array) == 0);\n\n    let valid_array = [3];\n    assert(validate_array(valid_array) == 1);\n\n    let valid_array = [1, 2, 3];\n    assert(validate_array(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0];\n    assert(validate_array(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0, 0];\n    assert(validate_array(valid_array) == 3);\n}\n\n#[test]\nfn smoke_validate_array_trailing() {\n    let valid_array: [Field; 0] = [];\n    assert(padded_array_length(valid_array) == 0);\n\n    let valid_array = [0];\n    assert(padded_array_length(valid_array) == 0);\n\n    let valid_array = [3];\n    assert(padded_array_length(valid_array) == 1);\n\n    let valid_array = [1, 0, 3];\n    assert(padded_array_length(valid_array) == 3);\n\n    let valid_array = [1, 0, 3, 0];\n    assert(padded_array_length(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0, 0];\n    assert(padded_array_length(valid_array) == 3);\n\n    let valid_array = [0, 0, 3, 0, 0];\n    assert(padded_array_length(valid_array) == 3);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case0() {\n    let invalid_array = [0, 1];\n    let _ = validate_array(invalid_array);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case1() {\n    let invalid_array = [1, 0, 0, 1, 0];\n    let _ = validate_array(invalid_array);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case2() {\n    let invalid_array = [0, 0, 0, 0, 1];\n    let _ = validate_array(invalid_array);\n}\n\n#[test]\nfn test_empty_array_length() {\n    assert_eq(array_length([0]), 0);\n    assert_eq(array_length([0, 0, 0]), 0);\n}\n\n#[test]\nfn test_array_length() {\n    assert_eq(array_length([123]), 1);\n    assert_eq(array_length([123, 0, 0]), 1);\n    assert_eq(array_length([123, 456]), 2);\n    assert_eq(array_length([123, 456, 0]), 2);\n}\n\n#[test]\nfn test_array_length_invalid_arrays() {\n    // Result can be misleading (but correct) for invalid arrays.\n    assert_eq(array_length([0, 0, 123]), 0);\n    assert_eq(array_length([0, 123, 0]), 0);\n    assert_eq(array_length([0, 123, 456]), 0);\n    assert_eq(array_length([123, 0, 456]), 1);\n}\n\n#[test]\nunconstrained fn find_index_greater_than_min() {\n    let values = [10, 20, 30, 40];\n    let min = 22;\n    let index = find_index_hint(values, |v: Field| min.lt(v));\n    assert_eq(index, 2);\n}\n\n#[test]\nunconstrained fn find_index_not_found() {\n    let values = [10, 20, 30, 40];\n    let min = 100;\n    let index = find_index_hint(values, |v: Field| min.lt(v));\n    assert_eq(index, 4);\n}\n\n#[test]\nfn test_array_concat() {\n    let array0 = [1, 2, 3];\n    let array1 = [4, 5];\n    let concatenated = array_concat(array0, array1);\n    assert_eq(concatenated, [1, 2, 3, 4, 5]);\n}\n\n#[test]\nfn check_permutation_basic_test() {\n    let original_array = [1, 2, 3];\n    let permuted_array = [3, 1, 2];\n    let indexes = [2, 0, 1];\n    check_permutation(original_array, permuted_array, indexes);\n}\n\n#[test(should_fail_with = \"Duplicated index\")]\nfn check_permutation_duplicated_index() {\n    let original_array = [0, 1, 0];\n    let permuted_array = [1, 0, 0];\n    let indexes = [1, 0, 0];\n    check_permutation(original_array, permuted_array, indexes);\n}\n\n#[test(should_fail_with = \"Invalid index\")]\nfn check_permutation_invalid_index() {\n    let original_array = [0, 1, 2];\n    let permuted_array = [1, 0, 0];\n    let indexes = [1, 0, 2];\n    check_permutation(original_array, permuted_array, indexes);\n}\n"
    },
    "355": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.2/noir-projects/noir-protocol-circuits/crates/types/src/utils/reader.nr",
      "source": "pub struct Reader<let N: u32> {\n    data: [Field; N],\n    offset: u32,\n}\n\nimpl<let N: u32> Reader<N> {\n    pub fn new(data: [Field; N]) -> Self {\n        Self { data, offset: 0 }\n    }\n\n    pub fn read(&mut self) -> Field {\n        let result = self.data[self.offset];\n        self.offset += 1;\n        result\n    }\n\n    pub fn read_u32(&mut self) -> u32 {\n        self.read() as u32\n    }\n\n    pub fn read_bool(&mut self) -> bool {\n        self.read() as bool\n    }\n\n    pub fn read_array<let K: u32>(&mut self) -> [Field; K] {\n        let mut result = [0; K];\n        for i in 0..K {\n            result[i] = self.data[self.offset + i];\n        }\n        self.offset += K;\n        result\n    }\n\n    pub fn read_struct<T, let K: u32>(&mut self, deserialise: fn([Field; K]) -> T) -> T {\n        let result = deserialise(self.read_array());\n        result\n    }\n\n    pub fn read_struct_array<T, let K: u32, let C: u32>(\n        &mut self,\n        deserialise: fn([Field; K]) -> T,\n        mut result: [T; C],\n    ) -> [T; C] {\n        for i in 0..C {\n            result[i] = self.read_struct(deserialise);\n        }\n        result\n    }\n\n    pub fn finish(self) {\n        assert(self.offset == self.data.len(), \"Reader did not read all data\");\n    }\n}\n"
    },
    "42": {
      "path": "std/option.nr",
      "source": "use crate::cmp::{Eq, Ord, Ordering};\nuse crate::default::Default;\nuse crate::hash::{Hash, Hasher};\n\npub struct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::mem::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default\n        }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    pub fn expect<let N: u32, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            other\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            default()\n        }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some {\n                Option::none()\n            } else {\n                self\n            }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n\nimpl<T> Default for Option<T> {\n    fn default() -> Self {\n        Option::none()\n    }\n}\n\nimpl<T> Eq for Option<T>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: Self) -> bool {\n        if self._is_some == other._is_some {\n            if self._is_some {\n                self._value == other._value\n            } else {\n                true\n            }\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T> Hash for Option<T>\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self._is_some.hash(state);\n        if self._is_some {\n            self._value.hash(state);\n        }\n    }\n}\n\n// For this impl we're declaring Option::none < Option::some\nimpl<T> Ord for Option<T>\nwhere\n    T: Ord,\n{\n    fn cmp(self, other: Self) -> Ordering {\n        if self._is_some {\n            if other._is_some {\n                self._value.cmp(other._value)\n            } else {\n                Ordering::greater()\n            }\n        } else if other._is_some {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n"
    },
    "43": {
      "path": "std/panic.nr",
      "source": "pub fn panic<T, U, let N: u32>(message: fmtstr<N, T>) -> U {\n    assert(false, message);\n    crate::mem::zeroed()\n}\n"
    },
    "50": {
      "path": "/Users/niallcheetham/Dev/obsidion/idenityRegistryDemo/identityRegistry/src/main.nr",
      "source": "mod types;\n\nuse dep::aztec::macros::aztec;\n\n//This is the identity registry contract.\n//has a 1:1 mapping between a zkpassportID and a user address.\n//should be able to be linked, unlinked, needs to verfiy the proof in the function\n\n#[aztec]\ncontract IdentityRegistry {\n    use dep::aztec::{\n        prelude::{AztecAddress, Map, PublicMutable, SharedMutable},\n        macros::{functions::{initializer, internal, private, public, view}, storage::storage},\n        protocol_types::{abis::function_selector::FunctionSelector, traits::{Deserialize, Serialize, FromField, ToField}},\n    };\n    use std::{verify_proof_with_type};\n    use crate::types::{SubProofInputs};\n    global ZERO_ADDRESS: AztecAddress = AztecAddress::from_field(\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n    );\n    global HONK_IDENTIFIER: u32 = 1;\n    global KEY_HASH: Field = 0;\n\n   \n\n    #[storage]\n    struct Storage<Context> {\n        admin: PublicMutable<AztecAddress, Context>,\n        zkPassportIDtoAddress: Map<Field, PublicMutable<AztecAddress, Context>, Context>,\n        addressToZKPassportID: Map<AztecAddress, PublicMutable<Field, Context>, Context>,\n    }\n\n    #[public]\n    #[initializer]\n    fn constructor(admin: AztecAddress) {\n        storage.admin.write(admin);\n    }\n\n    #[public]\n    #[view]\n    fn is_valid_zkID(zkID: Field) -> bool {\n        let mut truth = false;\n        let address = storage.zkPassportIDtoAddress.at(zkID).read();\n        if address != ZERO_ADDRESS {\n            truth = true;\n        }\n        truth\n    }\n    \n\n    #[public]\n    #[view]\n    fn is_valid_address(address: AztecAddress) -> bool {\n        let mut truth = false;\n        let zkID = storage.addressToZKPassportID.at(address).read();\n        if zkID != 0 {\n            truth = true;\n        }\n        truth\n    }\n\n    #[public]\n    #[view]\n    fn get_address_from_zkID(zkID: Field) -> AztecAddress {\n        storage.zkPassportIDtoAddress.at(zkID).read()\n    }\n\n    #[public]\n    #[view]\n    fn get_zkID_from_address(address: AztecAddress) -> Field {\n        storage.addressToZKPassportID.at(address).read()\n    }\n\n    #[private]\n    fn verify_zkID(\n        circuitInputs: SubProofInputs,\n        zk_id: Field,\n        add_zkID: bool,\n        remove_zkID: bool,\n    ) {\n        assert(circuitInputs.public_inputs.input_a[1] == circuitInputs.public_inputs.input_b[0], \"comm_out of proof_a does not match comm_in of proof_b\");\n        assert(circuitInputs.public_inputs.input_b[1] == circuitInputs.public_inputs.input_c[0], \"comm_out of proof_c does not match comm_in of proof_d\");\n        // assert(circuitInputs.public_inputs.input_c[1] == circuitInputs.public_inputs.input_d[0], \"comm_out of proof_d does not match comm_in of proof_c\");\n        assert(circuitInputs.public_inputs.input_d[1] == zk_id, \"scoped nullifier of proof_d does not match zk_id\");\n        // Verify all proofs\n        verify_proof_with_type(\n            circuitInputs.vkeys.vkey_a,\n            circuitInputs.proofs.proof_a,\n            circuitInputs.public_inputs.input_a,\n            KEY_HASH,\n            HONK_IDENTIFIER,\n        );\n\n        // verify_proof_with_type(\n        //     circuitInputs.vkeys.vkey_b,\n        //     circuitInputs.proofs.proof_b,\n        //     circuitInputs.public_inputs.input_b,\n        //     KEY_HASH,\n        //     HONK_IDENTIFIER,\n        // );\n        // verify_proof_with_type(\n        //     circuitInputs.vkeys.vkey_c,\n        //     circuitInputs.proofs.proof_c,\n        //     circuitInputs.public_inputs.input_c,\n        //     KEY_HASH,\n        //     HONK_IDENTIFIER,\n        // );\n        // verify_proof_with_type(\n        //     circuitInputs.vkeys.vkey_d,\n        //     circuitInputs.proofs.proof_d,\n        //     circuitInputs.public_inputs.input_d,\n        //     KEY_HASH,\n        //     HONK_IDENTIFIER,\n        // );\n        \n        // Add the zkID to storage\n        let address = context.msg_sender();\n\n        if remove_zkID & !add_zkID {\n            IdentityRegistry::at(context.this_address())._remove_zkID(zk_id, address).enqueue(&mut context);\n        }\n        else {\n            IdentityRegistry::at(context.this_address())._add_zkID(zk_id, address).enqueue(&mut context);\n        }\n    }\n\n\n    #[public]\n    #[internal]\n    fn _add_zkID(zk_id: Field, address: AztecAddress) {\n        storage.zkPassportIDtoAddress.at(zk_id).write(address);\n        storage.addressToZKPassportID.at(address).write(zk_id);\n    }\n\n    #[public]\n    #[internal]\n    fn _remove_zkID(zk_id: Field, address: AztecAddress) {\n        storage.zkPassportIDtoAddress.at(zk_id).write(ZERO_ADDRESS);\n        storage.addressToZKPassportID.at(address).write(0);\n    }\n\n    #[public]\n    fn remove_zkID_with_address() {\n        let address = context.msg_sender();\n        let passport_id = storage.addressToZKPassportID.at(address).read();\n        if passport_id != 0 {\n            storage.zkPassportIDtoAddress.at(passport_id).write(ZERO_ADDRESS);\n            storage.addressToZKPassportID.at(address).write(0);\n        }\n        else {\n            assert(false, \"No zkID found for address\");\n        }\n    }\n\n}\n\n"
    },
    "53": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.2/noir-projects/aztec-nr/aztec/src/context/call_interfaces.nr",
      "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector,\n    address::AztecAddress,\n    traits::{Deserialize, ToField},\n};\n\nuse crate::context::{gas::GasOpts, private_context::PrivateContext, public_context::PublicContext};\n\nuse crate::hash::{hash_args, hash_calldata};\nuse crate::oracle::execution_cache;\n\npub trait CallInterface<let N: u32> {\n    fn get_args(self) -> [Field];\n    fn get_selector(self) -> FunctionSelector;\n    fn get_name(self) -> str<N>;\n    fn get_contract_address(self) -> AztecAddress;\n    fn get_is_static(self) -> bool;\n}\n\n// PrivateCallInterface\n\npub struct PrivateCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let N: u32, T> PrivateCallInterface<N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self {\n            target_contract,\n            selector,\n            name,\n            args_hash,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static,\n        }\n    }\n\n    pub fn call<let M: u32>(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        execution_cache::store(self.args, self.args_hash);\n        let returns_hash = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            false,\n        );\n        let returns: T = returns_hash.get_preimage();\n        returns\n    }\n\n    pub fn view<let M: u32>(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        execution_cache::store(self.args, self.args_hash);\n        let returns_hash = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            true,\n        );\n        returns_hash.get_preimage()\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PrivateCallInterface<N, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PrivateVoidCallInterface\n\npub struct PrivateVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\n    is_static: bool,\n}\n\nimpl<let N: u32> PrivateVoidCallInterface<N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self { target_contract, selector, name, args_hash, args, return_type: (), is_static }\n    }\n\n    pub fn call(self, context: &mut PrivateContext) {\n        execution_cache::store(self.args, self.args_hash);\n        context\n            .call_private_function_with_args_hash(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                false,\n            )\n            .assert_empty();\n    }\n\n    pub fn view(self, context: &mut PrivateContext) {\n        execution_cache::store(self.args, self.args_hash);\n        context\n            .call_private_function_with_args_hash(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                true,\n            )\n            .assert_empty();\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PrivateVoidCallInterface<N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PrivateStaticCallInterface\n\npub struct PrivateStaticCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let N: u32, T> PrivateStaticCallInterface<N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self {\n            target_contract,\n            selector,\n            name,\n            args_hash,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static: true,\n        }\n    }\n\n    pub fn view<let M: u32>(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        execution_cache::store(self.args, self.args_hash);\n        let returns = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            true,\n        );\n        returns.get_preimage()\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PrivateStaticCallInterface<N, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PrivateStaticVoidCallInterface\n\npub struct PrivateStaticVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\n    is_static: bool,\n}\n\nimpl<let N: u32> PrivateStaticVoidCallInterface<N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self { target_contract, selector, name, args_hash, args, return_type: (), is_static: true }\n    }\n\n    pub fn view(self, context: &mut PrivateContext) {\n        execution_cache::store(self.args, self.args_hash);\n        context\n            .call_private_function_with_args_hash(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                true,\n            )\n            .assert_empty();\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PrivateStaticVoidCallInterface<N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicCallInterface\n\npub struct PublicCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    gas_opts: GasOpts,\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let N: u32, T> PublicCallInterface<N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            gas_opts: GasOpts::default(),\n            return_type: std::mem::zeroed(),\n            is_static,\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn call<let M: u32>(self, context: &mut PublicContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        let returns = context.call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array::<M>())\n    }\n\n    pub unconstrained fn view<let M: u32>(self, context: &mut PublicContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array::<M>())\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            false,\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PublicCallInterface<N, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicVoidCallInterface\n\npub struct PublicVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let N: u32> PublicVoidCallInterface<N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            return_type: (),\n            is_static,\n            gas_opts: GasOpts::default(),\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn call(self, context: &mut PublicContext) {\n        let returns = context.call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        assert(returns.len() == 0);\n    }\n\n    pub unconstrained fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        assert(returns.len() == 0);\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            false,\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n        )\n    }\n\n    pub fn set_as_teardown(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.set_public_teardown_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            false,\n        )\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PublicVoidCallInterface<N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicStaticCallInterface\n\npub struct PublicStaticCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let N: u32, T> PublicStaticCallInterface<N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static: true,\n            gas_opts: GasOpts::default(),\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn view<let M: u32>(self, context: &mut PublicContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array::<M>())\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PublicStaticCallInterface<N, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicStaticVoidCallInterface\n\npub struct PublicStaticVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let N: u32> PublicStaticVoidCallInterface<N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            return_type: (),\n            is_static: true,\n            gas_opts: GasOpts::default(),\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        assert(returns.len() == 0);\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PublicStaticVoidCallInterface<N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n"
    },
    "60": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.2/noir-projects/aztec-nr/aztec/src/context/private_context.nr",
      "source": "use crate::{\n    context::{inputs::PrivateContextInputs, returns_hash::ReturnsHash},\n    hash::{ArgsHasher, hash_args_array, hash_calldata_array},\n    keys::constants::{NULLIFIER_INDEX, NUM_KEY_TYPES, OUTGOING_INDEX, sk_generators},\n    messaging::process_l1_to_l2_message,\n    oracle::{\n        block_header::get_block_header_at,\n        call_private_function::call_private_function_internal,\n        enqueue_public_function_call::{\n            notify_enqueued_public_function_call, notify_set_min_revertible_side_effect_counter,\n            notify_set_public_teardown_function_call,\n        },\n        execution_cache,\n        key_validation_request::get_key_validation_request,\n        notes::{notify_created_nullifier, notify_nullified_note},\n    },\n};\nuse dep::protocol_types::{\n    abis::{\n        call_context::CallContext,\n        function_selector::FunctionSelector,\n        gas_settings::GasSettings,\n        log::Log,\n        log_hash::LogHash,\n        max_block_number::MaxBlockNumber,\n        note_hash::NoteHash,\n        nullifier::Nullifier,\n        private_call_request::PrivateCallRequest,\n        private_circuit_public_inputs::PrivateCircuitPublicInputs,\n        private_log::PrivateLogData,\n        public_call_request::PublicCallRequest,\n        read_request::ReadRequest,\n        side_effect::Counted,\n        validation_requests::{KeyValidationRequest, KeyValidationRequestAndGenerator},\n    },\n    address::{AztecAddress, EthAddress},\n    block_header::BlockHeader,\n    constants::{\n        MAX_CONTRACT_CLASS_LOGS_PER_CALL, MAX_ENQUEUED_CALLS_PER_CALL,\n        MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_L2_TO_L1_MSGS_PER_CALL,\n        MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NOTE_HASHES_PER_CALL,\n        MAX_NULLIFIER_READ_REQUESTS_PER_CALL, MAX_NULLIFIERS_PER_CALL,\n        MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PRIVATE_LOGS_PER_CALL,\n        PRIVATE_LOG_SIZE_IN_FIELDS,\n    },\n    messaging::l2_to_l1_message::L2ToL1Message,\n    traits::{Empty, Hash, ToField},\n    utils::arrays::array_concat,\n};\n\n// When finished, one can call .finish() to convert back to the abi\npub struct PrivateContext {\n    // docs:start:private-context\n    pub inputs: PrivateContextInputs,\n    pub side_effect_counter: u32,\n\n    pub min_revertible_side_effect_counter: u32,\n    pub is_fee_payer: bool,\n\n    pub args_hash: Field,\n    pub return_hash: Field,\n\n    pub max_block_number: MaxBlockNumber,\n\n    pub note_hash_read_requests: BoundedVec<ReadRequest, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>,\n    pub nullifier_read_requests: BoundedVec<ReadRequest, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\n    key_validation_requests_and_generators: BoundedVec<KeyValidationRequestAndGenerator, MAX_KEY_VALIDATION_REQUESTS_PER_CALL>,\n\n    pub note_hashes: BoundedVec<NoteHash, MAX_NOTE_HASHES_PER_CALL>,\n    pub nullifiers: BoundedVec<Nullifier, MAX_NULLIFIERS_PER_CALL>,\n\n    pub private_call_requests: BoundedVec<PrivateCallRequest, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    pub public_call_requests: BoundedVec<Counted<PublicCallRequest>, MAX_ENQUEUED_CALLS_PER_CALL>,\n    pub public_teardown_call_request: PublicCallRequest,\n    pub l2_to_l1_msgs: BoundedVec<L2ToL1Message, MAX_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    pub historical_header: BlockHeader,\n\n    pub private_logs: BoundedVec<PrivateLogData, MAX_PRIVATE_LOGS_PER_CALL>,\n    pub contract_class_logs_hashes: BoundedVec<LogHash, MAX_CONTRACT_CLASS_LOGS_PER_CALL>,\n\n    // Contains the last key validation request for each key type. This is used to cache the last request and avoid\n    // fetching the same request multiple times.\n    // The index of the array corresponds to the key type (0 nullifier, 1 incoming, 2 outgoing, 3 tagging).\n    pub last_key_validation_requests: [Option<KeyValidationRequest>; NUM_KEY_TYPES],\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        PrivateContext {\n            inputs,\n            side_effect_counter: inputs.start_side_effect_counter + 1,\n            min_revertible_side_effect_counter: 0,\n            is_fee_payer: false,\n            args_hash,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            historical_header: inputs.historical_header,\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n\n    pub fn msg_sender(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    pub fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.contract_address\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.inputs.tx_context.chain_id\n    }\n\n    pub fn version(self) -> Field {\n        self.inputs.tx_context.version\n    }\n\n    pub fn gas_settings(self) -> GasSettings {\n        self.inputs.tx_context.gas_settings\n    }\n\n    pub fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    pub fn get_args_hash(self) -> Field {\n        self.args_hash\n    }\n\n    pub fn push_note_hash(&mut self, note_hash: Field) {\n        self.note_hashes.push(NoteHash { value: note_hash, counter: self.next_counter() });\n    }\n\n    pub fn push_nullifier(&mut self, nullifier: Field) {\n        notify_created_nullifier(nullifier);\n        self.nullifiers.push(\n            Nullifier { value: nullifier, note_hash: 0, counter: self.next_counter() },\n        );\n    }\n\n    pub fn push_nullifier_for_note_hash(&mut self, nullifier: Field, nullified_note_hash: Field) {\n        let nullifier_counter = self.next_counter();\n        notify_nullified_note(nullifier, nullified_note_hash, nullifier_counter);\n        self.nullifiers.push(\n            Nullifier {\n                value: nullifier,\n                note_hash: nullified_note_hash,\n                counter: nullifier_counter,\n            },\n        );\n    }\n\n    // Returns the header of a block whose state is used during private execution (not the block the transaction is\n    // included in).\n    pub fn get_block_header(self) -> BlockHeader {\n        self.historical_header\n    }\n\n    // Returns the header of an arbitrary block whose block number is less than or equal to the block number\n    // of historical header.\n    pub fn get_block_header_at(self, block_number: u32) -> BlockHeader {\n        get_block_header_at(block_number, self)\n    }\n\n    pub fn set_return_hash(&mut self, returns_hasher: ArgsHasher) {\n        self.return_hash = returns_hasher.hash();\n        execution_cache::store(returns_hasher.fields, self.return_hash);\n    }\n\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\n        PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            returns_hash: self.return_hash,\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\n            is_fee_payer: self.is_fee_payer,\n            max_block_number: self.max_block_number,\n            note_hash_read_requests: self.note_hash_read_requests.storage(),\n            nullifier_read_requests: self.nullifier_read_requests.storage(),\n            key_validation_requests_and_generators: self\n                .key_validation_requests_and_generators\n                .storage(),\n            note_hashes: self.note_hashes.storage(),\n            nullifiers: self.nullifiers.storage(),\n            private_call_requests: self.private_call_requests.storage(),\n            public_call_requests: self.public_call_requests.storage(),\n            public_teardown_call_request: self.public_teardown_call_request,\n            l2_to_l1_msgs: self.l2_to_l1_msgs.storage(),\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\n            end_side_effect_counter: self.side_effect_counter,\n            private_logs: self.private_logs.storage(),\n            contract_class_logs_hashes: self.contract_class_logs_hashes.storage(),\n            historical_header: self.historical_header,\n            tx_context: self.inputs.tx_context,\n        }\n    }\n\n    pub fn set_as_fee_payer(&mut self) {\n        dep::protocol_types::debug_log::debug_log_format(\n            \"Setting {0} as fee payer\",\n            [self.this_address().to_field()],\n        );\n        self.is_fee_payer = true;\n    }\n\n    pub fn end_setup(&mut self) {\n        // dep::protocol_types::debug_log::debug_log_format(\n        //     \"Ending setup at counter {0}\",\n        //     [self.side_effect_counter as Field]\n        // );\n        self.min_revertible_side_effect_counter = self.side_effect_counter;\n        notify_set_min_revertible_side_effect_counter(self.min_revertible_side_effect_counter);\n    }\n\n    // docs:start:max-block-number\n    pub fn set_tx_max_block_number(&mut self, max_block_number: u32) {\n        // docs:end:max-block-number\n        self.max_block_number =\n            MaxBlockNumber::min_with_u32(self.max_block_number, max_block_number);\n    }\n\n    pub fn push_note_hash_read_request(&mut self, note_hash: Field) {\n        let side_effect = ReadRequest { value: note_hash, counter: self.next_counter() };\n        self.note_hash_read_requests.push(side_effect);\n    }\n\n    pub fn push_nullifier_read_request(&mut self, nullifier: Field) {\n        let request = ReadRequest { value: nullifier, counter: self.next_counter() };\n        self.nullifier_read_requests.push(request);\n    }\n\n    pub fn request_nsk_app(&mut self, npk_m_hash: Field) -> Field {\n        self.request_sk_app(npk_m_hash, NULLIFIER_INDEX)\n    }\n\n    pub fn request_ovsk_app(&mut self, ovpk_m_hash: Field) -> Field {\n        self.request_sk_app(ovpk_m_hash, OUTGOING_INDEX)\n    }\n\n    fn request_sk_app(&mut self, pk_m_hash: Field, key_index: Field) -> Field {\n        let cached_request = self.last_key_validation_requests[key_index as u32].unwrap_or(\n            KeyValidationRequest::empty(),\n        );\n\n        if cached_request.pk_m.hash() == pk_m_hash {\n            // We get a match so the cached request is the latest one\n            cached_request.sk_app\n        } else {\n            // We didn't get a match meaning the cached result is stale\n            // Typically we'd validate keys by showing that they are the preimage of `pk_m_hash`, but that'd require\n            // the oracle returning the master secret keys, which could cause malicious contracts to leak it or learn\n            // about secrets from other contracts. We therefore silo secret keys, and rely on the private kernel to\n            // validate that we siloed secret key corresponds to correct siloing of the master secret key that hashes\n            // to `pk_m_hash`.\n\n            // Safety: Kernels verify that the key validation request is valid and below we verify that a request\n            // for the correct public key has been received.\n            let request = unsafe { get_key_validation_request(pk_m_hash, key_index) };\n            assert_eq(request.pk_m.hash(), pk_m_hash, \"Obtained invalid key validation request\");\n\n            self.key_validation_requests_and_generators.push(\n                KeyValidationRequestAndGenerator {\n                    request,\n                    sk_app_generator: sk_generators[key_index as u32],\n                },\n            );\n            self.last_key_validation_requests[key_index as u32] = Option::some(request);\n            request.sk_app\n        }\n    }\n\n    // docs:start:context_message_portal\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        // docs:end:context_message_portal\n        let message = L2ToL1Message { recipient, content, counter: self.next_counter() };\n        self.l2_to_l1_msgs.push(message);\n    }\n\n    // docs:start:context_consume_l1_to_l2_message\n    // docs:start:consume_l1_to_l2_message\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        // docs:end:context_consume_l1_to_l2_message\n        let nullifier = process_l1_to_l2_message(\n            self.historical_header.state.l1_to_l2_message_tree.root,\n            self.this_address(),\n            sender,\n            self.chain_id(),\n            self.version(),\n            content,\n            secret,\n            leaf_index,\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_nullifier(nullifier)\n    }\n    // docs:end:consume_l1_to_l2_message\n\n    pub fn emit_private_log(&mut self, log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS]) {\n        let counter = self.next_counter();\n        let private_log = PrivateLogData { log: Log::new(log), note_hash_counter: 0, counter };\n        self.private_logs.push(private_log);\n    }\n\n    pub fn emit_raw_note_log(\n        &mut self,\n        log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS],\n        note_hash_counter: u32,\n    ) {\n        let counter = self.next_counter();\n        let private_log = PrivateLogData { log: Log::new(log), note_hash_counter, counter };\n        self.private_logs.push(private_log);\n    }\n\n    pub fn call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) -> ReturnsHash {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args, args_hash);\n        self.call_private_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    pub fn static_call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) -> ReturnsHash {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args, args_hash);\n        self.call_private_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            true,\n        )\n    }\n\n    pub fn call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> ReturnsHash {\n        self.call_private_function_with_args_hash(contract_address, function_selector, 0, false)\n    }\n\n    pub fn static_call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> ReturnsHash {\n        self.call_private_function_with_args_hash(contract_address, function_selector, 0, true)\n    }\n\n    pub fn call_private_function_with_args_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) -> ReturnsHash {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let start_side_effect_counter = self.side_effect_counter;\n\n        // Safety: The oracle simulates the private call and returns the value of the side effects counter after\n        // execution of the call (which means that end_side_effect_counter - start_side_effect_counter is\n        // the number of side effects that took place), along with the hash of the return values. We validate these\n        // by requesting a private kernel iteration in which the return values are constrained to hash\n        // to `returns_hash` and the side effects counter to increment from start to end.\n        let (end_side_effect_counter, returns_hash) = unsafe {\n            call_private_function_internal(\n                contract_address,\n                function_selector,\n                args_hash,\n                start_side_effect_counter,\n                is_static_call,\n            )\n        };\n\n        self.private_call_requests.push(\n            PrivateCallRequest {\n                call_context: CallContext {\n                    msg_sender: self.this_address(),\n                    contract_address,\n                    function_selector,\n                    is_static_call,\n                },\n                args_hash,\n                returns_hash,\n                start_side_effect_counter,\n                end_side_effect_counter,\n            },\n        );\n\n        // TODO (fees) figure out why this crashes the prover and enable it\n        // we need this in order to pay fees inside child call contexts\n        // assert(\n        //     (item.public_inputs.min_revertible_side_effect_counter == 0 as u32)\n        //     | (item.public_inputs.min_revertible_side_effect_counter\n        //         > self.min_revertible_side_effect_counter)\n        // );\n        // if item.public_inputs.min_revertible_side_effect_counter\n        //     > self.min_revertible_side_effect_counter {\n        //     self.min_revertible_side_effect_counter = item.public_inputs.min_revertible_side_effect_counter;\n        // }\n        self.side_effect_counter = end_side_effect_counter + 1;\n        ReturnsHash::new(returns_hash)\n    }\n\n    pub fn call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let calldata = array_concat([function_selector.to_field()], args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, false)\n    }\n\n    pub fn static_call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let calldata = array_concat([function_selector.to_field()], args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, true)\n    }\n\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        let calldata_hash = hash_calldata_array([function_selector.to_field()]);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, false)\n    }\n\n    pub fn static_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        let calldata_hash = hash_calldata_array([function_selector.to_field()]);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, true)\n    }\n\n    pub fn call_public_function_with_calldata_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        calldata_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n\n        notify_enqueued_public_function_call(\n            contract_address,\n            calldata_hash,\n            counter,\n            is_static_call,\n        );\n\n        let call_request = PublicCallRequest {\n            msg_sender: self.this_address(),\n            contract_address,\n            is_static_call,\n            calldata_hash,\n        };\n\n        self.public_call_requests.push(Counted::new(call_request, counter));\n    }\n\n    pub fn set_public_teardown_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let calldata = array_concat([function_selector.to_field()], args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.set_public_teardown_function_with_calldata_hash(contract_address, calldata_hash, false)\n    }\n\n    pub fn set_public_teardown_function_with_calldata_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        calldata_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n\n        notify_set_public_teardown_function_call(\n            contract_address,\n            calldata_hash,\n            counter,\n            is_static_call,\n        );\n\n        self.public_teardown_call_request = PublicCallRequest {\n            msg_sender: self.this_address(),\n            contract_address,\n            is_static_call,\n            calldata_hash,\n        };\n    }\n\n    fn next_counter(&mut self) -> u32 {\n        let counter = self.side_effect_counter;\n        self.side_effect_counter += 1;\n        counter\n    }\n}\n\nimpl Empty for PrivateContext {\n    fn empty() -> Self {\n        PrivateContext {\n            inputs: PrivateContextInputs::empty(),\n            side_effect_counter: 0 as u32,\n            min_revertible_side_effect_counter: 0 as u32,\n            is_fee_payer: false,\n            args_hash: 0,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            historical_header: BlockHeader::empty(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n}\n"
    },
    "61": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.2/noir-projects/aztec-nr/aztec/src/context/public_context.nr",
      "source": "use crate::context::gas::GasOpts;\nuse crate::hash::{\n    compute_l1_to_l2_message_hash, compute_l1_to_l2_message_nullifier, compute_secret_hash,\n};\nuse dep::protocol_types::abis::function_selector::FunctionSelector;\nuse dep::protocol_types::address::{AztecAddress, EthAddress};\nuse dep::protocol_types::constants::MAX_FIELD_VALUE;\nuse dep::protocol_types::traits::{Empty, FromField, Packable, Serialize, ToField};\n\npub struct PublicContext {\n    pub args_hash: Option<Field>,\n    pub compute_args_hash: fn() -> Field,\n}\n\nimpl PublicContext {\n    pub fn new(compute_args_hash: fn() -> Field) -> Self {\n        PublicContext { args_hash: Option::none(), compute_args_hash }\n    }\n\n    pub fn emit_public_log<T, let N: u32>(_self: &mut Self, log: T)\n    where\n        T: Serialize<N>,\n    {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_public_log(Serialize::serialize(log).as_slice()) };\n    }\n\n    pub fn note_hash_exists(_self: Self, note_hash: Field, leaf_index: Field) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { note_hash_exists(note_hash, leaf_index) } == 1\n    }\n\n    pub fn l1_to_l2_msg_exists(_self: Self, msg_hash: Field, msg_leaf_index: Field) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { l1_to_l2_msg_exists(msg_hash, msg_leaf_index) } == 1\n    }\n\n    pub fn nullifier_exists(_self: Self, unsiloed_nullifier: Field, address: AztecAddress) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { nullifier_exists(unsiloed_nullifier, address.to_field()) } == 1\n    }\n\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        let secret_hash = compute_secret_hash(secret);\n        let message_hash = compute_l1_to_l2_message_hash(\n            sender,\n            self.chain_id(),\n            /*recipient=*/\n            self.this_address(),\n            self.version(),\n            content,\n            secret_hash,\n            leaf_index,\n        );\n        let nullifier = compute_l1_to_l2_message_nullifier(message_hash, secret);\n\n        assert(\n            !self.nullifier_exists(nullifier, self.this_address()),\n            \"L1-to-L2 message is already nullified\",\n        );\n        assert(\n            self.l1_to_l2_msg_exists(message_hash, leaf_index),\n            \"Tried to consume nonexistent L1-to-L2 message\",\n        );\n\n        self.push_nullifier(nullifier);\n    }\n\n    pub fn message_portal(_self: &mut Self, recipient: EthAddress, content: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { send_l2_to_l1_msg(recipient, content) };\n    }\n\n    pub unconstrained fn call_public_function(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let calldata = args.push_front(function_selector.to_field());\n\n        call(gas_for_call(gas_opts), contract_address, calldata);\n        // Use success_copy to determine whether the call succeeded\n        let success = success_copy();\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    pub unconstrained fn static_call_public_function(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let calldata = args.push_front(function_selector.to_field());\n\n        call_static(gas_for_call(gas_opts), contract_address, calldata);\n        // Use success_copy to determine whether the call succeeded\n        let success = success_copy();\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    pub fn push_note_hash(_self: &mut Self, note_hash: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_note_hash(note_hash) };\n    }\n    pub fn push_nullifier(_self: &mut Self, nullifier: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_nullifier(nullifier) };\n    }\n\n    pub fn this_address(_self: Self) -> AztecAddress {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            address()\n        }\n    }\n    pub fn msg_sender(_self: Self) -> AztecAddress {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            sender()\n        }\n    }\n    pub fn selector(_self: Self) -> FunctionSelector {\n        // The selector is the first element of the calldata when calling a public function through dispatch.\n        // Safety: AVM opcodes are constrained by the AVM itself\n        let raw_selector: [Field; 1] = unsafe { calldata_copy(0, 1) };\n        FunctionSelector::from_field(raw_selector[0])\n    }\n    pub fn get_args_hash(mut self) -> Field {\n        if !self.args_hash.is_some() {\n            self.args_hash = Option::some((self.compute_args_hash)());\n        }\n\n        self.args_hash.unwrap_unchecked()\n    }\n    pub fn transaction_fee(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            transaction_fee()\n        }\n    }\n\n    pub fn chain_id(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            chain_id()\n        }\n    }\n    pub fn version(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            version()\n        }\n    }\n    pub fn block_number(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            block_number()\n        }\n    }\n    pub fn timestamp(_self: Self) -> u64 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            timestamp()\n        }\n    }\n    pub fn fee_per_l2_gas(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            fee_per_l2_gas()\n        }\n    }\n    pub fn fee_per_da_gas(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            fee_per_da_gas()\n        }\n    }\n\n    pub fn l2_gas_left(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            l2_gas_left()\n        }\n    }\n    pub fn da_gas_left(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            da_gas_left()\n        }\n    }\n    pub fn is_static_call(_self: Self) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { is_static_call() } == 1\n    }\n\n    pub fn raw_storage_read<let N: u32>(_self: Self, storage_slot: Field) -> [Field; N] {\n        let mut out = [0; N];\n        for i in 0..N {\n            // Safety: AVM opcodes are constrained by the AVM itself\n            out[i] = unsafe { storage_read(storage_slot + i as Field) };\n        }\n        out\n    }\n\n    pub fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T\n    where\n        T: Packable<N>,\n    {\n        T::unpack(self.raw_storage_read(storage_slot))\n    }\n\n    pub fn raw_storage_write<let N: u32>(_self: Self, storage_slot: Field, values: [Field; N]) {\n        for i in 0..N {\n            // Safety: AVM opcodes are constrained by the AVM itself\n            unsafe { storage_write(storage_slot + i as Field, values[i]) };\n        }\n    }\n\n    pub fn storage_write<T, let N: u32>(self, storage_slot: Field, value: T)\n    where\n        T: Packable<N>,\n    {\n        self.raw_storage_write(storage_slot, value.pack());\n    }\n}\n\n// Helper functions\nfn gas_for_call(user_gas: GasOpts) -> [Field; 2] {\n    // It's ok to use the max possible gas here, because the gas will be\n    // capped by the gas left in the (STATIC)CALL instruction.\n    [user_gas.l2_gas.unwrap_or(MAX_FIELD_VALUE), user_gas.da_gas.unwrap_or(MAX_FIELD_VALUE)]\n}\n\n// Unconstrained opcode wrappers (do not use directly).\nunconstrained fn address() -> AztecAddress {\n    address_opcode()\n}\nunconstrained fn sender() -> AztecAddress {\n    sender_opcode()\n}\nunconstrained fn transaction_fee() -> Field {\n    transaction_fee_opcode()\n}\nunconstrained fn chain_id() -> Field {\n    chain_id_opcode()\n}\nunconstrained fn version() -> Field {\n    version_opcode()\n}\nunconstrained fn block_number() -> Field {\n    block_number_opcode()\n}\nunconstrained fn timestamp() -> u64 {\n    timestamp_opcode()\n}\nunconstrained fn fee_per_l2_gas() -> Field {\n    fee_per_l2_gas_opcode()\n}\nunconstrained fn fee_per_da_gas() -> Field {\n    fee_per_da_gas_opcode()\n}\nunconstrained fn l2_gas_left() -> Field {\n    l2_gas_left_opcode()\n}\nunconstrained fn da_gas_left() -> Field {\n    da_gas_left_opcode()\n}\nunconstrained fn is_static_call() -> Field {\n    is_static_call_opcode()\n}\nunconstrained fn note_hash_exists(note_hash: Field, leaf_index: Field) -> u1 {\n    note_hash_exists_opcode(note_hash, leaf_index)\n}\nunconstrained fn emit_note_hash(note_hash: Field) {\n    emit_note_hash_opcode(note_hash)\n}\nunconstrained fn nullifier_exists(nullifier: Field, address: Field) -> u1 {\n    nullifier_exists_opcode(nullifier, address)\n}\nunconstrained fn emit_nullifier(nullifier: Field) {\n    emit_nullifier_opcode(nullifier)\n}\nunconstrained fn emit_public_log(message: [Field]) {\n    emit_public_log_opcode(message)\n}\nunconstrained fn l1_to_l2_msg_exists(msg_hash: Field, msg_leaf_index: Field) -> u1 {\n    l1_to_l2_msg_exists_opcode(msg_hash, msg_leaf_index)\n}\nunconstrained fn send_l2_to_l1_msg(recipient: EthAddress, content: Field) {\n    send_l2_to_l1_msg_opcode(recipient, content)\n}\nunconstrained fn call(gas: [Field; 2], address: AztecAddress, args: [Field]) {\n    call_opcode(gas, address, args)\n}\n\nunconstrained fn call_static(gas: [Field; 2], address: AztecAddress, args: [Field]) {\n    call_static_opcode(gas, address, args)\n}\n\npub unconstrained fn calldata_copy<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {\n    calldata_copy_opcode(cdoffset, copy_size)\n}\n\n// `success_copy` is placed immediately after the CALL opcode to get the success value\nunconstrained fn success_copy() -> bool {\n    success_copy_opcode()\n}\n\nunconstrained fn returndata_size() -> u32 {\n    returndata_size_opcode()\n}\n\nunconstrained fn returndata_copy(rdoffset: u32, copy_size: u32) -> [Field] {\n    returndata_copy_opcode(rdoffset, copy_size)\n}\n\npub unconstrained fn avm_return(returndata: [Field]) {\n    return_opcode(returndata)\n}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\nunconstrained fn avm_revert(revertdata: [Field]) {\n    revert_opcode(revertdata)\n}\n\nunconstrained fn storage_read(storage_slot: Field) -> Field {\n    storage_read_opcode(storage_slot)\n}\n\nunconstrained fn storage_write(storage_slot: Field, value: Field) {\n    storage_write_opcode(storage_slot, value);\n}\n\nimpl Empty for PublicContext {\n    fn empty() -> Self {\n        PublicContext::new(|| 0)\n    }\n}\n\n// AVM oracles (opcodes) follow, do not use directly.\n#[oracle(avmOpcodeAddress)]\nunconstrained fn address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeSender)]\nunconstrained fn sender_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeTransactionFee)]\nunconstrained fn transaction_fee_opcode() -> Field {}\n\n#[oracle(avmOpcodeChainId)]\nunconstrained fn chain_id_opcode() -> Field {}\n\n#[oracle(avmOpcodeVersion)]\nunconstrained fn version_opcode() -> Field {}\n\n#[oracle(avmOpcodeBlockNumber)]\nunconstrained fn block_number_opcode() -> Field {}\n\n#[oracle(avmOpcodeTimestamp)]\nunconstrained fn timestamp_opcode() -> u64 {}\n\n#[oracle(avmOpcodeFeePerL2Gas)]\nunconstrained fn fee_per_l2_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeFeePerDaGas)]\nunconstrained fn fee_per_da_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeL2GasLeft)]\nunconstrained fn l2_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeDaGasLeft)]\nunconstrained fn da_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeIsStaticCall)]\nunconstrained fn is_static_call_opcode() -> Field {}\n\n#[oracle(avmOpcodeNoteHashExists)]\nunconstrained fn note_hash_exists_opcode(note_hash: Field, leaf_index: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNoteHash)]\nunconstrained fn emit_note_hash_opcode(note_hash: Field) {}\n\n#[oracle(avmOpcodeNullifierExists)]\nunconstrained fn nullifier_exists_opcode(nullifier: Field, address: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNullifier)]\nunconstrained fn emit_nullifier_opcode(nullifier: Field) {}\n\n// TODO(#11124): rename unencrypted to public in avm\n#[oracle(avmOpcodeEmitUnencryptedLog)]\nunconstrained fn emit_public_log_opcode(message: [Field]) {}\n\n#[oracle(avmOpcodeL1ToL2MsgExists)]\nunconstrained fn l1_to_l2_msg_exists_opcode(msg_hash: Field, msg_leaf_index: Field) -> u1 {}\n\n#[oracle(avmOpcodeSendL2ToL1Msg)]\nunconstrained fn send_l2_to_l1_msg_opcode(recipient: EthAddress, content: Field) {}\n\n#[oracle(avmOpcodeCalldataCopy)]\nunconstrained fn calldata_copy_opcode<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {}\n\n#[oracle(avmOpcodeReturndataSize)]\nunconstrained fn returndata_size_opcode() -> u32 {}\n\n#[oracle(avmOpcodeReturndataCopy)]\nunconstrained fn returndata_copy_opcode(rdoffset: u32, copy_size: u32) -> [Field] {}\n\n#[oracle(avmOpcodeReturn)]\nunconstrained fn return_opcode(returndata: [Field]) {}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\n#[oracle(avmOpcodeRevert)]\nunconstrained fn revert_opcode(revertdata: [Field]) {}\n\n#[oracle(avmOpcodeCall)]\nunconstrained fn call_opcode(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n) {}\n\n#[oracle(avmOpcodeStaticCall)]\nunconstrained fn call_static_opcode(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n) {}\n\n#[oracle(avmOpcodeSuccessCopy)]\nunconstrained fn success_copy_opcode() -> bool {}\n\n#[oracle(avmOpcodeStorageRead)]\nunconstrained fn storage_read_opcode(storage_slot: Field) -> Field {}\n\n#[oracle(avmOpcodeStorageWrite)]\nunconstrained fn storage_write_opcode(storage_slot: Field, value: Field) {}\n"
    },
    "63": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.2/noir-projects/aztec-nr/aztec/src/context/utility_context.nr",
      "source": "use crate::oracle::{\n    execution::{get_block_number, get_chain_id, get_contract_address, get_version},\n    storage::storage_read,\n};\nuse dep::protocol_types::{address::AztecAddress, traits::Packable};\n\npub struct UtilityContext {\n    block_number: u32,\n    contract_address: AztecAddress,\n    version: Field,\n    chain_id: Field,\n}\n\nimpl UtilityContext {\n    pub unconstrained fn new() -> Self {\n        // We could call these oracles on the getters instead of at creation, which makes sense given that they might\n        // not even be accessed. However any performance gains are minimal, and we'd rather fail early if a user\n        // incorrectly attempts to create a UtilityContext in an environment in which these oracles are not\n        // available.\n        let block_number = get_block_number();\n        let contract_address = get_contract_address();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub unconstrained fn at(contract_address: AztecAddress) -> Self {\n        let block_number = get_block_number();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub unconstrained fn at_historical(contract_address: AztecAddress, block_number: u32) -> Self {\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub fn block_number(self) -> u32 {\n        self.block_number\n    }\n\n    pub fn this_address(self) -> AztecAddress {\n        self.contract_address\n    }\n\n    pub fn version(self) -> Field {\n        self.version\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.chain_id\n    }\n\n    pub unconstrained fn raw_storage_read<let N: u32>(\n        self: Self,\n        storage_slot: Field,\n    ) -> [Field; N] {\n        storage_read(self.this_address(), storage_slot, self.block_number())\n    }\n\n    pub unconstrained fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T\n    where\n        T: Packable<N>,\n    {\n        T::unpack(self.raw_storage_read(storage_slot))\n    }\n}\n"
    },
    "67": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.2/noir-projects/aztec-nr/aztec/src/hash.nr",
      "source": "use dep::protocol_types::{\n    address::{AztecAddress, EthAddress},\n    constants::{\n        GENERATOR_INDEX__FUNCTION_ARGS, GENERATOR_INDEX__MESSAGE_NULLIFIER,\n        GENERATOR_INDEX__PUBLIC_CALLDATA, GENERATOR_INDEX__SECRET_HASH,\n    },\n    hash::{poseidon2_hash_with_separator, poseidon2_hash_with_separator_slice, sha256_to_field},\n    point::Point,\n    traits::{Hash, ToField},\n};\n\npub use dep::protocol_types::hash::{compute_siloed_nullifier, pedersen_hash};\n\npub fn pedersen_commitment<let N: u32>(inputs: [Field; N], hash_index: u32) -> Point {\n    std::hash::pedersen_commitment_with_separator(inputs, hash_index)\n}\n\npub fn compute_secret_hash(secret: Field) -> Field {\n    poseidon2_hash_with_separator([secret], GENERATOR_INDEX__SECRET_HASH)\n}\n\npub fn compute_l1_to_l2_message_hash(\n    sender: EthAddress,\n    chain_id: Field,\n    recipient: AztecAddress,\n    version: Field,\n    content: Field,\n    secret_hash: Field,\n    leaf_index: Field,\n) -> Field {\n    let mut hash_bytes = [0 as u8; 224];\n    let sender_bytes: [u8; 32] = sender.to_field().to_be_bytes();\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\n    let recipient_bytes: [u8; 32] = recipient.to_field().to_be_bytes();\n    let version_bytes: [u8; 32] = version.to_be_bytes();\n    let content_bytes: [u8; 32] = content.to_be_bytes();\n    let secret_hash_bytes: [u8; 32] = secret_hash.to_be_bytes();\n    let leaf_index_bytes: [u8; 32] = leaf_index.to_be_bytes();\n\n    for i in 0..32 {\n        hash_bytes[i] = sender_bytes[i];\n        hash_bytes[i + 32] = chain_id_bytes[i];\n        hash_bytes[i + 64] = recipient_bytes[i];\n        hash_bytes[i + 96] = version_bytes[i];\n        hash_bytes[i + 128] = content_bytes[i];\n        hash_bytes[i + 160] = secret_hash_bytes[i];\n        hash_bytes[i + 192] = leaf_index_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\n// The nullifier of a l1 to l2 message is the hash of the message salted with the secret\npub fn compute_l1_to_l2_message_nullifier(message_hash: Field, secret: Field) -> Field {\n    poseidon2_hash_with_separator([message_hash, secret], GENERATOR_INDEX__MESSAGE_NULLIFIER)\n}\n\npub struct ArgsHasher {\n    pub fields: [Field],\n}\n\nimpl Hash for ArgsHasher {\n    fn hash(self) -> Field {\n        hash_args(self.fields)\n    }\n}\n\nimpl ArgsHasher {\n    pub fn new() -> Self {\n        Self { fields: [] }\n    }\n\n    pub fn add(&mut self, field: Field) {\n        self.fields = self.fields.push_back(field);\n    }\n\n    pub fn add_multiple<let N: u32>(&mut self, fields: [Field; N]) {\n        for i in 0..N {\n            self.fields = self.fields.push_back(fields[i]);\n        }\n    }\n}\n\n// Computes the hash of input arguments or return values for private functions, or for authwit creation.\npub fn hash_args_array<let N: u32>(args: [Field; N]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n// Same as `hash_args_array`, but takes a slice instead of an array.\npub fn hash_args(args: [Field]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator_slice(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n// Computes the hash of calldata for public functions.\npub fn hash_calldata_array<let N: u32>(calldata: [Field; N]) -> Field {\n    if calldata.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(calldata, GENERATOR_INDEX__PUBLIC_CALLDATA)\n    }\n}\n\n// Same as `hash_calldata_array`, but takes a slice instead of an array.\npub fn hash_calldata(calldata: [Field]) -> Field {\n    if calldata.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator_slice(calldata, GENERATOR_INDEX__PUBLIC_CALLDATA)\n    }\n}\n\n#[test]\nunconstrained fn compute_var_args_hash() {\n    let mut input = ArgsHasher::new();\n    for i in 0..100 {\n        input.add(i as Field);\n    }\n    let hash = input.hash();\n    dep::std::println(hash);\n    assert(hash == 0x19b0d74feb06ebde19edd85a28986c97063e84b3b351a8b666c7cac963ce655f);\n}\n"
    },
    "89": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.2/noir-projects/aztec-nr/aztec/src/macros/dispatch.nr",
      "source": "use super::utils::compute_fn_selector;\nuse std::panic;\n\n/// Returns an `fn public_dispatch(...)` function for the given module that's assumed to be an Aztec contract.\npub comptime fn generate_public_dispatch(m: Module) -> Quoted {\n    let functions = m.functions();\n    let functions =\n        functions.filter(|function: FunctionDefinition| function.has_named_attribute(\"public\"));\n\n    let unit = get_type::<()>();\n\n    let ifs = functions.map(|function: FunctionDefinition| {\n        let parameters = function.parameters();\n        let return_type = function.return_type();\n\n        let selector: Field = compute_fn_selector(function);\n\n        let mut parameters_size = 0;\n        for param in parameters {\n            parameters_size += size_in_fields(param.1);\n        }\n\n        let initial_read = if parameters.len() == 0 {\n            quote {}\n        } else {\n            // The initial calldata_copy offset is 1 to skip the Field selector\n            // The expected calldata is the serialization of\n            // - FunctionSelector: the selector of the function intended to dispatch\n            // - Parameters: the parameters of the function intended to dispatch\n            // That is, exactly what is expected for a call to the target function,\n            // but with a selector added at the beginning.\n            quote {\n                let input_calldata: [Field; $parameters_size] = dep::aztec::context::public_context::calldata_copy(1, $parameters_size);\n                let mut reader = dep::aztec::protocol_types::utils::reader::Reader::new(input_calldata);\n            }\n        };\n\n        let parameter_index = &mut 0;\n        let reads = parameters.map(|param: (Quoted, Type)| {\n            let parameter_index_value = *parameter_index;\n            let param_name = f\"arg{parameter_index_value}\".quoted_contents();\n            let param_type = param.1;\n            let read = quote {\n                let $param_name: $param_type = reader.read_struct(dep::aztec::protocol_types::traits::Deserialize::deserialize);\n            };\n            *parameter_index += 1;\n            quote { $read }\n        });\n        let read = reads.join(quote { });\n\n        let mut args = &[];\n        for parameter_index in 0..parameters.len() {\n            let param_name = f\"arg{parameter_index}\".quoted_contents();\n            args = args.push_back(quote { $param_name });\n        }\n\n        let args = args.join(quote { , });\n        // name of the function is assigned just before the call so debug metadata doesn't span most of this macro when figuring out where the call comes from.\n        let name = function.name();\n        let call = quote { $name($args) };\n\n        let return_code = if return_type == unit {\n            quote {\n                $call;\n                // Force early return.\n                dep::aztec::context::public_context::avm_return([]);\n            }\n        } else {\n            quote {\n                let return_value = dep::aztec::protocol_types::traits::Serialize::serialize($call);\n                dep::aztec::context::public_context::avm_return(return_value.as_slice());\n            }\n        };\n\n        let if_ = quote {\n            if selector == $selector {\n                $initial_read\n                $read\n                $return_code\n            }\n        };\n        if_\n    });\n\n    if ifs.len() == 0 {\n        // No dispatch function if there are no public functions\n        quote {}\n    } else {\n        let ifs = ifs.push_back(quote { panic(f\"Unknown selector {selector}\") });\n        let dispatch = ifs.join(quote {  });\n\n        let body = quote {\n            // We mark this as public because our whole system depends on public\n            // functions having this attribute. However, the public MACRO will\n            // handle the public_dispatch function specially and do nothing.\n            #[public]\n            pub unconstrained fn public_dispatch(selector: Field) {\n                $dispatch\n            }\n        };\n\n        body\n    }\n}\n\ncomptime fn size_in_fields(typ: Type) -> u32 {\n    let size = array_size_in_fields(typ);\n    let size = size.or_else(|| bool_size_in_fields(typ));\n    let size = size.or_else(|| constant_size_in_fields(typ));\n    let size = size.or_else(|| field_size_in_fields(typ));\n    let size = size.or_else(|| int_size_in_fields(typ));\n    let size = size.or_else(|| str_size_in_fields(typ));\n    let size = size.or_else(|| struct_size_in_fields(typ));\n    let size = size.or_else(|| tuple_size_in_fields(typ));\n    if size.is_some() {\n        size.unwrap()\n    } else {\n        panic(f\"Can't determine size in fields of {typ}\")\n    }\n}\n\ncomptime fn array_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_array().and_then(|typ: (Type, Type)| {\n        let (typ, element_size) = typ;\n        element_size.as_constant().map(|x: u32| x * size_in_fields(typ))\n    })\n}\n\ncomptime fn bool_size_in_fields(typ: Type) -> Option<u32> {\n    if typ.is_bool() {\n        Option::some(1)\n    } else {\n        Option::none()\n    }\n}\n\ncomptime fn field_size_in_fields(typ: Type) -> Option<u32> {\n    if typ.is_field() {\n        Option::some(1)\n    } else {\n        Option::none()\n    }\n}\n\ncomptime fn int_size_in_fields(typ: Type) -> Option<u32> {\n    if typ.as_integer().is_some() {\n        Option::some(1)\n    } else {\n        Option::none()\n    }\n}\n\ncomptime fn constant_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_constant()\n}\n\ncomptime fn str_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_str().map(|typ| size_in_fields(typ))\n}\n\ncomptime fn struct_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_data_type().map(|typ: (TypeDefinition, [Type])| {\n        let struct_type = typ.0;\n        let generics = typ.1;\n        let mut size = 0;\n        for field in struct_type.fields(generics) {\n            size += size_in_fields(field.1);\n        }\n        size\n    })\n}\n\ncomptime fn tuple_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_tuple().map(|types: [Type]| {\n        let mut size = 0;\n        for typ in types {\n            size += size_in_fields(typ);\n        }\n        size\n    })\n}\n\ncomptime fn get_type<T>() -> Type {\n    let t: T = std::mem::zeroed();\n    std::meta::type_of(t)\n}\n"
    },
    "93": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.2/noir-projects/aztec-nr/aztec/src/macros/functions/initialization_utils.nr",
      "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress,\n    constants::GENERATOR_INDEX__CONSTRUCTOR, hash::poseidon2_hash_with_separator, traits::ToField,\n};\n\nuse crate::{\n    context::{PrivateContext, PublicContext},\n    oracle::get_contract_instance::{\n        get_contract_instance, get_contract_instance_deployer_avm,\n        get_contract_instance_initialization_hash_avm,\n    },\n};\n\npub fn mark_as_initialized_public(context: &mut PublicContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn mark_as_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn assert_is_initialized_public(context: &mut PublicContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    assert(context.nullifier_exists(init_nullifier, context.this_address()), \"Not initialized\");\n}\n\npub fn assert_is_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    context.push_nullifier_read_request(init_nullifier);\n}\n\nfn compute_unsiloed_contract_initialization_nullifier(address: AztecAddress) -> Field {\n    address.to_field()\n}\n\npub fn assert_initialization_matches_address_preimage_public(context: PublicContext) {\n    let address = context.this_address();\n    let deployer = get_contract_instance_deployer_avm(address).unwrap();\n    let initialization_hash = get_contract_instance_initialization_hash_avm(address).unwrap();\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (deployer.is_zero()) | (deployer == context.msg_sender()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\npub fn assert_initialization_matches_address_preimage_private(context: PrivateContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance(address);\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\n/// This function is not only used in macros but it's also used by external people to check that an instance has been\n/// initialized with the correct constructor arguments. Don't hide this unless you implement factory functionality.\npub fn compute_initialization_hash(\n    init_selector: FunctionSelector,\n    init_args_hash: Field,\n) -> Field {\n    poseidon2_hash_with_separator(\n        [init_selector.to_field(), init_args_hash],\n        GENERATOR_INDEX__CONSTRUCTOR,\n    )\n}\n"
    },
    "96": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.2/noir-projects/aztec-nr/aztec/src/macros/functions/utils.nr",
      "source": "use crate::macros::{\n    functions::{abi_export::create_fn_abi_export, call_interface_stubs::stub_fn, stub_registry},\n    notes::NOTES,\n    utils::{\n        add_to_hasher, fn_has_noinitcheck, get_fn_visibility, is_fn_contract_library_method,\n        is_fn_initializer, is_fn_internal, is_fn_private, is_fn_public, is_fn_test, is_fn_utility,\n        is_fn_view, modify_fn_body, module_has_initializer, module_has_storage,\n    },\n};\nuse protocol_types::meta::generate_serialize_to_fields;\nuse std::meta::type_of;\n\npub(crate) comptime fn transform_private(f: FunctionDefinition) -> Quoted {\n    let fn_abi = create_fn_abi_export(f);\n    let fn_stub = stub_fn(f);\n    stub_registry::register(f.module(), fn_stub);\n\n    // If a function is further modified as unconstrained, we throw an error\n    if f.is_unconstrained() {\n        let name = f.name();\n        panic(\n            f\"Function {name} is annotated with #[private] but marked as unconstrained, remove unconstrained keyword\",\n        );\n    }\n\n    let module_has_initializer = module_has_initializer(f.module());\n    let module_has_storage = module_has_storage(f.module());\n\n    // Private functions undergo a lot of transformations from their Aztec.nr form into a circuit that can be fed to the\n    // Private Kernel Circuit.\n    // First we change the function signature so that it also receives `PrivateContextInputs`, which contain information\n    // about the execution context (e.g. the caller).\n    let original_params = f.parameters();\n    f.set_parameters(&[(\n        quote { inputs },\n        quote { crate::context::inputs::private_context_inputs::PrivateContextInputs }.as_type(),\n    )]\n        .append(original_params));\n\n    let mut body = f.body().as_block().unwrap();\n\n    // The original params are hashed and passed to the `context` object, so that the kernel can verify we've received\n    // the correct values.\n    // TODO: Optimize args_hasher for small number of arguments\n    let args_hasher_name = quote { args_hasher };\n    let args_hasher = original_params.fold(\n        quote {\n            let mut $args_hasher_name = dep::aztec::hash::ArgsHasher::new();\n        },\n        |args_hasher, param: (Quoted, Type)| {\n            let (name, typ) = param;\n            let appended_arg = add_to_hasher(args_hasher_name, name, typ);\n            quote {\n                $args_hasher\n                $appended_arg\n            }\n        },\n    );\n\n    let context_creation = quote {\n        let mut context = dep::aztec::context::private_context::PrivateContext::new(inputs, dep::aztec::protocol_types::traits::Hash::hash($args_hasher_name));\n    };\n\n    // Modifications introduced by the different marker attributes.\n    let internal_check = if is_fn_internal(f) {\n        create_internal_check(f)\n    } else {\n        quote {}\n    };\n\n    let view_check = if is_fn_view(f) {\n        create_view_check(f)\n    } else {\n        quote {}\n    };\n\n    let (assert_initializer, mark_as_initialized) = if is_fn_initializer(f) {\n        (create_assert_correct_initializer_args(f), create_mark_as_initialized(f))\n    } else {\n        (quote {}, quote {})\n    };\n\n    let storage_init = if module_has_storage {\n        quote {\n            // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n            // referenced. We instead ignore 'unused variable' warnings for it.\n            #[allow(unused_variables)]\n            let storage = Storage::init(&mut context);\n        }\n    } else {\n        quote {}\n    };\n\n    // Initialization checks are not included in contracts that don't have initializers.\n    let init_check = if module_has_initializer & !is_fn_initializer(f) & !fn_has_noinitcheck(f) {\n        create_init_check(f)\n    } else {\n        quote {}\n    };\n\n    // All private functions perform message discovery, since they may need to access notes. This is slightly\n    // inefficient and could be improved by only doing it once we actually attempt to read any.\n    let message_discovery_call = if NOTES.len() > 0 {\n        create_message_discovery_call()\n    } else {\n        quote {}\n    };\n\n    // Finally, we need to change the return type to be `PrivateCircuitPublicInputs`, which is what the Private Kernel\n    // circuit expects.\n    let return_value_var_name = quote { macro__returned__values };\n\n    let return_value_type = f.return_type();\n    let return_value = if body.len() == 0 {\n        quote {}\n    } else if return_value_type != type_of(()) {\n        // The original return value is passed to a second args hasher which the context receives.\n        let (body_without_return, last_body_expr) = body.pop_back();\n        let return_value = last_body_expr.quoted();\n        let return_value_assignment =\n            quote { let $return_value_var_name: $return_value_type = $return_value; };\n        let return_hasher_name = quote { return_hasher };\n        let return_value_into_hasher =\n            add_to_hasher(return_hasher_name, return_value_var_name, return_value_type);\n\n        body = body_without_return;\n\n        quote {\n            let mut $return_hasher_name = dep::aztec::hash::ArgsHasher::new();\n            $return_value_assignment\n            $return_value_into_hasher\n            context.set_return_hash($return_hasher_name);\n        }\n    } else {\n        let (body_without_return, last_body_expr) = body.pop_back();\n        if !last_body_expr.has_semicolon()\n            & last_body_expr.as_for().is_none()\n            & last_body_expr.as_assert().is_none()\n            & last_body_expr.as_for_range().is_none()\n            & last_body_expr.as_assert_eq().is_none()\n            & last_body_expr.as_let().is_none() {\n            let unused_return_value_name = f\"_{return_value_var_name}\".quoted_contents();\n            body = body_without_return.push_back(\n                quote { let $unused_return_value_name = $last_body_expr; }.as_expr().unwrap(),\n            );\n        }\n        quote {}\n    };\n\n    let context_finish = quote { context.finish() };\n\n    let to_prepend = quote {\n        $args_hasher\n        $context_creation\n        $assert_initializer\n        $init_check\n        $internal_check\n        $view_check\n        $storage_init\n        $message_discovery_call\n    };\n\n    let to_append = quote {\n        $return_value\n        $mark_as_initialized\n        $context_finish\n    };\n    let modified_body = modify_fn_body(body, to_prepend, to_append);\n    f.set_body(modified_body);\n    f.set_return_type(\n        quote { dep::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs }\n            .as_type(),\n    );\n    f.set_return_data();\n\n    fn_abi\n}\n\npub(crate) comptime fn transform_public(f: FunctionDefinition) -> Quoted {\n    let fn_abi = create_fn_abi_export(f);\n    let fn_stub = stub_fn(f);\n    stub_registry::register(f.module(), fn_stub);\n\n    // If a function is further modified as unconstrained, we throw an error\n    if f.is_unconstrained() {\n        let name = f.name();\n        panic(\n            f\"Function {name} is annotated with #[public] but marked as unconstrained, remove unconstrained keyword\",\n        );\n    }\n\n    let module_has_initializer = module_has_initializer(f.module());\n    let module_has_storage = module_has_storage(f.module());\n\n    // Public functions undergo a lot of transformations from their Aztec.nr form.\n    let original_params = f.parameters();\n    let args_len = original_params\n        .map(|(name, typ): (Quoted, Type)| {\n            generate_serialize_to_fields(name, typ, &[], false).0.len()\n        })\n        .fold(0, |acc: u32, val: u32| acc + val);\n\n    // Unlike in the private case, in public the `context` does not need to receive the hash of the original params.\n    let context_creation = quote {\n        let mut context = dep::aztec::context::public_context::PublicContext::new(|| {\n        // We start from 1 because we skip the selector for the dispatch function.\n        let serialized_args : [Field; $args_len] = dep::aztec::context::public_context::calldata_copy(1, $args_len);\n        dep::aztec::hash::hash_args_array(serialized_args)\n        });\n    };\n\n    // Modifications introduced by the different marker attributes.\n    let internal_check = if is_fn_internal(f) {\n        create_internal_check(f)\n    } else {\n        quote {}\n    };\n\n    let view_check = if is_fn_view(f) {\n        create_view_check(f)\n    } else {\n        quote {}\n    };\n\n    let (assert_initializer, mark_as_initialized) = if is_fn_initializer(f) {\n        (create_assert_correct_initializer_args(f), create_mark_as_initialized(f))\n    } else {\n        (quote {}, quote {})\n    };\n\n    let storage_init = if module_has_storage {\n        // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n        // referenced. We instead ignore 'unused variable' warnings for it.\n        quote {\n            #[allow(unused_variables)]\n            let storage = Storage::init(&mut context);\n        }\n    } else {\n        quote {}\n    };\n\n    // Initialization checks are not included in contracts that don't have initializers.\n    let init_check = if module_has_initializer & !fn_has_noinitcheck(f) & !is_fn_initializer(f) {\n        create_init_check(f)\n    } else {\n        quote {}\n    };\n\n    let to_prepend = quote {\n        $context_creation\n        $assert_initializer\n        $init_check\n        $internal_check\n        $view_check\n        $storage_init\n    };\n\n    let to_append = quote {\n        $mark_as_initialized\n    };\n\n    let body = f.body().as_block().unwrap();\n    let modified_body = modify_fn_body(body, to_prepend, to_append);\n    f.set_body(modified_body);\n\n    // All public functions are automatically made unconstrained, even if they were not marked as such. This is because\n    // instead of compiling into a circuit, they will compile to bytecode that will be later transpiled into AVM\n    // bytecode.\n    f.set_unconstrained(true);\n    f.set_return_public(true);\n\n    fn_abi\n}\n\npub(crate) comptime fn transform_utility(f: FunctionDefinition) {\n    // Check if function is marked as unconstrained\n    if !f.is_unconstrained() {\n        let name = f.name();\n        panic(\n            f\"Function {name} is annotated with #[utility] but not marked as unconstrained, add unconstrained keyword\",\n        );\n    }\n\n    // Create utility context\n    let context_creation =\n        quote { let mut context = dep::aztec::context::utility_context::UtilityContext::new(); };\n    let module_has_storage = module_has_storage(f.module());\n\n    // Initialize Storage if module has storage\n    let storage_init = if module_has_storage {\n        quote {\n            // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n            // referenced. We instead ignore 'unused variable' warnings for it.\n            #[allow(unused_variables)]\n            let storage = Storage::init(context);\n        }\n    } else {\n        quote {}\n    };\n\n    // All utility functions perform message discovery, since they may need to access private notes that would be\n    // found during this process. This is slightly inefficient and could be improved by only doing it once we actually\n    // attempt to read any.\n    let message_discovery_call = if NOTES.len() > 0 {\n        create_message_discovery_call()\n    } else {\n        quote {}\n    };\n\n    // Inject context creation, storage initialization, and message discovery call at the beginning of the function\n    // body.\n    let to_prepend = quote {\n        $context_creation\n        $storage_init\n        $message_discovery_call\n    };\n    let body = f.body().as_block().unwrap();\n    let modified_body = modify_fn_body(body, to_prepend, quote {});\n    f.set_body(modified_body);\n\n    f.set_return_public(true);\n}\n\ncomptime fn create_internal_check(f: FunctionDefinition) -> Quoted {\n    let name = f.name();\n    let assertion_message = f\"Function {name} can only be called internally\";\n    quote { assert(context.msg_sender() == context.this_address(), $assertion_message); }\n}\n\ncomptime fn create_view_check(f: FunctionDefinition) -> Quoted {\n    let name = f.name();\n    let assertion_message = f\"Function {name} can only be called statically\";\n    if is_fn_private(f) {\n        // Here `context` is of type context::PrivateContext\n        quote { assert(context.inputs.call_context.is_static_call == true, $assertion_message); }\n    } else {\n        // Here `context` is of type context::PublicContext\n        quote { assert(context.is_static_call(), $assertion_message); }\n    }\n}\n\ncomptime fn create_assert_correct_initializer_args(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::assert_initialization_matches_address_preimage_{fn_visibility}(context);\"\n        .quoted_contents()\n}\n\ncomptime fn create_mark_as_initialized(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::mark_as_initialized_{fn_visibility}(&mut context);\"\n        .quoted_contents()\n}\n\ncomptime fn create_init_check(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::assert_is_initialized_{fn_visibility}(&mut context);\"\n        .quoted_contents()\n}\n\n/// Injects a call to `aztec::messages::discovery::discover_new_messages`, causing for new notes to be added to PXE and made\n/// available for the current execution.\npub(crate) comptime fn create_message_discovery_call() -> Quoted {\n    quote {\n        /// Safety: message discovery returns nothing and is performed solely for its side-effects. It is therefore\n        /// always safe to call.\n        unsafe {\n            dep::aztec::messages::discovery::discover_new_messages(\n                context.this_address(),\n                _compute_note_hash_and_nullifier,\n            );\n        };\n    }\n}\n\n/// Checks if each function in the module is marked with either #[private], #[public], #[utility],\n/// #[contract_library_method], or #[test]. Non-macroified functions are not allowed in contracts.\npub(crate) comptime fn check_each_fn_macroified(m: Module) {\n    for f in m.functions() {\n        let name = f.name();\n        if !is_fn_private(f)\n            & !is_fn_public(f)\n            & !is_fn_utility(f)\n            & !is_fn_contract_library_method(f)\n            & !is_fn_test(f) {\n            panic(\n                f\"Function {name} must be marked as either #[private], #[public], #[utility], #[contract_library_method], or #[test]\",\n            );\n        }\n    }\n}\n"
    },
    "99": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.2/noir-projects/aztec-nr/aztec/src/macros/storage.nr",
      "source": "use poseidon::poseidon2::Poseidon2Hasher;\nuse std::{collections::umap::UHashMap, hash::BuildHasherDefault};\n\nuse super::utils::AsStrQuote;\nuse super::utils::get_storage_size;\nuse super::utils::is_note;\n\n/// Stores a map from a module to the name of the struct that describes its storage layout.\n/// This is then used when generating a `storage_layout()` getter on the contract struct.\npub comptime mut global STORAGE_LAYOUT_NAME: UHashMap<Module, Quoted, BuildHasherDefault<Poseidon2Hasher>> =\n    UHashMap::default();\n\n/// Marks a struct as the one describing the storage layout of a contract. Only a single struct in the entire contract\n/// should have this macro (or `storage_no_init`) applied to it.\n/// The contract's storage is accessed via the `storage` variable, which will will automatically be made available in\n/// all functions as an instance of the struct this macro was applied to.\npub comptime fn storage(s: TypeDefinition) -> Quoted {\n    // This macro performs three things:\n    //  - it marks the contract as having storage, so that `macros::utils::module_has_storage` will return true and\n    //    functions will have the storage variable injected and initialized via the `init` function.\n    //  - it implements said `init` function by allocating appropriate storage slots to each state variable.\n    //  - it exposes the storage layout by creating a `StorageLayout` struct that is exposed via the `abi(storage)`\n    //    macro.\n    let mut slot: u32 = 1;\n    let mut storage_vars_constructors = &[];\n    let mut storage_layout_fields = &[];\n    let mut storage_layout_constructors = &[];\n\n    // TODO(#8658): uncomment the code below to inject the Context type parameter.\n    //let mut new_storage_fields = &[];\n    //let context_generic = s.add_generic(\"Context\");\n    for field in s.fields_as_written() {\n        // FIXME: This doesn't handle field types with generics\n        let (name, typ) = field;\n        let (storage_field_constructor, storage_size) =\n            generate_storage_field_constructor(typ, quote { $slot }, false);\n        storage_vars_constructors =\n            storage_vars_constructors.push_back(quote { $name: $storage_field_constructor });\n        // We have `Storable` in a separate `.nr` file instead of defining it in the last quote of this function\n        // because that way a dev gets a more reasonable error if he defines a struct with the same name in\n        // a contract.\n        storage_layout_fields =\n            storage_layout_fields.push_back(quote { pub $name: dep::aztec::prelude::Storable });\n        storage_layout_constructors = storage_layout_constructors.push_back(\n            quote { $name: dep::aztec::prelude::Storable { slot: $slot } },\n        );\n        //let with_context_generic = add_context_generic(typ, context_generic);\n        //println(with_context_generic);\n        //new_storage_fields = new_storage_fields.push_back((name,  with_context_generic ));\n        slot += storage_size;\n    }\n\n    //s.set_fields(new_storage_fields);\n    let storage_vars_constructors = storage_vars_constructors.join(quote {,});\n    let storage_impl = quote {\n        impl<Context> Storage<Context> {\n            fn init(context: Context) -> Self {\n                Self {\n                    $storage_vars_constructors\n                }\n            }\n        }\n    };\n\n    let storage_layout_fields = storage_layout_fields.join(quote {,});\n    let storage_layout_constructors = storage_layout_constructors.join(quote {,});\n\n    let module = s.module();\n    let module_name = module.name();\n    let storage_layout_name = f\"STORAGE_LAYOUT_{module_name}\".quoted_contents();\n    let (module_name_str, module_name_len) = module_name.as_str_quote();\n    STORAGE_LAYOUT_NAME.insert(module, storage_layout_name);\n\n    quote {\n        $storage_impl\n\n        pub struct StorageLayoutFields {\n            $storage_layout_fields\n        }\n\n        pub struct StorageLayout<let N: u32> {\n            pub contract_name: str<N>,\n            pub fields: StorageLayoutFields\n        }\n\n        #[abi(storage)]\n        pub global $storage_layout_name: StorageLayout<$module_name_len> = StorageLayout {\n            contract_name: $module_name_str,\n            fields: StorageLayoutFields { $storage_layout_constructors }\n        };\n    }\n}\n\n/// Same as `storage`, except the user is in charge of providing an implementation of the `init` constructor function\n/// with signature `fn init<Context>(context: Context) -> Self`, which allows for manual control of storage slot\n/// allocation. Similarly, no `StorageLayout` struct will be created.\n/// Only a single struct in the entire contract should have this macro (or `storage`) applied to it.\npub comptime fn storage_no_init(_s: TypeDefinition) {\n    // All `storage` does is provide the `init` implementation, so we don't need to do anything here. Applying this\n    // macro however will cause for `macros::utils::module_has_storage` to return true, resulting in the injection of\n    // the `storage` variable.\n}\n\n/// Returns the expression required to initialize a state variable with a given slot, along with its serialization size,\n/// i.e. how many contiguous storage slots the variable requires.\ncomptime fn generate_storage_field_constructor(\n    typ: Type,\n    slot: Quoted,\n    parent_is_map: bool,\n) -> (Quoted, u32) {\n    assert(\n        typ.as_data_type().is_some(),\n        \"Storage containers must be generic structs of the form `Container<_, Context>`, or Map<Key, _, Context>\",\n    );\n    let (container_struct, generics) = typ.as_data_type().unwrap();\n    let struct_name = container_struct.name();\n\n    if is_storage_map(typ) {\n        // Map state variables recursively initialize their contents - this includes nested maps.\n        let (value_constructor, _) =\n            generate_storage_field_constructor(generics[1], quote { slot }, true);\n        (quote { $struct_name::new(context, $slot, | context, slot | { $value_constructor }) }, 1)\n    } else {\n        let storage_size = if parent_is_map {\n            // Variables inside a map do not require contiguous slots since the map slot derivation is assumed to result\n            // in slots very far away from one another.\n            1\n        } else {\n            let (_, container_struct_generics) = typ.as_data_type().unwrap();\n            let stored_struct = container_struct_generics[0];\n\n            if is_note(stored_struct) {\n                // Private notes always occupy a single slot, since the slot is only used as a state variable\n                // identifier.\n                1\n            } else {\n                get_storage_size(typ)\n            }\n        };\n\n        // We assume below that all state variables implement `fn new<Context>(context: Context, slot: Field) -> Self`.\n        (quote { $struct_name::new(context, $slot)}, storage_size)\n    }\n}\n\n/// Returns true if `typ` is `state_vars::map::Map`.\ncomptime fn is_storage_map(typ: Type) -> bool {\n    if typ.as_data_type().is_some() {\n        let (def, generics) = typ.as_data_type().unwrap();\n        let maybe_map = if (def.name() == quote { Map }) & (generics.len() == 3) {\n            let maybe_key = generics[0];\n            let maybe_value = generics[1];\n            let maybe_context = generics[2];\n            quote { crate::state_vars::map::Map<$maybe_key, $maybe_value, $maybe_context> }.as_type()\n        } else {\n            quote {()}.as_type()\n        };\n        typ == maybe_map\n    } else {\n        false\n    }\n}\n\ncomptime fn add_context_generic(typ: Type, context_generic: Type) -> Type {\n    let (def, mut generics) = typ.as_data_type().expect(\n        f\"Storage containers must be generic structs of the form `Container<..., Context>`\",\n    );\n    let name = def.name();\n\n    if is_storage_map(typ) {\n        generics[generics.len() - 2] = add_context_generic(generics[1], context_generic);\n        generics[generics.len() - 1] = context_generic;\n    } else {\n        generics[generics.len() - 1] = context_generic;\n    }\n\n    let generics = generics.map(|typ: Type| quote {$typ}).join(quote {,});\n    quote { $name<$generics> }.as_type()\n}\n"
    }
  }
}
