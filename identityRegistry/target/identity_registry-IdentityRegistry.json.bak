{"noir_version":"1.0.0-beta.4+0000000000000000000000000000000000000000","name":"IdentityRegistry","functions":[{"name":"public_dispatch","hash":"6908397914589340786","is_unconstrained":true,"custom_attributes":["public"],"abi":{"parameters":[{"name":"selector","type":{"kind":"field"},"visibility":"private"}],"return_type":null,"error_types":{"72026683357237545":{"error_kind":"string","string":"Function is_valid_address can only be called statically"},"206160798890201757":{"error_kind":"string","string":"Storage slot 0 not allowed. Storage slots must start from 1."},"2233873454491509486":{"error_kind":"string","string":"Initializer address is not the contract deployer"},"2830029349304997821":{"error_kind":"fmtstring","length":27,"item_types":[{"kind":"field"}]},"3842422468523945747":{"error_kind":"string","string":"Function _remove_zkID can only be called internally"},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"7995561580326778049":{"error_kind":"string","string":"Function _add_zkID can only be called internally"},"11032241527761073405":{"error_kind":"string","string":"Function is_valid_zkID can only be called statically"},"12285239479773811347":{"error_kind":"string","string":"Function get_zkID_from_address can only be called statically"},"12749937572827500595":{"error_kind":"string","string":"No zkID found for address"},"13699457482007836410":{"error_kind":"string","string":"Not initialized"},"14225679739041873922":{"error_kind":"string","string":"Index out of bounds"},"15100788409809688557":{"error_kind":"string","string":"Function get_address_from_zkID can only be called statically"},"17618083556256589634":{"error_kind":"string","string":"Initialization hash does not match"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"7Z3tjtw2sobvxb/9g8X6ILm3sjgIkmx2YcBIFkn2AAeL3PvRzFjq9ojdRL9W0TMiESCwEz39ksWiRFaxpP9++McvP/3nXz98+vWfv/3x4W9//++Hz7/9/OOfn377dfnbf//6+OGn3z99/vzpXz9c/+cP4elfMT9f/8e/f/z16a9//Pnj739++BtTLh8//PLrP5Y/MqXlF/756fMvH/6Wy1//8/FDLI8zHGpMzMm+MMsf82uGACYCDAOMAIwCjAFMApgMMOVxRgA/EMAPpGprkiBfGJKk18zH/cVBOK9XB0llu9zoWcL8JZK/RPaXKO4SGvwlql5ISmGFNIdXXqgRYBhgBGAUYAxgEsBkgCmPM1Z3m6Lrk4xKev0kMwKYCDAMMAIwCjAGMAlgMsDUn0pG6+SOluT+rSClnL5cnOlqKVPsSSAFbwHyFojeAuwtIN4C6i1g3gLJWyB7C3z7TKaYSNd7xbJMDNcSlcu1rGtKMrLLxVy5WMzoy8ViV7+8LBf2F2cNazuyRnq1tsihe0+Nt3uo5Xi/pzGm9SEaOV4uXtZX1Z+2bdWVSL66+qmvNFBf40B95e/b13K/r8n4y7UpXSa2xOemy/ttur7fplv3pqfImwdfLRyrTecQ1mcBByuNyREDrU+yGK6iEevkSAP1NQ/U1/Jd+5oFn34lvN+m0/ttev8VQZYtApK1saZV4tXdla4urq5pWxGzwgP1VQbqqw7UVxuor2mgvuY33tey9TVSfN348o4bTyG88dZbvrSe77uZlbg+6sOlzZHKS09pmJ5+h2WNXXqaqdFTls0jOTV6mkpeu5qDWKMZjfsMBZ6WuWEZmZa5YRmdlrlhGZuWuWGZNC1zwzJ5CMs8d7UM01UK43SVztPVHHSNvublbn6/GXHJmq5dLFfpYUu1XybbMqwxXO4CMdfiupK3gJ5kvuxRWOOLzU+0oH03Nj/RUtnR5pEuNtfYsHkqsl6dSuHG1bzlg4WvNnnVxMilGTEyX1/8PJYyx/I0Y3mi7cjwY3miDdTwY3miLd/wY3miTerwY3miXfjoYxlPFGYYfixnHOU8YznjM+cZyxn3Oc9YyhzL04zljPucZyxn3Oc8YznjPucZyxn3Oc9YzrjPacaSZ9znPGM54z7nGcsZ9znPWM64z3nGUuZYnmYsZ9znPGM54z7nGcsZ9znPWM64z3nGcsZ9TjOWMuM+5xnLGfd5R2PJtBYHRY62G8sZ9znPWM64z3nGUuZYnmYsZ9znPGM54z7nGcsZ9znPWM64z3nGcsZ9TjOWOuM+5xnLGfc5z1jOuM95xnLGfc4zljLH8jRjOeM+5xnLGfc5z1jOuM95xnLGfc4zljPuc5qxtBn3Oc9YzrjPecZyxn3e0Vim7aszMansxnLGfc4zljLH8jRjOeM+5xnLGfc5z1jOuM95xnLGfc4zljPuc5qxTDPuc56xnHGf84zld4j7ULyMpdwfSw5bQ5ikcfGjX8cKq5tIjpdGr1/HSjwtc8MyMi1zwzI6LXPDMjYtc8MyaVrmhmXytMwNy5RpmbplcpiWuWEZmpa5YZm5Br5lmbkGvmUZGcMyz30dZFX73NdB1qnPfT3TyvNdvCEpn2lF+z4sfqaV8ruweDnTCvx9WPxMK/v3YfEz7Rjeh8XPtBN5HxaXafHOFj/TPut9WPxMu733YfG55+xt8bnn7G3xuefsa/EY5p6zt8XnnrO3xeees7fF556zt8VlWryzxeees7fF556zt8XnnrO3xeees7fF556zs8Vp7jl7W3zuOXtbfO45e1t87jl7W1ymxTtbfO45e1t8rsePt7heLG6v36e2jMe0eNdK5hjnWqW3xedapbfFZVq8s8XnWqW3xWd8vLfFZ3y8t8Xnery3xWd8vLPFecbHe1v8O+w5y1olTeUq7LB0+rlB8a01iN9ag6R7g0rZ4haB2q9SWxuibFeebPGl+d1XxzHwNgWC5PvNl8yyzq0sl2lbfxOcpvXukTWn64ufu2r9u3r57aDhflfL9hq7Umg/Tuk7uJlcGk87v89vrUHljTVIjnh8bk6xtE23i/XlcSHkrhDdFdhdQdwV1F3B3BWSu0J2VyjeCod89LqU9Wri5Z/7NxlN68UWGs96MaP1YWlXN68bD8uwLYg10uuH5SFfhH6oo0brssA4NjoqaR0k0UD3O1qsrJ/NKSnqrqP1O1yOW0dzKo2OhhLWB8Hy51h2GtxBQzpoaAcN66BRvRPxstJf95N89W7gReMZKgBU/ygTyaV9cnWTudEb4W0aBUm73tQ/FnSwhnTQ0A4a1kEjddCoejDpdg8lzWHnjAWA6q99b0GEQBGBGIEEgRSBDIHqDlS0bHGItLvT1F+12oIKANVf0NmCCIEiAjECCQIpAn37Sj6lvEakMl09c5Zl1bNCclfI7grFW+GAl1y1FMhdIborsLuCuCuou8IBu3OO25cpiDnrTiN10MgdNIq7Bh/xMoGmBnXQiB00uIPGt8/xJS4TaQvMqPBfd4MJadn3fbk60deb/kqEYNmmrRGCmF9HCPiQAtuvW7+3kHXQSB00vv0OksvmTPl6/bQqFG+FA8rCWgoH3DuELttJuRxefolT8hFlPw0FdlcQdwV1VzB3heSukN0VirdCDO4K7nM6us/p6D6no/ucju5zOh48pzVdK1Qupu0w0rL3uESLyKS28tG8/nSy0Fj5JM5rbiRJbByvIOIt7bK0KbwOSvIRp1BlO8JBUvS+Ye6emOAjTq/dbs2zQnRXqE/IYutudFm+h/sKqtv5n3QxEvPLSqR+emlZZK2WZdolNbh+ZqgFGQIlBMoIVACofsKjBRECRQRiBEI8QhCPEMQjBPEIueERcjk/GhvTqJVTZCn+Gho6aFAHjdhBQx5P13I9wd2Csnu+j+vJ52M1LHTQoA4asYMGd9CQx3OHbIpAhkAJgTICAXlrRvLWjOStGclbcwKylHwjb92AFIEMgRICZQQC8taM5K0ZyVtz9s7LcWZ3BXFXUHcFc1dI7grZXcE7187uuXZ2z7Vz6ZCLKx1ycUd8FKapoR00rING6qCRO2j459zlkBf4f68crxzyMvz7uVE55PXvLQ3uoPHtd5D7+VE5IOPeUjB3hQPuHZfKBbquXHgJDssRr+htKBRvhSNewdpQIHeF6K7A7grirqDuCuau4D6nyX1Ok/ucju5zOrrP6XjwnOayU2B3BXFXUHcFc1dI7grZXaF4K3BwVyB3hQPmdNItwJ+u3qaxKqi7QnJXyL5HDgTJtAuSaRck0y5Ipl2QTLsgmXZBMu2CZNoFybSLZARCPEIRj1DEIxTxCGX3FLfcSHEfq6EdNKyDRuqgAVSISz3r3oL808/SoeRbOpR8S4eSb+lQ8i2WO2gAmXZBMu2CZNoFybQLUiEuSIW4IBXiglSIS0oIBGTaBcm0C5JpFyTTLkiFuCAV4oJUiAtSIS7ZEMg7ES3uiWhxT0SLeyJa3BPR4l70Le5F3+Je9C3uRd9SzF3BP/0sHdLP0iH9rB1KvrVDybd2KPnWDiXfGqSDxvGF2f2OHGiHkm/tUPKth3wptqVxwB2k0OU1zvI6OKxHJKIbCuSuEN0V2F1B3BXUXcHcFZK7QnZXcJ/T0X1OR/c5Hd3ndHSf0/HgOW3hWuH9FkxrBJI5Gg2BEgJlBAKSOcoBgQiBIgIxAgkCIR6BlFYrUlqtSGm1sn9lrErooEEdNGIHDe6gARTS6o00dQPyr4xVDR00qING7KDBHTSkgwaQzFE1BEoIlBEISO+pBQQiBIoIxAgkj6dY1BSBDIESAmUEAtJ7mgICEQJFBPJOX2gSdwV1VzB3heSukN0VvFOSmoO7ArkrRHeFDimLAyre2xraQcM6aKQOGrmDRofUZOmQmizH1692TIUV/8pYLdxBQzpofPsdJIbtMH8MZReuPeBgQ0shuStkd4XirGAHHGloKZC7QnRXYHcFcVdQdwVzV0juCtldwX1O07Fzeskw7RTIXSG6K7C7grgrqLuCuSskd4XsrlC8FSKQvLRICBQRiBFIEEgRyBAoIVBGICCdbUg625B0tiHpbEPS2XYrnX1g1tBYO2hYB43UQcP/ndYmQG2i3UiTN6AbX2Hezs8sf8w7iBFIEMi/vs8kd9DwT5Zbh2S5dUiWW4dkuSmQvLQb2e8GpAhkCJQQKCMQkM42JJ1tSDrbDEhemjECCQIpAhkCJQTKCASksw1JZxuSzjYknW3Im8INeVO4IW8KN+RN4Ya8KdyQ+mVD6pfNPSdr7jlZc8/Jmvs7yM39HeTm/g5yc38HubmXfpt76be5l35bhyysFeqgETtocAcN6aChHTSsg0bqoHHAaQsqZdvuxEB2rbG/XDKvWynJ0qilybp9KC9rTtcXP7f+gHMcMcR4af1Vg+qtXzYFa+vtqsjoRuuDbq2P9Kr16Yji9a9tL/JqfNMRxetNjdhB49vvTcIXx2N7/X3PFMRdQd0VzF0huStkd4XirXBAvrelQO4K0V3BfU6T+5wm9zlN7nOa3Oc0HTynU9kpFG+FGNwVyF0huiuwu4K4K6i7grkrJHeFI+b0tugT4bBTKN4KHNwVyF0huiuwu4K4K6i7grkrJHcF9znN7nNa3Oe0uM9pcZ/TcvCcFt0piLuCuiuYu0JyV8juCsVbQYO7ArkrRHcF4GBUqh8raUGKQPXJlGO+QOW+AVpH11L9FMrBGrmDRvHXqB+JOVgjPn4qMNUPw7Qg//f9pw7v+08d3vefzP88YEqhgwZ10ADeTpKQjw8k5OMDCfn4QEI+PpCQjw+klBEIOOCXckAg4DhXQj4+kJCPDyTk4wMJ+fhAQj4+kHJCoIxAwHGuVAICIR5REI8oiEcUxCMK4hEF8YiCeERBPKJ4nxzKIbgrkLtCdFdgdwVxV1B3BXNXSO4K2V3B/60smUIHDeqgETtocAcN6aChHTSsg8YB5wG/21m9fMSr5b/bWb18xGvrG2fccgwdNKiDxgGRzsvHhEXL6+xFPuKUQUNB3BXUXcHcFZK7QnZXKN4KR5wyaCiQu4L7nGb3Oc3uc5rd5zS7z2k+dk5b4J1Cdlco3goS3BXIXSG6K7C7grgrqLuCuSscMKctpk1By04huysUb4UjThk0FMhdIborsLuCuCuou4K5K7jPaXWf0+o+p819Tpv7nLaD5/TVxasCuyuIu4K6K5i7QnJXyO4KxVshBXcFcleI7oev8o0vohyrIR00tIOGddDIj59ry/XDMA3o4bfAPEOMQIJAikCGQP7nQXPOHTT8z4PmEjpoUAeNR297z5AgkCKQIVBCoIxA5XGohIBAhEARgRiBBIEUgQyBEgJlBEI8ghCPIMQjCPEIQjyCEI8gxCMI8QhCPIIQjyDEIyLiERHxiIh4REQ8IiIeERGPiIhHRMQjIuIREfEIRjyCEY9gxCMY8QhGPIIRj2DEIxjxCEY8ghGPEMQjBPEIQTxCEI8QxCME8QhBPEIQjxDEIwTxCEU8QhGPUMQjFPEIRTxCEY9QxCMU8QhFPEIRjzDEIwzxCEM8whCPMMQjDPGIegybpWzhJGX76+4GfDvleVWVIfzy68n117PrrxfPX6/HrA/7dXL99ej66+z66+L66+r6665zNbnO1eQ6V5PrXM2uczW7ztXsOlez61zNrnM1u87V7DpXs+tcPeJr2DHRWj5By7rjcqq0WplBmbY6jiWFdLmYKxdz2BrCJI2Lc9zakaNeCkTiU/H33ijLRms1SyncuJrTWp4jfGlGrF0aecv+Rma9vvjJ4ke8lX5a/CGL07R4Z4vHafHDLU68WTzazuI8Ld7Z4jIt3tniOi3e2eI2Ld7Z4mlavLPF87R4Z4vPPWdfi1MIc9PZ3eRz19nd5HPb2dvk9RN4mdbgZL4SYNUvECOQIJAikCFQQqCMQAWA6ifwctjeycWpAtFjUM19yvZaaAmXOBGzfZGI/hKKdN0QKCFQBqD6ATCVFVLJu6laP//VYDLAlMeZ+uGvBkMAEwGGAUYARgEG8IP6qS/N6/uyNMc9kwGmPM7Uj3zZ9ig05j1DABMBhgFGAEYBxgAmAUwGmPI4Y4AfGOAHBvjBjTeoL/ewdSUYctlRN96J3qLqryQm3aqgKO1n0Y33lrcohiiBqPpriSnbtvYOFWvceD9+XG8pyx8rWgWhbrxTvEURREWIYogSiLrxqnnZRlkT7SmDqARRGaIKQt14u3iLIoi68Q2Csm7LyGh/j7rxgvEWJRClEGUQlSAqQ1QBKKqHfYh5o1jjnooQxRAlEKUQZRCVICpDVEGoeoljk4J8gyDfoBu+YXmjMu0pgSiFKIOoBFEZogpCRWTlQJEgKkIUQ1Q9NZm2FWxMKnuqbnnL21MvhYpWQah6UWGTIoiqWz6VtMWDyfYUQ5RAlEKUQVSCqAxRBaHqEaYmRRAF+YZAviGQbwjkGwL5hkC+ITe+DHN56hWpUAWh9NZ3167uh5cgLJnU8jVLTHaN2C5hku3q6gvnU+Y1Wp9yabyd/skWW0qK9CoJ8/LSk+VBSo9nBMgiAjECCQIpAhkCJQTKCFQeD/VTejBz83iGhBL5SwjSdUUgQyAgc0M3giJX36n46jMVtSzvgZ+peAqe1duzVYo8rWh7tqd+4w/b64qfIl/327OERNK2276KxVbbU7SsjS92Nf+29uRWeyh+1Z4XqiDUjaBIML6MxaU7VJ1UV9HQcnmgPL3y7UXC/CWSv0T2lyjeEjEEfwnyl4j+EuwvIQdI6PY4u9r7Pb9tcb+Yczt7czkCFOM+ERWDjtJRG6WjaZSO5lE6WgbpKIVROkqjdDSO0lEepaMySkdHWRnRKCsjGmVlRKOsjGiUlVEcZWUUR1kZxVFWRnGUlVEcZWUUR1kZxVFWRnGUlVEcZWUUR1kZ8SgrIx5lZcTneY7qpaNm+46e5q57//xm5NPcdVsdPc1dt9FROc1dt9XR09x1Wx09zX601dHT7EdbHT3Nc7TV0dPsR1sdPc1+tNXR+sqI8nZebhn0rzr6guVHsX3TVMvaNMvx6gU71ZdibycdU7qcIno63P3cHiWoGxoxjDFMMEzfmK3tjbUnva32GL+x9sgba88b8+d0mj3T3dd8Lx09zZ6p0dF8mj1Tq6On2TPdf3FdzKfZM7U6epo9U6ujMkpHT7NnanX0NHumVkdPE01udfQ8K6NGR8+zMrrf0XKelVGjo6MsGPzL5di/XI79y+XYv1yO/cvlOIi/hPpLmL9E8pcY5IgLj1IWxaOURfEoZVE8SlkUj1IWxaOURfEoZVE8SlkUj1IWxaOURfEoZVE8SlkUj1IWxaOURfEoZVE8SlkUj1IWxaOURfEoZVE8SlkUj1IWxaOURfEoZVHMo6yMeJSV0YkK3RodHWVldJ5Ct/ulizxKWRSPUhbFo5RF8ShlUTxKWRSPUhbFMkjBOMsgBeMsgxSMsw5SMM5YzR8/XvO3b9qB5Uf8eHnfC2YYljAsY1h5W7auf6j4O7aH3lh73lYpJdvbKjNme2P+fKKyqLuFbnyisqhGR2WUjg5SFsWjlEXxKGVRPEpZFI9SFsWjlEVxGaRgnEep/+IySME4Fxmlo4MsGORGXSFtzXn6nOpXm55K43X78Heyq0+Z1j/ku+wj1ouvv5l+40O+nLbyr6Wx5fry5/bXq4Xuf1VWiBAoIhAjkCCQIpAhUEKg+td/734uVujBr//W3P/+V3YlBn8JBrpeP0faghSBgK//CiMuyoiLMuKijLgoZwQqACTITUuQm1Y9od8YXGH3OSHiL5GQriO3KQE+Ui4aAOhGrFrCGqFcpnNqPK1z4NVwOWhuPK0zr/6Vcgmtp7Xky7JBr1Yb69O6Httewqpbr4ku7S9fRrIegW5SBaHq345vUgRREaIYogSiFKIMouqhK466LnafTpzpnssgVzDuxovt2hyBXAQ5BjkBuaqvLC605mWWEb7cEbS2WVnavG4klmY09gZZU1z9SXPa3WvqMd9l+GyT4HzdnhcqQVSGqIJQ9ThZkyKIihDFECUQpRAF+UaBfKNAvlEQ39AQIKrtGxr3VIQohiiBKIUog6gEURmiCkJRgKgbvmFpozLvqRvjVbZnQeGwpxSiDKISRGWIKggVA0QRREWIYoiCfCNCvhEh34iQb0TIN2LbN6TsKA4QRRAVIYohSiBKIcogKkFUhqi6b5S03nuX5/2eqgeXmhRBVIQohiiBKIUog6gEURmiIN9QyDcU8g2FfEMh39C2b1yd8tsohSiDqARRGaIKQlmAKIKoCFEMUdVRXhbsvFFpvycyg6iEUPUIz/KfV+hqhb2GgrUe3mlB1XlicTsMe3VI8AIpAhkCVc1ndIGsAmUEqk4R3Z7HFvbRd61HXloQIVBEIEYgQSBFoLpHbIckLMUKlB6HrL7OTbZ6RLJdIYvVV55lO+9Rku0ZBRgDmAQwN85HbuU8FHLZUwWhbn0es0ERREWIYogSiFKIMohKEAX5hkC+oZBvKOQbCvmGQr5RXzvev8fUV44lrjnTIhUGmPv1ldx9nfo6rsFEgGGAAe7NBtybDbg311d8Ja9+8NVhvpXJAFMeZ+q57Kv+1Bh63Ab1PHaDYYAB/CABfpAAP0jAPK1nrhtMeZzJAWAAPyjAPsYKIxCwj7GiCGQIBOxjrGQEKo9DKQD7mBQIgSICMQIJAikCGQIB+5hUzw62oAJA9dxgCyIEig9Cfy1//d8ff//040+ff/ljQZ7+739+/fnPT7/9+uWvf/7fv9f/89Pvnz5//vSvH/79+28///KP//z+yw+ff/v56f99CF/+9XeywB/JoizNeXI00hQ+LgGB8NS85wtC0I8U6Pk/0DOxrE6Wf6WlLUt7/h8=","names":["public_dispatch"],"brillig_names":["public_dispatch"]},{"name":"get_zkID_from_address","hash":"2789096167438080899","is_unconstrained":true,"custom_attributes":["public","view"],"abi":{"parameters":[{"name":"address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"}],"return_type":{"abi_type":{"kind":"field"},"visibility":"public"},"error_types":{"206160798890201757":{"error_kind":"string","string":"Storage slot 0 not allowed. Storage slots must start from 1."},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"12285239479773811347":{"error_kind":"string","string":"Function get_zkID_from_address can only be called statically"},"13699457482007836410":{"error_kind":"string","string":"Not initialized"},"14225679739041873922":{"error_kind":"string","string":"Index out of bounds"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"7Z3bbuM2EIbfxde5IIfDU15lUQQ5eAMDhh04ToEiyLuXak1J9nClcqguEGhujCieXxx9JIV/GEX83Lxsnz5eH3aHn8f3zf2Pz83++Px43h0P6ejz627zdNrt97vXh/GvN6r7APVP/Pvb46E7fD8/ns6be23AqrvN9vDS/WyCTef4udtvN/fRfd3RcAWQoxXCEGwKweicvgSj86oPdroQHKyyl+BgQY+D/7jbgF4k+RhztNbx9yUPiyRvQ08+zJDX1vsc7IyZTj7amK80OoO3yZuFk9dwlXzXBP7/TdhiE5A6K4vAopluwqcBdIn2KXyGKrg8UyIEe0vV/Zd8ri65U3mWKrBUkaMyxZsMKJeHI6Q52GusKnakM8MsHbpEW1sc6a4/89DpRvtS/0XMs9THOJwZQikP4/Pow9GkgFIogM4nBhhNt2KwxczCYhiHdvi04GvBB4KvBZ8RfC34UPC14LOCrwWfE3wt+Lzga8EXBF8Lvij4GvChVB1N+KTqaMInVccsvpAXDexo6eqCT6qOJnwo+FrwSdUxh8/1se46tMMnVUcTPqk6mvBJ1dGET6qOFnxWqo4mfFJ1NOGTqqMJn1QdTfhQ8LXgk6qjCZ9UHU34pOpowidVRxM+qToIEyelBGUi9QFlIqafMhEnT5mgMCFMxHNTJmKkKRNxx5SJWF7KRHwsYeLFx1Im4mMpE/GxlIn4WMoEhQlhIj6WMhEfS5ms08canVMGA+6WyTp97DSTdfrYSSZhnT52msk6few0k3X62Gkm6/Sx00xQmBAm6/Sx00zW6WOnmYiPpUzEx1Im4mMJkyg+ljIRH0uZiI+lTMTHUiYoTAgT8bGUifhYykR8LGWyTh/rMceCt/zgDuA6TW8NQO0C5uvz6vb/v7Vap0VekuA6DfWSBNdpv5ckuE6zXkXQx/6dwEE7QhCFYCPBdRYCSxJcZ9mwJMF1FhlLEpSSpJWg1CSNBLXUJK0EpSZpJSg1SStBqUlmCUbTX19EShCFYCPBBWoSHfqNVWC04UeZoLUxJ+8CDMl3rVCE/RY73g9vVdUO/83dfePc/TfOPXzj3Ge95/gm8Ivc+3mdulFdNVFIx/brUt6pmT2BvAl5snoc7VFUDE6JetcngiqOw7trLe83kRZy+l2TVIi3N4TyLgtzovJuRdriAIosyZXfqD8nChxRZIjK7wxPA7dnDoqAKL+rWOOwJ9K4W7MIOSLLETmOyHNEgSOKDFH5LYupb/vOtV4TkeaIgCMyHBFyRJYjchxReUTY2DsNpw0RBY4oMkROcUSaIwKOyHBEyBGVO9cMjtBYMp/KrzeYEwWOKDJEXnFEmiMCjshwRMgRWY6IMyI8Z0T4X4wI1/s+E8iNxUeGKCiOSHNEwBEZjgg5Io4lCBxLEDiWIHAsQfmBwuSke0+NRFJMLvZlfvSkCi4/ZjQtibUSKD9JMi3R9W4cyk8LzIkMR4QckeWIHEfkOaLAEUWGqLyKPyfijAjNGRGaMyI0Z0RozojQnBFRXrqYup1AecUgQl4DiEgkUD/Ry7soT7eC9RJbL3H1El9/+aFeUn8DLm8+HEPu/atV2otE10ugXmJmrqUgwfrLt/USVy+p731T3/umvvexflaWNz6blkC9xNRLKnv/Kx39+XjaPT7tt+9J0X35cXg+746Hy+H5r7f8zdNpt9/vXh/eTsfn7cvHafuwPz53323U5eMHpKWz9LeHzgh1hzp5OA2uO+yIQVqXBB9Sq6nlvwE=","names":["get_zkID_from_address"],"brillig_names":["get_zkID_from_address"]},{"name":"is_valid_zkID","hash":"6817016525015789670","is_unconstrained":true,"custom_attributes":["public","view"],"abi":{"parameters":[{"name":"zkID","type":{"kind":"field"},"visibility":"private"}],"return_type":{"abi_type":{"kind":"boolean"},"visibility":"public"},"error_types":{"206160798890201757":{"error_kind":"string","string":"Storage slot 0 not allowed. Storage slots must start from 1."},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"11032241527761073405":{"error_kind":"string","string":"Function is_valid_zkID can only be called statically"},"13699457482007836410":{"error_kind":"string","string":"Not initialized"},"14225679739041873922":{"error_kind":"string","string":"Index out of bounds"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"H4sIAAAAAAAA/9VazW4jRRDusT22x443XhakFZeVQOI84584uRklC1kOILFPMLFnUFDQoiQgjnNAiAtISNyQuHHnwmOAhMRLcOEZSDtd8efP5bEdz0RQUtQzU9VV1dX11+145hY892ehBt8Y5NvYjeFuEBXIK/QUPXMXoU14xz0E7r0C+GqBCw8UXYrifxgOzgKzvOYC9e8HjmeZ9hGeJfAPG47Pi2zOn9dioWMWgwPnNB1enl+HORY+AN4yv0y73ex7XLLdoidmta3E544zcwcFyQ2F90lWyrr6wv858C9D//fK0f+O//vl6H+Xr07L0T9qm9sY+tbx27v567rn+MvPPvp88mqavDudXiZXV5y30RfzYBue1S14PmWeH35xcXGenieXz786v7pe4q0VWHmu0LfKCr3wO4JPMt50o7Xt96DzG6zzi6uX1/H1+eQ4vri4r4E5+VgYuzHcDSJDC/PN6kTERngGRvjBPXeMbmBtNEZ3CJnbVXhJIumYZZtwMajRGsbuPdwNBpusA+W3TLnFwyN5og/bR+wotvMVXbuEsyCFx1NwVeVb5YF57Rt9v1GOZptajhycL3SBMm/sxnA76PEH3hORjXLrtL57ymYYburPIr9llv2nDH+ukz6rfENs11B07RLOAvtgQ5HTUOT8X3ihjz5UbGhy/B3laPmpo8zbtb5otsmrL/eVgzQ+yfELlIO8pDEWOfUC5SAvqcuSq9BPx24Md4Oe8G6CbgXmnSOxER/y0X4tkM0+2Sa9ELcHON77DuDqhHsEOIxvhiq9o53s+CPwZTqBQJFToH0PO6QXAttes2+L9EIc2p7ti7Zn+6LttTgQ0OwrdtrUvvuKnDrJF541+i4gceYT/aduLDlGwteAryFZgbK+AmWPuM4jdJR1s/8EpBfi0LfYf9C3cL8YNB8ROqvXH8CX6QQ0H+Eay/GJuKayDq3OeYTDfN8gHNbhJuGwBuAlCfI0Ru9f5NJDWzPXXT6Dos24b5J11lbw4xgSOvd5tsaGE2Bzh1xA3h3qX16/uow/ST5O4qm3Qk/2D6bLyzWI982y/sekv9B+40a7J1+7Z+0MLftUhznaHsgc6/8SO7Vsji8qtkeH818ZqrA2jieU7xP9d+4d41jG2g56pqM4SvtxGg/j6XQwiTn/GbJT0fLPkijpp2naT+JBepA+uPyjoyg+GPZH0/iwlw7S6Tr5eNkoPsXnVsRpZxbxQ8k1+B3zB8ex0P/kRqlHnPfH97QFg1YLA1oD1vOqWc6ZJ9niGoT+Nzda2p/Nos24Z0Ac2rNCOO4JEKf1XcJffMqHNTRz1iD0v7jR0racolL7JG5xPWXmmBsYzH5YAj1Q15n+2eK624CrKvR4R2r/9hR67B24dmpnAo/ekRfa/JR0FRvWFXrk5xP9r260tG97i/qhX7dId1w79wvaOVfrQQLQ+Xf3XPJd19Y9pEc4jBO+f9r0fJL3nwBaDym22LaHLCJP1EjefyVu8YzOcYsxWlXoOW7XxbncoXTN8l6yf2u1YJuYsXBK8tBfZG8wZrjuandKsgY770/gh/uI+R3nnmRzPNL/Dbr85Z73jZ7PEId+yb636dmG7+RLqvEDrU54JLtdjuyN7+VFfsvoeWhcjD5RXrxgT1Mh++yVtDeiT0fRR6vTj83tfRrvGeonvLQ6pfkv2prtkGebrjKff7PAPeY8U1F02OQsr+WStsnv1T3ipeUJrd6s+/1G8hz3vv+40c73nRG0/MB5BfMD5xXt7kdw2p2u8Nd6OuzDuJZovqj1eSIb/bCzAa9GjuxHCn0nRzbqhXNZ9qp40XoCvAu0UANckblR6wkwL3FPkNebW9jElto+dokebafFMccjym0TDuOPewn0U/FfjBftN348I0gPUPR9QdibTg6S3s2Vzugg6h1NH/q+YjI8OJsMhnGYRDNt1snfF5tkczz6s4WGe5czPNMLP5/oHzsG1t5PYF9mtIo8S/dWDp23YpzxUL7VssVvQbZMX82W6UV2K1vWUXBtwGGsWdhz72gv5CV6+ET/DHK9hSbMkfldRX6T5C/orXzj/7tqK/Rthd7uz1M36e5OBGQX3WvNZBJ//Ma6ie+UEVc3ITWaxKMoOhpEySAarourfwEfOa7jAi8AAA==","debug_symbols":"7Z3dbuM2EIXfxde+IIe/k1dZFIGTeAMDhh04ToEiyLtXci1K8VBSOXQLBJqbYLWeY1KfKOYcKRI/Vy/bp4/Xx93h9/F99fDrc7U/Pm/Ou+Oh2fr8Wq+eTrv9fvf6OPzvlWp/gL7Uv79tDu3m+3lzOq8etAGn1qvt4aX9t4mu+Y7fu/129YD+a03LFUBXrSz0xSZTbL3X12Lrg0rFXmeKo1PuWhwd6GHxH+sVwF06j9hVa43/X+fNXTrvYiIfZ8hrF0JX7I2Z7jw67PYUvbG3nbd37ryGb51vm3D/fRM+2wQ0B6sTgbNmuonQDKBrdWjKZ6iC784UhOhuqYZ/059vu9yqIkuFHJVRLFV2komYjmTEEG41wNAYhiY/kq223Q5Z65PGqewg86afQfrhop3LnoX+WgyqH5BGh9zYQtvNIAGx/2aIuX6Y0O2nHZywkCsF0N0XAwymgmyxs9204Wwclrb4nOCrwecFXw2+IPhq8EXBV4MPBV8FPqsEXw0+Lfhq8IHgq8FnBF8NPiv4avBJ6pjFF7tE7gbXha74JHVU4ZPUUYVPUsccPp9q/ffSFp+kjhp8TlJHFT5JHVX4JHVU4ZPUUYXPCr4afJI6qvBJ6qjCJ6mjCp+kjip8kjpq8HlJHVX4JHVU4ZPUQZlIlKBMrDAhTMT0Uybi5CkTseeUiXhuykSMNGESxB1TJmJ5KRPxsZSJ+FjKxAoTwkR8LGUiPpYyER9LmYiPpUzExxImcZk+1uiuy2DA3zJZpo+dZrJMHzvNZJk+dpqJFSaEyTJ97DSTZfrYaSbL9LHTTJbpY6eZLNPHTjJB8bGUifhYykR8LGUiPpYyscKEMBEfS5mIj6VMxMdSJuJjKRPxsYSJVmJkM1CW6WSD7WohOH7xheAyfW8JQe1jghEUEILLdMn3JGiFYCXBZTrwexJcpl8vIhgwvXM3avq7eJnu/p4El5kF7klwmcnhjgT1MmPGPQlKJqklKJmklqBkklqCVghWEpRMUktQMkktQckktQQlk9QSlExSSRAkk9QSlExSS1AyySxBNGn/0FKCkklqCdp6gjqmRcRgsLhVnqBz2HXeR+g7j5hDmJaTC6F/ybn29p++ux/cd/+D+x5+cN/nvacLc31P53UTBtS3JjLdcekeUfBqZv27YGJ3sgY7WI8vW9zMVsGnjliFw/LLvo64xJBWo7TopvcV03yH2K/QCB4uDRgobOAisgzRyFu9VZoImxsdeDu3jbzLekaUtzXa2f6Ykzt9I+8tnhEZjshyRPmJUsc0fEBRECNnSr+U4XCEdiJkiMbe/jct0hwRcESGI7IcUf44OZsOrguaiDxHFDiiyBEhQzTyxpsZkeaI8iPCYTJNXhsiMhyR5YgcR+Q5osARRY4IGaKR56RNb26NI+fTyIPEMyLDEVmOyHFEniMKHFHkiJAhGnmgakbEGRHIGREjz6wYnyysiWRiGXmoY0bkOCLPEQWOKHJEWC4CxbAEoDRHBByR4YiyIJpQkOLB7V/SQv6uNaYrFhg8kZhyiS2XuHKJL3fjMHKzZUYUOSJGwgBQHJHmiIAjMhyR5YgcR8QZEcAZEcAZEcAZEYYzIgxnRORXc5+cTvLRG6G7nIGWSspP9PyyydOtYLEkvzzutESXS8onYFs+AdvyCTi/xCNGlS7XGCLx5ZJQLokz+5KRYPHu5y/tTEt0uaT86Lvyo+/Kj74rPyvzy8tMS0K5JJZLCo/+V7P15+a02zztt++Nov3w4/B83h0P183zX2/dJ0+n3X6/e318Ox2fty8fp+3j/vjcfrZS1x+/wOMaULVWtd1sjOm6uRzcbrYDBlA3n5qm1ablvwE=","names":["is_valid_zkID"],"brillig_names":["is_valid_zkID"]},{"name":"_add_zkID","hash":"17597657300507300397","is_unconstrained":true,"custom_attributes":["public","internal"],"abi":{"parameters":[{"name":"zk_id","type":{"kind":"field"},"visibility":"private"},{"name":"address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"}],"return_type":null,"error_types":{"206160798890201757":{"error_kind":"string","string":"Storage slot 0 not allowed. Storage slots must start from 1."},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"7995561580326778049":{"error_kind":"string","string":"Function _add_zkID can only be called internally"},"13699457482007836410":{"error_kind":"string","string":"Not initialized"},"14225679739041873922":{"error_kind":"string","string":"Index out of bounds"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"H4sIAAAAAAAA/9VbzYojVRS+laSm8zsdHQTd6MYHSNJJZwYRInbb6kIRF4LoIpNUpGF0pGeU0YXUxp0wguCDCG58ChGfQBCfQHCj2NV9T+fLl69qKp2qnpkLTaXq3nu+c88959xzTlUH7rwF/i9pNX+tuPVmYyb+2tuu9Quk1SuTz6AkPleEHLj0Zn0/+h8Nmp88rha44AbhFkn/Zm84bYj1Fcj/XgNolkB/YPRr5dDv7Xg6b8ar9B3hdtyq8eIc60Mde8v31X2//b7hfzeIXhn7jjwVLbcbgv8KrC1pr8elYO8Z/QOg7wpcm9E/LIf/C/pvlMP/hU85Kof/fsud6/I/nl779K/rf0+//PTdz2d359Fr8/lJdO8e2gvbcVbbhGa4Ac3nmeY7X9y5c7w4jk4OHxzfu79G+5qgbb8rKWtjvtQB73w/Yrzgr4ls/wOed5nn96PP5tHJkyRaR0sJBU8h9dnYF/01WXYAxy6LdOKvve3aoEP8GH+Ii9tepOsKCM+51eOG5dh06/tQpCkHhGf8sHxMhU12O4LXrujD/cc+xNkROIoW71EJutHruHV5MC7yVOBeDPPqhuE3Xam62s/aM5QP60Zd8NoVfawbdYFTFzhXRWvXpev6ZfUZ59u4hpg38dfeZm3AD3hPDBtxMQUpUH9GefXZ8JtufS/K0OcG8ZOmGya7puC1K/pYB5sCpylwniZapqNmG6g7bBtKzo0MHJzfyMCpb4lTFzgdMS9IuRoOP2McJZus8+WyOCi3OuHUC8RBWofxKk6zQBykdRCfX81XtWB+kWWGDtDkNSby/RBwk7+2vw/dUudwbS3ox/F/uiXNj/1v03GM8ZopeCqeRjkx3m23Kr8OzC8ypX0W6DrCaoj1FYg969CasXXEutnmr0Mf2+ku9LFtdaEP94tble5RFgnNWrCky+OsKR1hH9kW67C+jliH8lMh9aFvaVMf+tEO9aENY5mDfV/Vre+dlS3Umtlvcr6JY9NiwloKvYN4lZaNf+Cvyf2rflMSfp/zz5dp+f27J9NPog9Oju9HjhrXCjj5rIhx2Bpi3sRfe9u1vTxJT0lBWe6E2PCvKulRCURW0qMClCwDu2zwgrSYB/WOo2TnmztpNfwm8VrW/oVCrhUhV5W0shN8GpNW3O8K4SjZhBk4ON/G5SmileQzcieW7DPKLqLVc8p1U5/BerKNz3hSaXFiiUUX1t9Niy6VnDjhljihwOmIeUHK1XD4WVZRNM8ZcFmcTe3+sjhI6zBexSkrgT2IV3HSEr+fgC7qbN7Ez8b/5pY0f/a/d8V8Lm5YzMHvv3kd/FLlF38tucgnE78GYZf0bcAtVbSxpop3bJNYTGA7wmSKdV8lU4HgQSV+9mzTxK8q1mF918Q6VOGM4xp+kYF9aPv8gkclocrGOPFDeaiYmhM/jhGduA/FWD6X7D6vDdm4X/210MSP7wMxDlvLrTuT3/01Ed4fREtVd1XiYuPbYjwajQlKKZTNbaTMm/j73nZt4woPGzpWeNjQscLDho4VHq7+PAN9/BEXNuUETE4JzUkOJ6D2WQVbiGXGxAcczsUDjiuHf8GYvwm7I7BVoGvjr4vxXIlMmqpk2dySK5hRR/BqTekKVxFRV7iKiLrCeoQHaJP6bkAfyoSb0jH86CyvjvE+K9+QV8faQNeq5yazWrwcV9Qejm/2eraeqqcfunXZIH5I4//191zNtUNhckk+F+Npf7E3XUxH0/l8OJty0JQ0s5lWCfi3o360t1gs9qLpcLG/uHL8/WgxWvSiUX8x2BsPZ/1H4ePHZSrhOIzPr4lu7QRLWmh7GKDjXPsokQPml4Ilzab/rYopxnOe4EsFWNanijclB+vDrLd1Jb9hy120MfymKzWmuCjatIgf3NOkVUg+7ZL2JutsVW/nkzPlulvfM+TPaGHgy2+NUH/5reO1nLJRXwpw0oB7zIlIRfBgfSrxsT5cl9lTK2VtVVqb0VJ+guemyQL9ip2FIdF/GfzKK+RX1Ndtyj9kJXXsV7K+/FDnuSowZ+miSowNG/Wwk4PWTgb2o2JGxlYxI/PiXLq92BiLBVA2ZcYtp22U4HwNMRr7pTBelY3aRxyfR5ZqH7s0HmWn7JjtEXFb1KfyD2XHpr9oLxwDoD1iDFB03NIbzGf70eA0tBzv9we35pvELVk+SNl/nrfVaC8H8fmV31YfeeYeZ+GPfWzN6fODYzEbPwWf+Tb5TPbL2KcK48qfZtU00r6Ww3OinrEGG/+eZy4Z+z3ocdLQx9h6SvYxQ+VjMK5gH6PiIhWH5PFJKLOuS/c/Ad0jLZT5EfGKvoDHIz2O+T+CPfohWOUP9ZpjEvVCSfk59qsqDkt4+YpstqSPG8bqZZQ19SI8oL6sjw9UzVAV2rP+S0XVMUwWmxbMi/AT+M9/Z/zF63w9DrvF2h/brar/qpewee38MD6/dt36XrJ+q7NgE5tJ2hHhqRgfbcbi/bPn8ZIO7lXSdvx9DfBwvPEX0vhv4CyKSf9CgZeMe5gxLki5ntEQz2rx6rNGvD6+Gq+PN+xmvM6j9bWgD/UoaW1/j/JCWsZHSOO/g/M6aXWYY/O7Ar9O+Ct8i2eoT0yrKp7Z+GR/vvWTLs52wC66xnCGSfTxGfP2EPS66Hh2Ntq/PRuOpr2on9wOrroOeAo9nk3H/f6tYT8a9kePwv8f89zbmDZBAAA=","debug_symbols":"7Z3dbts4EIXfxde+4M+QHPZVikWQpGlhwEiKJF1gUeTd185GshIy0mpGTeXy3AR1w2ONP1HkOYxF/dx8ubn68e1id/v17mHz6fPPzf7u+vJxd3d7ePXzabu5ut/t97tvF8P/3pjjD2ee2z98v7w9vnx4vLx/3Hyy3gWz3dzcfjn+23M4vMfX3f5m8ynHp23Z3DjXtTbkTo19pTHFaF8aU0ymbxxtpTEHE14ac3B22Piv7cbZRYrPuWttbf644t0ixQfuyfMEeRtS6hpH78eLzyF3nzRHT2+L9wsXb92r4o+HoF9/iFA9hM25Fzlj4/ghiD11XYIHnf+dLpFc3yU4vaUaq/W4weXlXl1f8Rd30fQ/+BAN6zmqWKTKEpWvDl/kT6fEx9P5C6baRaI/Xf+nq8KGUGvNsWucuW/rbXquxq6qGreqavyqqqFVVRNWVU1cVTVpVdXwqqrJa6qGPnwsDl01hxnyVTVl25Spm+hSzqd3dlyrwyfT13yaclytqXO2e2PnBqaq2jhQZ8AC8bDpEZ8FPg0+B3wafB74NPgI+DT4AvBp8EXg0+BLwKfBx8CnwZeBT4EvIHWo8CF1qPAhdUzi4245Ogz+QPGCD6lDhY+AT4MPqWMKX+zbxtdNj/iQOlT4kDpU+JA6VPiQOjT4IlKHCh9ShwofUocKH1KHCh8BnwYfUocKH1KHCh9ShwofUocKH1JHwSQhSpRMkA9KJjD9JRM4+ZIJgUnBBJ67ZAIjXTKBOy6ZwPKWTOBjCyYMH1sygY8tmcDHlkzgY0smBCYFE/jYkgl8bMEkNzoXhxOTwed7YdLmGJuoa+tSkDc+AmxzQJ4D0EbuYNhk3n7fMLc5ei8IsM2hfkGAba5vLAiwzcWQWQBT7ncZYlvMwm2unCwH0Jo2vd2SBNtclVmSYJtrOEsSRBrREiQQVBJEHtESRCDREkQi0RJEJNESRCZRErTIJFqCyCRagsgkWoLIJFqCBIJTBLPvP1+mkiAyiZbgApnE8mnTbQoTBEPIXfGR3WCH7lxD2G9OntJpMx0b6b/a0xnXzmdcez7f2t2090x5onYy3REsufTqEGVrNr4bMtiEU0HVDfYT++7pEomzGW98mD849ENXcHHY/PmzvuMS+z3yibxZdHQc2/DZOreucvy6yqF1lRPWVU5cVzlpXeXwusrJqyrnvad+/K5yPnxU/qP2ULTegZ+Knwc/FT8CPxW/AH4qfhH8VPwS+Kn4Mfip+GXw0/AjA34qfsgfOn7IH5pttC0hf+j4Efip+CF/aDZls4T8oeOH/KHjh/yh44f8oeIXkD90/JA/dPyQP3T8kD90/Aj8VPyQP3T8kD90/JA/dPyQPypQMqAUUCKSQgUK7H8FCjx9BQqMegUKAUoJBZa6AgU+uQIF5rcCBY62AgWOtoSS4GgrUOBoK1DgaCtQ4GgrUAhQSihwtBUojfqUsX3KLbc5+yy3UbnlNqeq5bY5ttzmvLYkwTYnwSUJtjljLkmwzQWjBTd04jZXl5Yk2KbFW5Jgm+tWCxLMbS5yLUkQmURLEJlESxCZREuQQFBJEJlESxCZREsQmURLEJlESxCZREfQGWQSLUFkEi1BZBLdZtvOIJNoCZKe4G/aetqZcMa1xzOuPZ1x7dPec1DOWW9X7myb84t33aTrvA9vBzzb5pQxAYUApYTS5mKTt76H4gq/YNtcP5qA0uaS0ASUNld5JqC0uXAzDsW1uRYzAaXN5ZUJKI062nEojTracSgEKCUUmLcSim/z0a/j2ce3+TTXCShtPqB1Agq1CWV8TGnzMaoTUCKglFASoJRQGFBKKBlQCihkAKWE0qijHYfSqKMdh9Koox2HAvNWQqnvHZdi9/4pUiGp+r3ck8mpPEqaL+H5kjxbUt+nx5r+izjWcC5EViJyEpGXiEgiChJRlIiSRMQSURaIWNIjWNIjWNIjWNIjWNIjWNIj6jf2jg4n9TtZs+uGw0ylZP6FXr9PbPQo9RujxiU0XxLmS+YPwHn+AJznD8D1r69n7s7+q4ntWeLr39cel9j5EjfxWSoSP/fje0PzJWG+JM6XpPkSni+ZfVV6a+ZL7HyJmy+Zf/adYA7wzklE9TnAhn7TCptcISKJKEhEUSKquwLLnYW2zhQgfH2uJjf4HmdxpPrfhaZETiLyEhFJREEiihJR/TwF6k9uSLYQsUSUBaL6utGUyEpETiLyElG9R4TcR9Foi+mrHnanRFEiShIRS0RZIApGIrISUf3k+tN9Gj4U11P9IUFToiARRYkoSUQsEWWBqP7giCmRlYicRCTpEVHSI+I7PSL2d2N4LgaWGCWiJBGxRJQFoncWdCZEViKSWIIksQRJYgnSbEvwdHj19+X97vJqf/Nw0Bx/+eP2+nF3d/vy8vGf791vru53+/3u28X3+7vrmy8/7m8u9nfXx99tzMuPzz7x1ud8KObZ5jvirQv++PKIm4zfkgmHox6O/C8=","names":["_add_zkID"],"brillig_names":["_add_zkID"]},{"name":"verify_zkID","hash":"3713477923314157032","is_unconstrained":false,"custom_attributes":["private"],"abi":{"parameters":[{"name":"inputs","type":{"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs","fields":[{"name":"call_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"historical_header","type":{"kind":"struct","path":"aztec::protocol_types::block_header::BlockHeader","fields":[{"name":"last_archive","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"content_commitment","type":{"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment","fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"blobs_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}]}},{"name":"state","type":{"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference","fields":[{"name":"l1_to_l2_message_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"partial","type":{"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference","fields":[{"name":"note_hash_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"nullifier_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"public_data_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}}]}},{"name":"global_variables","type":{"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"fee_recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"gas_fees","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}},{"name":"total_fees","type":{"kind":"field"}},{"name":"total_mana_used","type":{"kind":"field"}}]}},{"name":"tx_context","type":{"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings","fields":[{"name":"gas_limits","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"teardown_gas_limits","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"max_fees_per_gas","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}},{"name":"max_priority_fees_per_gas","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}}]}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]},"visibility":"private"},{"name":"circuitInputs","type":{"kind":"struct","path":"types::SubProofInputs","fields":[{"name":"vkeys","type":{"kind":"struct","path":"types::Vkeys","fields":[{"name":"vkey_a","type":{"kind":"array","length":128,"type":{"kind":"field"}}},{"name":"vkey_b","type":{"kind":"array","length":128,"type":{"kind":"field"}}},{"name":"vkey_c","type":{"kind":"array","length":128,"type":{"kind":"field"}}},{"name":"vkey_d","type":{"kind":"array","length":128,"type":{"kind":"field"}}}]}},{"name":"proofs","type":{"kind":"struct","path":"types::Proofs","fields":[{"name":"proof_a","type":{"kind":"array","length":459,"type":{"kind":"field"}}},{"name":"proof_b","type":{"kind":"array","length":459,"type":{"kind":"field"}}},{"name":"proof_c","type":{"kind":"array","length":459,"type":{"kind":"field"}}},{"name":"proof_d","type":{"kind":"array","length":459,"type":{"kind":"field"}}}]}},{"name":"public_inputs","type":{"kind":"struct","path":"types::PubInputs","fields":[{"name":"input_a","type":{"kind":"array","length":2,"type":{"kind":"field"}}},{"name":"input_b","type":{"kind":"array","length":2,"type":{"kind":"field"}}},{"name":"input_c","type":{"kind":"array","length":2,"type":{"kind":"field"}}},{"name":"input_d","type":{"kind":"array","length":2,"type":{"kind":"field"}}}]}}]},"visibility":"private"},{"name":"zk_id","type":{"kind":"field"},"visibility":"private"},{"name":"add_zkID","type":{"kind":"boolean"},"visibility":"private"},{"name":"remove_zkID","type":{"kind":"boolean"},"visibility":"private"}],"return_type":{"abi_type":{"kind":"struct","path":"aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs","fields":[{"name":"call_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"is_fee_payer","type":{"kind":"boolean"}},{"name":"max_block_number","type":{"kind":"struct","path":"aztec::protocol_types::abis::max_block_number::MaxBlockNumber","fields":[{"name":"_opt","type":{"kind":"struct","path":"std::option::Option","fields":[{"name":"_is_some","type":{"kind":"boolean"}},{"name":"_value","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}},{"name":"note_hash_read_requests","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"nullifier_read_requests","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"key_validation_requests_and_generators","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator","fields":[{"name":"request","type":{"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest","fields":[{"name":"pk_m","type":{"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint","fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}]}},{"name":"sk_app","type":{"kind":"field"}}]}},{"name":"sk_app_generator","type":{"kind":"field"}}]}}},{"name":"note_hashes","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::note_hash::NoteHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"nullifiers","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::nullifier::Nullifier","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_hash","type":{"kind":"field"}}]}}},{"name":"private_call_requests","type":{"kind":"array","length":5,"type":{"kind":"struct","path":"aztec::protocol_types::abis::private_call_request::PrivateCallRequest","fields":[{"name":"call_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"public_call_requests","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::side_effect::counted::Counted","fields":[{"name":"inner","type":{"kind":"struct","path":"aztec::protocol_types::abis::public_call_request::PublicCallRequest","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"is_static_call","type":{"kind":"boolean"}},{"name":"calldata_hash","type":{"kind":"field"}}]}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"public_teardown_call_request","type":{"kind":"struct","path":"aztec::protocol_types::abis::public_call_request::PublicCallRequest","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"is_static_call","type":{"kind":"boolean"}},{"name":"calldata_hash","type":{"kind":"field"}}]}},{"name":"l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"kind":"struct","path":"aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message","fields":[{"name":"recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"content","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"private_logs","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::private_log::PrivateLogData","fields":[{"name":"log","type":{"kind":"struct","path":"aztec::protocol_types::abis::log::Log","fields":[{"name":"fields","type":{"kind":"array","length":18,"type":{"kind":"field"}}}]}},{"name":"note_hash_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"contract_class_logs_hashes","type":{"kind":"array","length":1,"type":{"kind":"struct","path":"aztec::protocol_types::abis::log_hash::LogHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"historical_header","type":{"kind":"struct","path":"aztec::protocol_types::block_header::BlockHeader","fields":[{"name":"last_archive","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"content_commitment","type":{"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment","fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"blobs_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}]}},{"name":"state","type":{"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference","fields":[{"name":"l1_to_l2_message_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"partial","type":{"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference","fields":[{"name":"note_hash_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"nullifier_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"public_data_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}}]}},{"name":"global_variables","type":{"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"fee_recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"gas_fees","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}},{"name":"total_fees","type":{"kind":"field"}},{"name":"total_mana_used","type":{"kind":"field"}}]}},{"name":"tx_context","type":{"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings","fields":[{"name":"gas_limits","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"teardown_gas_limits","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"max_fees_per_gas","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}},{"name":"max_priority_fees_per_gas","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}}]}}]},"visibility":"databus"},"error_types":{"783436594657808921":{"error_kind":"string","string":"comm_out of proof_c does not match comm_in of proof_d"},"2224917424955179192":{"error_kind":"string","string":"scoped nullifier of proof_d does not match zk_id"},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"14225679739041873922":{"error_kind":"string","string":"Index out of bounds"},"15712935051881954152":{"error_kind":"string","string":"comm_out of proof_a does not match comm_in of proof_b"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"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nDYm7RYbXdw2urhtdHHbDJu00cVto4vbRhe3jS5uG12cNsbtFhtd3Da6uG10cdsMm7TRxW2ji9tGF7eNLm4bXZw2Zu4WG13cNrq4bXRx2wybtNHFbaOL20YXt40ubhtdXDYXe3eLjS5uG13cNrq4bYZN2ujittHFbaOL20YXt40uTht7d4uNLm4bXdw2urhthk3a6OK20cVto4vbRhe3jS5OG3t3i40ubhtd3Da6uG2GTdro4rbRxW2ji9tGF7eNLk4be3eLjS5uG13cNrq4bYZN2ujittHFbaOL20YXt40uTht7d4uNLm4bXdw2urhthk3a6OK20cVto4vbRhe3jS5OG3t3i40ubhtd3Da6uG2GTdro4rbRxW2ji9tGF7eNLk4be3eLjS5uG13cNrq4bYZN2ujittHFbaOL20YXt40uTht7d4uNLm4bXdw2urhthk3a6OK20cVto4vbRhe3jS5OG3t3i40ubhtd3Da6uG2GTdro4rbRxW2ji9tGF7eNLk4be3eLjS5uG13cNrq4bYZN2ujittHFbaOL20YXt40uLpurvbvFRhe3jS5uG13cNsMmbXRx2+jittHFbaOL20YXp429u8VGF7eNLm4bXdw2wyZtdHHb6OK20cVto4vbRhenjb27xUYXt40ubhtd3DbDJm10cdvo4rbRxW2ji9tGF6eNvbvFRhe3jS5uG13cNsMmbXRx2+jittHFbaOL20YXp429u8VGF7eNLm4bXdw2wyZtdHHb6OK20cVto4vbRhenjb27xUYXt40ubhtd3DbDJm10cdvo4rbRxW2ji9tGF6eNvbvFRhe3jS5uG13cNsMmbXRx2+jittHFbaOL20YXp429u8VGF7eNLm4bXdw2wyZtdHHb6OK20cVto4vbRhenjb27xUYXt40ubhtd3DbDJm10cdvo4rbRxW2ji9tGF6eNvbvFRhe3jS5uG13cNsMmbXRx2+jittHFbaOL20YXl829vbvFRhe3jS5uG13cNsMmbXRx2+jittHFbaOL20YXp429u8VGF7eNLm4bXdw2wyZtdHHb6OK20cVto4vbRhenjb27xUYXt40ubhtd3DbDJm10cdvo4rbRxW2ji9tGF6eNvbvFRhe3jS5uG13cNsMmbXRx2+jittHFbaOL20YXp429u8VGF7eNLm4bXdw2wyZtdHHb6OK20cVto4vbRhen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G13cNrq4bXRx2wybtNHFbaOL20YXt40ubhtdXDZXe3eLjS5uG13cNrq4bYZN2ujittHFbaOL20YXt40uTht7d4uNLm4bXdw2urhthk3a6OK20cVto4vbRhe3jS5OG3t3i40ubhtd3Da6uG2GTdro4rbRxW2ji9tGF7eNLk4be3eLjS5uG13cNrq4bYZN2ujittHFbaOL20YXt40uTht7d4uNLm4bXdw2urhthk3a6OK20cVto4vbRhe3jS5OG3t3i40ubhtd3Da6uG2GTdro4rbRxW2ji9tGF7eNLk4be3eLjS5uG13cNrq4bYZN2ujittHFbaOL20YXt40uTht7d4uNLm4bXdw2urhthk3a6OK20cVto4vbRhe3jS5OG3t3i40ubhtd3Da6uG2GTdro4rbRxW2ji9tGF7eNLk4be3eLjS5uG13cNrq4bYZN2ujittHFbaOL20YXt40uLpt7e3eLjS5uG13cNrq4bYZN2ujittHFbaOL20YXt40uTht7d4uNLm4bXdw2urhthk3a6OK20cVto4vbRhe3jS5OG3t3i40ubhtd3Da6uG2GTdro4rbRxW2ji9tGF7eNLk4be3eLjS5uG13cNrq4bYZN2ujittHFbaOL20YXt40uTht7d4uNLm4bXdw2urhthk3a6OK20cVto4vbRhe3jS5OG3t3i40ubhtd3Da6uG2GTdro4rbRxW2ji9tGF7eNLk4be3eLjS5uG13cNrq4bYZN2ujittHFbaOL20YXt40uTht7d4uNLm4bXdw2urhthk3a6OK20cVto4vbRhe3jS5OG3t3i40ubhtd3Da6uG2GTdro4rbRxW2ji9tGF7eNLk4be3eLjS5uG13cNrq4bYZN2ujittHFbaOL20YXt40uLpuxd7fY6OK20cVto4vbZtikjS5uG13cNrq4bXRx2+jitLF3t9jo4rbRxW2ji9tm2KSNLm4bXdw2urhtdHHb6OK0sXe32OjittHFbaOL22bYpI0ubhtd3Da6uG10cdvo4rSxd7fY6OK20cVto4vbZtikjS5uG13cNrq4bXRx2+jitLF3t9jo4rbRxW2ji9tm2KSNLm4bXdw2urhtdHHb6OK0sXe32OjittHFbaOL22bYpI0ubhtd3Da6uG10cdvo4rSxd7fY6OK20cVto4vbZtikjS5uG13cNrq4bXRx2+jitLF3t9jo4rbRxW2ji9tm2KSNLm4bXdw2urhtdHHb6OK0sXe32OjittHFbaOL22bYpI0ubhtd3Da6uG10cdvo4rSxd7fY6OK20cVto4vbZtikjS5uG13cNrq4bXRx2+jisnmwd7fY6OK20cVto4vbZtikjS5uG13cNrq4bXRx2+jitLF3t9jo4rbRxW2ji9tm2KSNLm4bXdw2urhtdHHb6OK0sXe32OjittHFbaOL22bYpI0ubhtd3Da6uG10cdvo4rSxd7fY6OK20cVto4vbZtikjS5uG13cNrq4bXRx2+jitLF3t9jo4rbRxW2ji9tm2KSNLm4bXdw2urhtdHHb6OK0sXe32OjittHFbaOL22bYpI0ubhtd3Da6uG10cdvo4rSxd7fY6OK20cVto4vbZtikjS5uG13cNrq4bXRx2+jitLF3t9jo4rbRxW2ji9tm2KSNLm4bXdw2urhtdHHb6OK0sXe32OjittHFbaOL22bYpI0ubhtd3Da6uG10cdvo4rSxd7fY6OK20cVto4vbZtikjS5uG13cNrq4bXRx2+jisnm0d7fY6OK20cVto4vbZtikjS5uG13cNrq4bXRx2+jitLF3t9jo4rbRxW2ji9tm2KSNLm4bXdw2urhtdHHb6OK0sXe32OjittHFbaOL22bYpI0ubhtd3Da6uG10cdvo4rSxd7fY6OK20cVto4vbZtikjS5uG13cNrq4bXRx2+jitLF3t9jo4rbRxW2ji9tm2KSNLm4bXdw2urhtdHHb6OK0sXe32OjittHFbaOL22bYpI0ubhtd3Da6uG10cdvo4rSxd7fY6OK20cVto4vbZtikjS5uG13cNrq4bXRx2+jitLF3t9jo4rbRxW2ji9tm2KSNLm4bXdw2urhtdHHb6OK0sXe32OjittHFbaOL22bYpI0ubhtd3Da6uG10cdvo4rSxd7fY6OK20cVto4vbZtikjS5uG13cNrq4bXRx2+jisnmyd7fY6OK20cVto4vbZtikjS5uG13cNrq4bXRx2+jitLF3t9jo4rbRxW2ji9tm2KSNLm4bXdw2urhtdHHb6OK0sXe32OjittHFbaOL22bYpI0ubhtd3Da6uG10cdvo4rSxd7fY6OK20cVto4vbZtikjS5uG13cNrq4bXRx2+jitLF3t9jo4rbRxW2ji9tm2KSNLm4bXdw2urhtdHHb6OK0sXe32OjittHFbaOL22bYpI0ubhtd3Da6uG10cdvo4rSxd7fY6OK20cVto4vbZtikjS5uG13cNrq4bXRx2+jitLF3t9jo4rbRxW2ji9tm2KSNLm4bXdw2urhtdHHb6OK0sXe32OjittHFbaOL22bYpI0ubhtd3Da6uG10cdvo4rSxd7fY6OK20cVto4vbZtikjS5uG13cNrq4bXRx2+jisnm2d7fY6OK20cVto4vbZtikjS5uG13cNrq4bXRx2+jitLF3t9jo4rbRxW2ji9tm2KSNLm4bXdw2urhtdHHb6OK0sXe32OjittHFbaOL22bYpI0ubhtd3Da6uG10cdvo4rSxd7fY6OK20cVto4vbZtikjS5uG13cNrq4bXRx2+jitLF3t9jo4rbRxW2ji9tm2KSNLm4bXdw2urhtdHHb6OK0sXe32OjittHFbaOL22bYpI0ubhtd3Da6uG10cdvo4rSxd7fY6OK20cVto4vbZtikjS5uG13cNrq4bXRx2+jitLF3t9jo4rbRxW2ji9tm2KSNLm4bXdw2urhtdHHb6OK0sXe32OjittHFbaOL22bYpI0ubhtd3Da6uG10cdvo4rSxd7fY6OK20cVto4vbZtikjS5uG13cNrq4bXRx2+jisnmxd7fY6OK20cVto4vbZtikjS5uG13cNrq4bXRx2+jitLF3t9jo4rbRxW2ji9tm2KSNLm4bXdw2urhtdHHb6OK0sXe32OjittHFbaOL22bYpI0ubhtd3Da6uG10cdvo4rSxd7fY6OK20cVto4vbZtikjS5uG13cNrq4bXRx2+jitLF3t9jo4rbRxW2ji9tm2KSNLm4bXdw2urhtdHHb6OK0sXe32OjittHFbaOL22bYpI0ubhtd3Da6uG10cdvo4rSxd7fY6OK20cVto4vbZtikjS5uG13cNrq4bXRx2+jitLF3t9jo4rbRxW2ji9tm2KSNLm4bXdw2urhtdHHb6OK0sXe32OjittHFbaOL22bYpI0ubhtd3Da6uG10cdvo4rSxd7fY6OK20cVto4vbZtikjS5uG13cNrq4bXRx2+jisLm/s3e32OjittHFbaOL22bYpI0ubhtd3Da6uG10cdvo4rSxd7fY6OK20cVto4vbZtikjS5uG13cNrq4bXRx2+jitLF3t9jo4rbRxW2ji9tm2KSNLm4bXdw2urhtdHHb6OK0sXe32OjittHFbaOL22bYpI0ubhtd3Da6uG10cdvo4rSxd7fY6OK20cVto4vbZtikjS5uG13cNrq4bXRx2+jitLF3t9jo4rbRxW2ji9tm2KSNLm4bXdw2urhtdHHb6OK0sXe32OjittHFbaOL22bYpI0ubhtd3Da6uG10cdvo4rSxd7fY6OK20cVto4vbZtikjS5uG13cNrq4bXRx2+jitLF3t9jo4rbRxW2ji9tm2KSNLm4bXdw2urhtdHHb6OK0sXe32OjittHFbaOL22bYpI0ubhtd3Da6uG10cdvo4rK52LtbbHRx2+jittHFbTNs0kYXt40ubhtd3Da6uG10cdrYu1tsdHHb6OK20cVtM2zSRhe3jS5uG13cNrq4bXRx2ti7W2x0cdvo4rbRxW0zbNJGF7eNLm4bXdw2urhtdHHa2LtbbHRx2+jittHFbTNs0kYXt40ubhtd3Da6uG10cdrYu1tsdHHb6OK20cVtM2zSRhe3jS5uG13cNrq4bXRx2ti7W2x0cdvo4rbRxW0zbNJGF7eNLm4bXdw2H7yLH+aLzU9u/rbN9XJ9/PSZvP4p+v/b5oN38XvafPS9u3e1ebuL5/nyxeZ+t5nL5dMB5vXPIF+Oe/fjh7j+6z/Em5V2ub8+fPqqvf7F//PD/kFeb375fOuHxy83vn/jxi8vL59/Et7dXeann9JbX7R5+MlX7SefyecTzM/+BG8Xz/Xl02/A6/3Tly/zw6e3ersFZj7dcVwfrs//+FZv30s+PX7+LfV898ZbvX3/8XJ39/m79fLw07d66x7t/tO39uXp8pPv1euPH+LlX/4h3l4pun95+fwdcvd09CEuzw8vnz7G5fn5y8+zh7d+p7z+DLl++vSfLpev3AgPl8+/Zx/u5x9/Qr29PHTi815v7Lz3N3beubHzPpzrvP/cn2mun+/IXrvt6Q2dRzqLzhOdReeZzqLzQqd1nk9WkV9Z52TN+ZV1TlaoX1nnZD37lXWGzqKjlTcdrbzpaOVNRytvOlp50Xm57VZ+/vS4/+X18e03dG67lY90tPL2naWVN52hs+ho5U1HK286WnnT0cqbjlZuneudx5U3HY8rbzpaedO56VY+eB7j9W7oLDo33cqHOjfdyoc6J2vlp/n8iM3TvPVz9mT1e3jek/Xs0XkvJyvUw/OerDkPz3uyijw878m68PC8c2PnPVm7HZ73ZDX2/Pj5U3l+eXzjvCfrq8PznqyvDs97sr46Ou/1ZH11eN6T9dXheU/WV4fnPVlfvVw+Pzrwcv/8xnnnxs57sr46PO/J+urwvCfrq8PznqyvDs97sr46Ou/9yfrq8Lwn66vD856srw7Pe1uv/77en6yvDs97sr46PO/J+urwvCfrq8PznqyvDs/r+W4/3PrNZ+WM57ttOp7vtul4vtum47Uhm87QWXRu+7Uh+2vSrnPbrw050rnt14Yc6dz2a0OOdG67lQ90HryOetPxOupN57Zb+UhHKy81+KCVNx2vo950vI560/E66k3H66g3HY8rLzqPWnnpnUetvOlo5U3ntlv5SGfoLDoeV950PK686XhcedPRylsNauVF52yLSF9Zx3MwNh3Pwdh0PK686QydRUcrL71z47tPRzpaedPxHIxNRysvP5Vve/fp6Fpnt737dKhz0618qOP6nJvO0Fl0buwaBGdbcjo8741dQ/Nsa0uH572xa2iebRHp8Lw3dg3Ns60WHZ73xq6hebZlocPznqyvjq5Zdrb1n8Pz3tg1NM+20HN43tu6hub92VZ0Ds97W9fQvD/b0s3heU/WV4fnnZt6fOP+bPsyh+e9rcev7s+2AXN43tu6hub92TZgjs57tg2Yw/Pe1jU07z/+BszDfDnv4/PBea+vf5f/482vl3n4u/O+8d4PngNw//EXY95VZ+gsOh++9N5V58N34bvqfPiKfFedD9+c/1Kd/Vl99x9/Rec9dT7+5s676nz4+n1Xndtu5SOd227lI51xj9736B9/WehddbTypqOVN53bbuUjndtu5QOdj7+f9K46WnnpnY+/zfSuOlp50xk6i85tt/KRzm238pGOVt7u0bXypqOVF52Pv271rjq33cpHOlp5uc/6+OtW76ozdBYdrbzpaOVN57Zb+Ujnplv54CoV9x9/3eo9dT7+utW76tx0Kx/q3HQrH+p8lVZ+uX7Webl/OdB5+vRnm7n/YnN5fbMfPqH5Cp/Qy3z5cr385EVkb35Cl5eHly9PeX+8fHnvj29/AebhJ1+B57+7+Q9HePj5H+Hx53+Ep//5Izxd7z4f4fnpfj/Cy8PD5/d9ff7Jd8Knb803g2leb/vpANe7x3f9wfXPvbDk4XL5fPP7eeNH0cttnfftGaITn/dyY+e9nuu8X/ViqfdvTwXR+VFn6Cw6D3QWnUc6i84TnUXnZM35lXVOVqhfV+fpZD37lXVOVr9fWUcrbzpaedMZOouOVt50tPKmc9utfPAX2k+33cpHOlp5+c561sqbjlbedLTypqOVN52hs+ho5U1HK286HlfedDyuvOlo5UXn5aZb+egJfC833cqHOjfdyoc6J2vlg6mi+5eT1e/heU/Ws4fnPVmhHp73ZM15eN6TVeTheU/WhQfnnbuTld7heU/WbofnPVmNHUwVzd3J+urwvHNj5z1ZXx2e92R9dXjek/XV4XlP1leH5z1ZXx1M98zlZH11eN6T9dXheU/WV4fnPVlfHZ53buy8J+urw/OerK8Oz3uyvjp4RehcbusV3XO5rVd0z/W2XtE919t6RfdcT9ZXh+f1XLofbv3W8xLmerIa+8o6nku36Xgu3abjuXSbjufSbTq3/Vy6/VU5c3/brzs50rnt150c6dz2606OdG67lY90hs6ic9utfKRz2618pKOVlxq818qbjtedLDrjNdqbjtdobzpeo73peFx50xm9070zWnnT0cqbjusZbTquZ7TpeFx50XnwuPKm43HlTUcrLzX4oJU3naGz6HgOxqbjORibjseVNx2PK286WnnpnbPtPn1lHa286XgOxqajlZefyre9KXVwLay57U2pQ52bbuVDnZtu5UOdm27lQ50buwbB2VaiDs97Y9d4OtuS0+F5b+samnO2taXD897WNTTnbItIh+e9rWtoztlWiw7Pe7K+Orqm1dmWhQ7Pe7K+OjzvjV1D82x7PofnnRs7741dQ/NsKzqH572xa2iebenm6PGNs23XHJ33bGs0h+e9sWtonm0x5vC8N3YNzbNtwBye98auofnxN2Ae5st5H58Pznt9/bv8H29+vczD3533jfd+9ByAj78Y8646H77d3lXnw5feO+o8fPztmnfV+fAV+a46H745/6U6+7P6Hj7+is676gydRefD1++76tx2Kx/p3HYrH+lo5e0eXSsvOh9/h+hddbTypnPbrXykc9utfKQzdBYdrbz0zsffZnpXHa286dx2Kx/p3HYrH+h8/E2pd9XRyss9+sffq3pXHa286QydRee2W/lIRytv91laedPRypuOVl50Pv661bvq3HYrH+ncdCvf71epePj461bvqjN0Fp2bbuVDnZtu5UOdr9LKL9fPOi/3Lwc6T5/f9f0Xm8vrm/3wCX2NPH2ZL1+ul5+8iOzNT+jy8vDy5Snvj5cvpo9vfwHm4Sdfgee/u/kPR3j52R/hq0wzvfMRLj//I1x//ke4/58/wtP17vMRnp/u9yO8PDx8ft/X55/8PHr9Afn6q1/98dvf/e7b//z3333361/++dvvfv+n79/07vt/vL2T8/qHgB/f3cPT43//6fb2eMz+Jk///Js8//Nv8vJPvsnrry7f3zL+aunp0/3B43X+G+nrL//PL//47S9/9bvffm/5/f/9y+9//Yn29Zd//r9/+PR/PuH/4Y/f/fq3v/nLH3/7/Zfhy1fg+99ar/e0c309wX894+nh8ouHxy+f2/f/6Xr5xfX1P/3t9SP/Pw==","names":["verify_zkID"],"brillig_names":["store_in_execution_cache_oracle_wrapper","notify_enqueued_public_function_call_wrapper","directive_invert","directive_integer_quotient"]},{"name":"constructor","hash":"2844858595090350811","is_unconstrained":true,"custom_attributes":["public","initializer"],"abi":{"parameters":[{"name":"admin","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"}],"return_type":null,"error_types":{"2233873454491509486":{"error_kind":"string","string":"Initializer address is not the contract deployer"},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"14225679739041873922":{"error_kind":"string","string":"Index out of bounds"},"17618083556256589634":{"error_kind":"string","string":"Initialization hash does not match"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"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","names":["constructor"],"brillig_names":["constructor"]},{"name":"is_valid_address","hash":"1672689428884046998","is_unconstrained":true,"custom_attributes":["public","view"],"abi":{"parameters":[{"name":"address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"}],"return_type":{"abi_type":{"kind":"boolean"},"visibility":"public"},"error_types":{"72026683357237545":{"error_kind":"string","string":"Function is_valid_address can only be called statically"},"206160798890201757":{"error_kind":"string","string":"Storage slot 0 not allowed. Storage slots must start from 1."},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"13699457482007836410":{"error_kind":"string","string":"Not initialized"},"14225679739041873922":{"error_kind":"string","string":"Index out of bounds"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"7Z3fbuo4EMbfhWsu7PHf6ascrSraciokBBWlK62qvvsmXZwExknWY3alKnNTnRzmI+OfJ+43ocSfq5ft08fr4+7w+/i+evj1udofnzfn3fHQHH1+rVdPp91+v3t9HP73SrU/QH3Hv79tDu3h+3lzOq8etAGn1qvt4aX9t4mueY/fu/129YD+a03DFUCKVhb6YJMJtt7rS7D1QXXBXmeCo1PuEhwd6GHwH+sV6Lskj5iitcb/L3m4S/IuduTjDHntQkjB3pjp5NFhGil6Y2+TN3dOXsNV8u0p7H9/Cpc9BTSTlUTgrJk+RWgK6BIdmvAZquDTlYIQ3S1V/2/yuRpyqwosVWSpkKMy2UUmYjeTEUO41WiGBhiafCV7NGlAYTCpTmWLzJt+BenLRTuXvQr9JRhUX5BGh1xtoU0rSEDs3xliLg8T0jjt4IKFXCiATm8MMFgKssHOpmXD2TgMbfFZwVeDzwm+Gnxe8NXgC4KvBl8UfDX4UPBV4LNK8NXg04KvBh8Ivhp80nVU4bOCrwafdB2z+GK6oeEGt9Uu+KTrqMInXUcVPuk65vD5LtZfh7b4pOuoweek66jCJ11HFT7pOqrwSddRhc8Kvhp80nVU4ZOuowqfdB1V+KTrqMInXUcNPi9dRxU+6Tqq8EnXQZlIK0GZWGFCmIjpp0zEyVMmYs8pE/HclIkYacIkiDumTMTyUibiYykT8bGUiRUmhIn4WMpEfCxlIj6WMhEfS5mIjyVM4jJ9rNEpZTDgb5ks08dOM1mmj51mskwfO83EChPCZJk+dprJMn3sNJNl+thpJsv0sdNMluljJ5mg+FjKRHwsZSI+ljIRH0uZWGFCmIiPpUzEx1Im4mMpE/GxlIn4WMJEKzGyGSjLdLLBplgIjh/8TXCZvreEoPbRdjAUEILLdMn3JGiFYCXBZTrwexJcpl8vIhiwe2Rx1PR38TLd/T0JLrMXuCfBZXYOdySol9lm3JOg9CS1BKUnqSUoPUktQSsEKwlKT1JLUHqSWoLSk9QSlJ6klqD0JJUEQXqSWoLSk9QSlJ5kliCabnxoKUHpSWoJ2nqCOnZ7sMFgb7A8QecwJe8j9Mkj5hB2u/GF0D/kXHv7T+7uB+fuf3Du4QfnPu89Dc7l3l3XTTOgrk6RScd1nxEFr/qRZrcPDCamPIIdbGeYDW5Wq+C7RKzCYfj3WPMusVkyurF6MxxrK8rvsTcnsgzRyJO6Vbe4NR9e4O16NfJ86hlR3qroPr2mYokIOCLDEVmOKL/46diVBCgKIl/9tt/dcVh1SYQM0cgT/WZEmiMCjshwRJYjys+Ts93kuqCJyHNEgSOKHBEyRCNPsZkRaY4oXxGuX+O9NkRkOCLLETmOyHNEgSOKHBEyRCPffTa9YTWOXE8jXw6eERmOyHJEjiPyHFHgiCJHhAzRyJekZkScikBORYx8D8X4zpaaSBaWkS9qzIgcR+Q5osARRY4Iy0WgGJYAlOaIgCMyHFEWRGP0O8t/+9exkP8kGru7EBg8kZhyiS2XuHKJL3fjMPIByowockSMDgNAcUSaIwKOyHBEliNyHBGnIoBTEcCpCOBUhOFUhOFURH6z+snlJN96I6RbFGippPxCz2+FPH0WLJbkt7ydluhySfkCbMsXYFu+AOe3bcSYZv/qJvJF4ssloVwSZ8aSkWDx8PO3dqYlulxSPvuufPZd+ey78qsyv2XMtCSUS2K5pHD2v5qjPzen3eZpv31vFO2LH4fn8+54uBye/3pLrzyddvv97vXx7XR83r58nLaP++Nz+9pKXX78Ao9rQNVa1fawMaZrbXV72BYMoG5eNc1ZmzP/DQ==","names":["is_valid_address"],"brillig_names":["is_valid_address"]},{"name":"remove_zkID_with_address","hash":"4533360410998630216","is_unconstrained":true,"custom_attributes":["public"],"abi":{"parameters":[],"return_type":null,"error_types":{"206160798890201757":{"error_kind":"string","string":"Storage slot 0 not allowed. Storage slots must start from 1."},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"12749937572827500595":{"error_kind":"string","string":"No zkID found for address"},"13699457482007836410":{"error_kind":"string","string":"Not initialized"},"14225679739041873922":{"error_kind":"string","string":"Index out of bounds"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"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","names":["remove_zkID_with_address"],"brillig_names":["remove_zkID_with_address"]},{"name":"sync_notes","hash":"11930536392875853495","is_unconstrained":true,"custom_attributes":["aztec::macros::functions::utility"],"abi":{"parameters":[],"return_type":null,"error_types":{"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"H4sIAAAAAAAA/7WTPQ+CMBCGi2KUjzjgoD+jBAyM+LG4OLpXCkpUSAB3frqQXENtwKjAJU17FJ5736OVUB0SzDLqEAyyglmBecTtj8vhQY67hakIdfvku9i2lQZ/Peq3FGBKw/Ax4w/UfzwFzr6o+bwXVndWDo1b66g+H0P5Z/9vSP+LD5418GpAXnmew/oS5Nt74t+Oz8c5SNnXTR1EgnIxdK5CSd0lcZ4SP99QmgZZJhJGDWTUQlU56pVE8YG26fmRdgrSLEpikSZ/Sav6yu6lXLyr8eA57hCOizHTMAb+BDV3X+b2+feXkKuCJ+bT+1Nn6BAztEhI1oRS2yeGwK+CP38vlizs4eEFAAA=","debug_symbols":"rZLNqoMwEEbfJWsX+c/EVymXEjWWQIgS9UIR372xxCK1tBs3QyYchpPMN6PGVtPt6kLbDai8zMh3tRldF1I3LwWqovPe3a77a4TXQtiTH3oT1nYYTRxRSTAnUCAbmudZqTSjdd6iUsulOOAKZIYB8xcq2QdUUJFRIfALJQyWvwIRfoIMMLXJCP1dhjOdUS7hICPOkAG+yWj4LiPx9jOSyoOMPEFGU5phzcQPGcAZVfhtTUtq/010pvI2x6udQr1L23jv7Vvw+tjVtpmiXSO4S1+ql/QEytLYNPoB","names":["sync_notes"],"brillig_names":["sync_notes"]},{"name":"_remove_zkID","hash":"3981875364831667784","is_unconstrained":true,"custom_attributes":["public","internal"],"abi":{"parameters":[{"name":"zk_id","type":{"kind":"field"},"visibility":"private"},{"name":"address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"}],"return_type":null,"error_types":{"206160798890201757":{"error_kind":"string","string":"Storage slot 0 not allowed. Storage slots must start from 1."},"3842422468523945747":{"error_kind":"string","string":"Function _remove_zkID can only be called internally"},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"13699457482007836410":{"error_kind":"string","string":"Not initialized"},"14225679739041873922":{"error_kind":"string","string":"Index out of bounds"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"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","names":["_remove_zkID"],"brillig_names":["_remove_zkID"]},{"name":"get_address_from_zkID","hash":"4808789401342975368","is_unconstrained":true,"custom_attributes":["public","view"],"abi":{"parameters":[{"name":"zkID","type":{"kind":"field"},"visibility":"private"}],"return_type":{"abi_type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"public"},"error_types":{"206160798890201757":{"error_kind":"string","string":"Storage slot 0 not allowed. Storage slots must start from 1."},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"13699457482007836410":{"error_kind":"string","string":"Not initialized"},"14225679739041873922":{"error_kind":"string","string":"Index out of bounds"},"15100788409809688557":{"error_kind":"string","string":"Function get_address_from_zkID can only be called statically"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"7Z3dbqM8EIbvheMe4PH4r7ey+lSlbbaKFCVVmn7Squq9L+zGQDIG1mN2pYo5qUozbzw8ttE7LuCP6nn7+P7ysDt8P75V998+qv3xaXPeHQ/N0cfnXfV42u33u5eH4Z+ruv0B9a/4t9fNoT18O29O5+peaTD1XbU9PLe/a2+a7/i+22+r+2A/72h4DRCja4Q+WCeC0Vp1CUbr6i7YqkSwN7W5BHsDahj8310FapHkQ4jRSoV/lzwskrzxHXk/Q14Z52Kw1Xo6+WBCPNNgNd4mrxdOXsFV8m0T+PebMMkmoOmsKAKDeroJ1wygS7Rrwmeogo0zJYA3t1Ttn+RzdcqtyrFUnqUKHJVOX2SC6oZjwH7imTrZkVb3s7TvEmVMcqTbSzDUfadr5VL9FzDOUhdC/83gU3loF0cfDiYFpEIBVPxigMF0SwYbjCwM+mFoi08JvhJ8IPhK8GnBV4IPBV8JPiP4SvBZwVeCzwm+Enxe8JXgC4KvAB9K1VGET6qOInxSdczi83HRwAyWri74pOoowoeCrwSfVB1z+GwXa69DW3xSdRThk6qjCJ9UHUX4pOoowWek6ijCJ1VHET6pOorwSdVRhA8FXwk+qTqK8EnVUYRPqo4ifFJ1FOGTqoMwsVJKUCZSH1AmYvopE3HylAkKE8JEPDdlIkaaMhF3TJmI5aVMxMcSJk58LGUiPpYyER9LmYiPpUxQmBAm4mMpE/GxlMk6faxWMWXQYG+ZrNPHTjNZp4+dZOLX6WOnmazTx04zWaePnWayTh87zQSFCWGyTh87zWSdPnaaifhYykR8LGUiPpYwCeJjKRPxsZSJ+FjKRHwsZYLChDARH0uZiI+lTMTHUibr9LEOYyw4ww9uAa7T9OYAVNZjPD9X3z7/rep1WuQlCa7TUC9JcJ32e0mC6zTrWQRd6GB4ZQlBFIKFBNdZCCxJcJ1lw5IE11lkLElQSpJSglKTFBJUUpOUEpSapJSg1CSlBKUmmSUYtO5hUIIoBAsJLlCTKN9trAKDDT/SBI0JMXnroU8+hBTCbosd5/q3qiqLv3O3Xzh394Vz918493nvaeu53Lt53XRjfdVEIh3TrUs5W8/sCeS0j5PV4WCPomRwc7VytksE6zAMb891ZL+Jurt6NLVMuL0gjOyyMCNKz0RlsAdFluRG3qg/I/IcUWCIRt4ZrnzHHGoCYuRdxdjviTTs1ihCjshwRJYjchyR54gCQzTylkWDXecap4hIcUTAEWmOCDkiwxFZjig9IkzonIZVmog8RxQYopGX5cyIFEcEHJHmiJAjSneu7h2hNmQ+jbzeYEbkOaLAEI08QT4jUhwRcESaI0KOyHBEnBHhOCNi5Ek6bTvfpz25sIw8ajYtGnkWa0akOCLgiDRHhBwRxxJ4jiXwHEvgOZYgfUNh46Q7T41EkkwudGV+cKQKTt9mNC0JuRJI30kyLVH5bhxG7haYEWmOCDkiwxFZjshxRJ4jCgzRyCr+jIgzIhRnRCjOiFCcEaE4I0JxRkR66WLqcgLpFYMAcQ0gIJFA/kRP76I83QrmS0y+xOZLXP7p+3xJ/gU4vflw8LH3r1ZpLxKVL4F8iZ45l4QE80/f5EtsviS/93V+7+v83sf8WZne+GxaAvkSnS/J7P3P5uj/zWm3edxv3xpF++H74em8Ox4uh+cfr/GTx9Nuv9+9PLyejk/b5/fT9mF/fGo/q+rLj2/QLJ01/3tojVB7qBoPp8C2hy0xaNYlwfmm1ablnw==","names":["get_address_from_zkID"],"brillig_names":["get_address_from_zkID"]}],"outputs":{"structs":{"functions":[{"kind":"struct","path":"IdentityRegistry::constructor_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"IdentityRegistry::constructor_parameters","fields":[{"name":"admin","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}}]},{"kind":"struct","path":"IdentityRegistry::_add_zkID_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"IdentityRegistry::_add_zkID_parameters","fields":[{"name":"zk_id","type":{"kind":"field"}},{"name":"address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}}]},{"kind":"struct","path":"IdentityRegistry::get_zkID_from_address_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"IdentityRegistry::get_zkID_from_address_parameters","fields":[{"name":"address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}},{"name":"return_type","type":{"kind":"field"}}]},{"kind":"struct","path":"IdentityRegistry::verify_zkID_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"IdentityRegistry::verify_zkID_parameters","fields":[{"name":"circuitInputs","type":{"kind":"struct","path":"types::SubProofInputs","fields":[{"name":"vkeys","type":{"kind":"struct","path":"types::Vkeys","fields":[{"name":"vkey_a","type":{"kind":"array","length":128,"type":{"kind":"field"}}},{"name":"vkey_b","type":{"kind":"array","length":128,"type":{"kind":"field"}}},{"name":"vkey_c","type":{"kind":"array","length":128,"type":{"kind":"field"}}},{"name":"vkey_d","type":{"kind":"array","length":128,"type":{"kind":"field"}}}]}},{"name":"proofs","type":{"kind":"struct","path":"types::Proofs","fields":[{"name":"proof_a","type":{"kind":"array","length":459,"type":{"kind":"field"}}},{"name":"proof_b","type":{"kind":"array","length":459,"type":{"kind":"field"}}},{"name":"proof_c","type":{"kind":"array","length":459,"type":{"kind":"field"}}},{"name":"proof_d","type":{"kind":"array","length":459,"type":{"kind":"field"}}}]}},{"name":"public_inputs","type":{"kind":"struct","path":"types::PubInputs","fields":[{"name":"input_a","type":{"kind":"array","length":2,"type":{"kind":"field"}}},{"name":"input_b","type":{"kind":"array","length":2,"type":{"kind":"field"}}},{"name":"input_c","type":{"kind":"array","length":2,"type":{"kind":"field"}}},{"name":"input_d","type":{"kind":"array","length":2,"type":{"kind":"field"}}}]}}]}},{"name":"zk_id","type":{"kind":"field"}},{"name":"add_zkID","type":{"kind":"boolean"}},{"name":"remove_zkID","type":{"kind":"boolean"}}]}}]},{"kind":"struct","path":"IdentityRegistry::remove_zkID_with_address_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"IdentityRegistry::remove_zkID_with_address_parameters","fields":[]}}]},{"kind":"struct","path":"IdentityRegistry::_remove_zkID_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"IdentityRegistry::_remove_zkID_parameters","fields":[{"name":"zk_id","type":{"kind":"field"}},{"name":"address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}}]},{"kind":"struct","path":"IdentityRegistry::is_valid_address_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"IdentityRegistry::is_valid_address_parameters","fields":[{"name":"address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}},{"name":"return_type","type":{"kind":"boolean"}}]},{"kind":"struct","path":"IdentityRegistry::is_valid_zkID_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"IdentityRegistry::is_valid_zkID_parameters","fields":[{"name":"zkID","type":{"kind":"field"}}]}},{"name":"return_type","type":{"kind":"boolean"}}]},{"kind":"struct","path":"IdentityRegistry::get_address_from_zkID_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"IdentityRegistry::get_address_from_zkID_parameters","fields":[{"name":"zkID","type":{"kind":"field"}}]}},{"name":"return_type","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}]},"globals":{"storage":[{"kind":"struct","fields":[{"name":"contract_name","value":{"kind":"string","value":"IdentityRegistry"}},{"name":"fields","value":{"kind":"struct","fields":[{"name":"admin","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}}]}},{"name":"zkPassportIDtoAddress","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000002"}}]}},{"name":"addressToZKPassportID","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000003"}}]}}]}}]}]}},"file_map":{"20":{"source":"use crate::default::Default;\nuse crate::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub(crate) struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub(crate) fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub(crate) struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n","path":"std/hash/poseidon2.nr"},"22":{"source":"pub mod hash;\npub mod aes128;\npub mod array;\npub mod slice;\npub mod ecdsa_secp256k1;\npub mod ecdsa_secp256r1;\npub mod embedded_curve_ops;\npub mod field;\npub mod collections;\npub mod compat;\npub mod convert;\npub mod option;\npub mod string;\npub mod test;\npub mod cmp;\npub mod ops;\npub mod default;\npub mod prelude;\npub mod runtime;\npub mod meta;\npub mod append;\npub mod mem;\npub mod panic;\npub mod hint;\n\nuse convert::AsPrimitive;\n\n// Oracle calls are required to be wrapped in an unconstrained function\n// Thus, the only argument to the `println` oracle is expected to always be an ident\n#[oracle(print)]\nunconstrained fn print_oracle<T>(with_newline: bool, input: T) {}\n\nunconstrained fn print_unconstrained<T>(with_newline: bool, input: T) {\n    print_oracle(with_newline, input);\n}\n\npub fn println<T>(input: T) {\n    // Safety: a print statement cannot be constrained\n    unsafe {\n        print_unconstrained(true, input);\n    }\n}\n\npub fn print<T>(input: T) {\n    // Safety: a print statement cannot be constrained\n    unsafe {\n        print_unconstrained(false, input);\n    }\n}\n\npub fn verify_proof<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n) {\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, 0);\n}\n\npub fn verify_proof_with_type<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {\n    if !crate::runtime::is_unconstrained() {\n        crate::assert_constant(proof_type);\n    }\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, proof_type);\n}\n\n#[foreign(recursive_aggregation)]\nfn verify_proof_internal<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {}\n\n// Asserts that the given value is known at compile-time.\n// Useful for debugging for-loop bounds.\n#[builtin(assert_constant)]\npub fn assert_constant<T>(x: T) {}\n\n// Asserts that the given value is both true and known at compile-time\n#[builtin(static_assert)]\npub fn static_assert<let N: u32>(predicate: bool, message: str<N>) {}\n\npub fn wrapping_add<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() + y.as_())\n}\n\npub fn wrapping_sub<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    //340282366920938463463374607431768211456 is 2^128, it is used to avoid underflow\n    AsPrimitive::as_(x.as_() + 340282366920938463463374607431768211456 - y.as_())\n}\n\npub fn wrapping_mul<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() * y.as_())\n}\n\n#[builtin(as_witness)]\npub fn as_witness(x: Field) {}\n\nmod tests {\n    use super::wrapping_mul;\n\n    #[test(should_fail_with = \"custom message\")]\n    fn test_static_assert_custom_message() {\n        super::static_assert(1 == 2, \"custom message\");\n    }\n\n    #[test(should_fail)]\n    fn test_wrapping_mul() {\n        // This currently fails.\n        // See: https://github.com/noir-lang/noir/issues/7528\n        let zero: u128 = 0;\n        let one: u128 = 1;\n        let two_pow_64: u128 = 0x10000000000000000;\n        let u128_max: u128 = 0xffffffffffffffffffffffffffffffff;\n\n        // 1*0==0\n        assert_eq(zero, wrapping_mul(zero, one));\n\n        // 0*1==0\n        assert_eq(zero, wrapping_mul(one, zero));\n\n        // 1*1==1\n        assert_eq(one, wrapping_mul(one, one));\n\n        // 0 * ( 1 << 64 ) ==  0\n        assert_eq(zero, wrapping_mul(zero, two_pow_64));\n\n        // ( 1 << 64 ) * 0 == 0\n        assert_eq(zero, wrapping_mul(two_pow_64, zero));\n\n        // 1 * ( 1 << 64 ) == 1 << 64\n        assert_eq(two_pow_64, wrapping_mul(two_pow_64, one));\n\n        // ( 1 << 64 ) * 1 == 1 << 64\n        assert_eq(two_pow_64, wrapping_mul(one, two_pow_64));\n\n        // ( 1 << 64 ) * ( 1 << 64 ) == 1 << 64\n        assert_eq(zero, wrapping_mul(two_pow_64, two_pow_64));\n        // -1 * -1 == 1\n        assert_eq(one, wrapping_mul(u128_max, u128_max));\n    }\n}\n","path":"std/lib.nr"},"42":{"source":"use crate::cmp::{Eq, Ord, Ordering};\nuse crate::default::Default;\nuse crate::hash::{Hash, Hasher};\n\npub struct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::mem::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default\n        }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    pub fn expect<let N: u32, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            other\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            default()\n        }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some {\n                Option::none()\n            } else {\n                self\n            }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n\nimpl<T> Default for Option<T> {\n    fn default() -> Self {\n        Option::none()\n    }\n}\n\nimpl<T> Eq for Option<T>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: Self) -> bool {\n        if self._is_some == other._is_some {\n            if self._is_some {\n                self._value == other._value\n            } else {\n                true\n            }\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T> Hash for Option<T>\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self._is_some.hash(state);\n        if self._is_some {\n            self._value.hash(state);\n        }\n    }\n}\n\n// For this impl we're declaring Option::none < Option::some\nimpl<T> Ord for Option<T>\nwhere\n    T: Ord,\n{\n    fn cmp(self, other: Self) -> Ordering {\n        if self._is_some {\n            if other._is_some {\n                self._value.cmp(other._value)\n            } else {\n                Ordering::greater()\n            }\n        } else if other._is_some {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n","path":"std/option.nr"},"43":{"source":"pub fn panic<T, U, let N: u32>(message: fmtstr<N, T>) -> U {\n    assert(false, message);\n    crate::mem::zeroed()\n}\n","path":"std/panic.nr"},"50":{"source":"mod types;\n\nuse dep::aztec::macros::aztec;\n\n//This is the identity registry contract.\n//has a 1:1 mapping between a zkpassportID and a user address.\n//should be able to be linked, unlinked, needs to verfiy the proof in the function\n\n#[aztec]\ncontract IdentityRegistry {\n    use dep::aztec::{\n        prelude::{AztecAddress, Map, PublicMutable, SharedMutable},\n        macros::{functions::{initializer, internal, private, public, view}, storage::storage},\n        protocol_types::{abis::function_selector::FunctionSelector, traits::{Deserialize, Serialize, FromField, ToField}},\n    };\n    use std::{verify_proof_with_type};\n    use crate::types::{SubProofInputs};\n    global ZERO_ADDRESS: AztecAddress = AztecAddress::from_field(\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n    );\n    global HONK_IDENTIFIER: u32 = 1;\n    global KEY_HASH: Field = 0;\n\n   \n\n    #[storage]\n    struct Storage<Context> {\n        admin: PublicMutable<AztecAddress, Context>,\n        zkPassportIDtoAddress: Map<Field, PublicMutable<AztecAddress, Context>, Context>,\n        addressToZKPassportID: Map<AztecAddress, PublicMutable<Field, Context>, Context>,\n    }\n\n    #[public]\n    #[initializer]\n    fn constructor(admin: AztecAddress) {\n        storage.admin.write(admin);\n    }\n\n    #[public]\n    #[view]\n    fn is_valid_zkID(zkID: Field) -> bool {\n        let mut truth = false;\n        let address = storage.zkPassportIDtoAddress.at(zkID).read();\n        if address != ZERO_ADDRESS {\n            truth = true;\n        }\n        truth\n    }\n    \n\n    #[public]\n    #[view]\n    fn is_valid_address(address: AztecAddress) -> bool {\n        let mut truth = false;\n        let zkID = storage.addressToZKPassportID.at(address).read();\n        if zkID != 0 {\n            truth = true;\n        }\n        truth\n    }\n\n    #[public]\n    #[view]\n    fn get_address_from_zkID(zkID: Field) -> AztecAddress {\n        storage.zkPassportIDtoAddress.at(zkID).read()\n    }\n\n    #[public]\n    #[view]\n    fn get_zkID_from_address(address: AztecAddress) -> Field {\n        storage.addressToZKPassportID.at(address).read()\n    }\n\n    #[private]\n    fn verify_zkID(\n        circuitInputs: SubProofInputs,\n        zk_id: Field,\n        add_zkID: bool,\n        remove_zkID: bool,\n    ) {\n        assert(circuitInputs.public_inputs.input_a[1] == circuitInputs.public_inputs.input_b[0], \"comm_out of proof_a does not match comm_in of proof_b\");\n        assert(circuitInputs.public_inputs.input_b[1] == circuitInputs.public_inputs.input_c[0], \"comm_out of proof_c does not match comm_in of proof_d\");\n        // assert(circuitInputs.public_inputs.input_c[1] == circuitInputs.public_inputs.input_d[0], \"comm_out of proof_d does not match comm_in of proof_c\");\n        assert(circuitInputs.public_inputs.input_d[1] == zk_id, \"scoped nullifier of proof_d does not match zk_id\");\n        // Verify all proofs\n        verify_proof_with_type(\n            circuitInputs.vkeys.vkey_a,\n            circuitInputs.proofs.proof_a,\n            circuitInputs.public_inputs.input_a,\n            KEY_HASH,\n            HONK_IDENTIFIER,\n        );\n\n        // verify_proof_with_type(\n        //     circuitInputs.vkeys.vkey_b,\n        //     circuitInputs.proofs.proof_b,\n        //     circuitInputs.public_inputs.input_b,\n        //     KEY_HASH,\n        //     HONK_IDENTIFIER,\n        // );\n        // verify_proof_with_type(\n        //     circuitInputs.vkeys.vkey_c,\n        //     circuitInputs.proofs.proof_c,\n        //     circuitInputs.public_inputs.input_c,\n        //     KEY_HASH,\n        //     HONK_IDENTIFIER,\n        // );\n        // verify_proof_with_type(\n        //     circuitInputs.vkeys.vkey_d,\n        //     circuitInputs.proofs.proof_d,\n        //     circuitInputs.public_inputs.input_d,\n        //     KEY_HASH,\n        //     HONK_IDENTIFIER,\n        // );\n        \n        // Add the zkID to storage\n        let address = context.msg_sender();\n\n        if remove_zkID & !add_zkID {\n            IdentityRegistry::at(context.this_address())._remove_zkID(zk_id, address).enqueue(&mut context);\n        }\n        else {\n            IdentityRegistry::at(context.this_address())._add_zkID(zk_id, address).enqueue(&mut context);\n        }\n    }\n\n\n    #[public]\n    #[internal]\n    fn _add_zkID(zk_id: Field, address: AztecAddress) {\n        storage.zkPassportIDtoAddress.at(zk_id).write(address);\n        storage.addressToZKPassportID.at(address).write(zk_id);\n    }\n\n    #[public]\n    #[internal]\n    fn _remove_zkID(zk_id: Field, address: AztecAddress) {\n        storage.zkPassportIDtoAddress.at(zk_id).write(ZERO_ADDRESS);\n        storage.addressToZKPassportID.at(address).write(0);\n    }\n\n    #[public]\n    fn remove_zkID_with_address() {\n        let address = context.msg_sender();\n        let passport_id = storage.addressToZKPassportID.at(address).read();\n        if passport_id != 0 {\n            storage.zkPassportIDtoAddress.at(passport_id).write(ZERO_ADDRESS);\n            storage.addressToZKPassportID.at(address).write(0);\n        }\n        else {\n            assert(false, \"No zkID found for address\");\n        }\n    }\n\n}\n\n","path":"/Users/niallcheetham/Dev/obsidion/idenityRegistryDemo/identityRegistry/src/main.nr"},"53":{"source":"use dep::protocol_types::{\n    abis::function_selector::FunctionSelector,\n    address::AztecAddress,\n    traits::{Deserialize, ToField},\n};\n\nuse crate::context::{gas::GasOpts, private_context::PrivateContext, public_context::PublicContext};\n\nuse crate::hash::{hash_args, hash_calldata};\nuse crate::oracle::execution_cache;\n\npub trait CallInterface<let N: u32> {\n    fn get_args(self) -> [Field];\n    fn get_selector(self) -> FunctionSelector;\n    fn get_name(self) -> str<N>;\n    fn get_contract_address(self) -> AztecAddress;\n    fn get_is_static(self) -> bool;\n}\n\n// PrivateCallInterface\n\npub struct PrivateCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let N: u32, T> PrivateCallInterface<N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self {\n            target_contract,\n            selector,\n            name,\n            args_hash,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static,\n        }\n    }\n\n    pub fn call<let M: u32>(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        execution_cache::store(self.args, self.args_hash);\n        let returns_hash = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            false,\n        );\n        let returns: T = returns_hash.get_preimage();\n        returns\n    }\n\n    pub fn view<let M: u32>(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        execution_cache::store(self.args, self.args_hash);\n        let returns_hash = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            true,\n        );\n        returns_hash.get_preimage()\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PrivateCallInterface<N, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PrivateVoidCallInterface\n\npub struct PrivateVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\n    is_static: bool,\n}\n\nimpl<let N: u32> PrivateVoidCallInterface<N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self { target_contract, selector, name, args_hash, args, return_type: (), is_static }\n    }\n\n    pub fn call(self, context: &mut PrivateContext) {\n        execution_cache::store(self.args, self.args_hash);\n        context\n            .call_private_function_with_args_hash(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                false,\n            )\n            .assert_empty();\n    }\n\n    pub fn view(self, context: &mut PrivateContext) {\n        execution_cache::store(self.args, self.args_hash);\n        context\n            .call_private_function_with_args_hash(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                true,\n            )\n            .assert_empty();\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PrivateVoidCallInterface<N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PrivateStaticCallInterface\n\npub struct PrivateStaticCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let N: u32, T> PrivateStaticCallInterface<N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self {\n            target_contract,\n            selector,\n            name,\n            args_hash,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static: true,\n        }\n    }\n\n    pub fn view<let M: u32>(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        execution_cache::store(self.args, self.args_hash);\n        let returns = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            true,\n        );\n        returns.get_preimage()\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PrivateStaticCallInterface<N, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PrivateStaticVoidCallInterface\n\npub struct PrivateStaticVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\n    is_static: bool,\n}\n\nimpl<let N: u32> PrivateStaticVoidCallInterface<N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self { target_contract, selector, name, args_hash, args, return_type: (), is_static: true }\n    }\n\n    pub fn view(self, context: &mut PrivateContext) {\n        execution_cache::store(self.args, self.args_hash);\n        context\n            .call_private_function_with_args_hash(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                true,\n            )\n            .assert_empty();\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PrivateStaticVoidCallInterface<N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicCallInterface\n\npub struct PublicCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    gas_opts: GasOpts,\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let N: u32, T> PublicCallInterface<N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            gas_opts: GasOpts::default(),\n            return_type: std::mem::zeroed(),\n            is_static,\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn call<let M: u32>(self, context: &mut PublicContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        let returns = context.call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array::<M>())\n    }\n\n    pub unconstrained fn view<let M: u32>(self, context: &mut PublicContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array::<M>())\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            false,\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PublicCallInterface<N, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicVoidCallInterface\n\npub struct PublicVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let N: u32> PublicVoidCallInterface<N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            return_type: (),\n            is_static,\n            gas_opts: GasOpts::default(),\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn call(self, context: &mut PublicContext) {\n        let returns = context.call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        assert(returns.len() == 0);\n    }\n\n    pub unconstrained fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        assert(returns.len() == 0);\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            false,\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n        )\n    }\n\n    pub fn set_as_teardown(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.set_public_teardown_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            false,\n        )\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PublicVoidCallInterface<N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicStaticCallInterface\n\npub struct PublicStaticCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let N: u32, T> PublicStaticCallInterface<N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static: true,\n            gas_opts: GasOpts::default(),\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn view<let M: u32>(self, context: &mut PublicContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array::<M>())\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PublicStaticCallInterface<N, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicStaticVoidCallInterface\n\npub struct PublicStaticVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let N: u32> PublicStaticVoidCallInterface<N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            return_type: (),\n            is_static: true,\n            gas_opts: GasOpts::default(),\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        assert(returns.len() == 0);\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PublicStaticVoidCallInterface<N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n","path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.2/noir-projects/aztec-nr/aztec/src/context/call_interfaces.nr"},"60":{"source":"use crate::{\n    context::{inputs::PrivateContextInputs, returns_hash::ReturnsHash},\n    hash::{ArgsHasher, hash_args_array, hash_calldata_array},\n    keys::constants::{NULLIFIER_INDEX, NUM_KEY_TYPES, OUTGOING_INDEX, sk_generators},\n    messaging::process_l1_to_l2_message,\n    oracle::{\n        block_header::get_block_header_at,\n        call_private_function::call_private_function_internal,\n        enqueue_public_function_call::{\n            notify_enqueued_public_function_call, notify_set_min_revertible_side_effect_counter,\n            notify_set_public_teardown_function_call,\n        },\n        execution_cache,\n        key_validation_request::get_key_validation_request,\n        notes::{notify_created_nullifier, notify_nullified_note},\n    },\n};\nuse dep::protocol_types::{\n    abis::{\n        call_context::CallContext,\n        function_selector::FunctionSelector,\n        gas_settings::GasSettings,\n        log::Log,\n        log_hash::LogHash,\n        max_block_number::MaxBlockNumber,\n        note_hash::NoteHash,\n        nullifier::Nullifier,\n        private_call_request::PrivateCallRequest,\n        private_circuit_public_inputs::PrivateCircuitPublicInputs,\n        private_log::PrivateLogData,\n        public_call_request::PublicCallRequest,\n        read_request::ReadRequest,\n        side_effect::Counted,\n        validation_requests::{KeyValidationRequest, KeyValidationRequestAndGenerator},\n    },\n    address::{AztecAddress, EthAddress},\n    block_header::BlockHeader,\n    constants::{\n        MAX_CONTRACT_CLASS_LOGS_PER_CALL, MAX_ENQUEUED_CALLS_PER_CALL,\n        MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_L2_TO_L1_MSGS_PER_CALL,\n        MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NOTE_HASHES_PER_CALL,\n        MAX_NULLIFIER_READ_REQUESTS_PER_CALL, MAX_NULLIFIERS_PER_CALL,\n        MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PRIVATE_LOGS_PER_CALL,\n        PRIVATE_LOG_SIZE_IN_FIELDS,\n    },\n    messaging::l2_to_l1_message::L2ToL1Message,\n    traits::{Empty, Hash, ToField},\n    utils::arrays::array_concat,\n};\n\n// When finished, one can call .finish() to convert back to the abi\npub struct PrivateContext {\n    // docs:start:private-context\n    pub inputs: PrivateContextInputs,\n    pub side_effect_counter: u32,\n\n    pub min_revertible_side_effect_counter: u32,\n    pub is_fee_payer: bool,\n\n    pub args_hash: Field,\n    pub return_hash: Field,\n\n    pub max_block_number: MaxBlockNumber,\n\n    pub note_hash_read_requests: BoundedVec<ReadRequest, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>,\n    pub nullifier_read_requests: BoundedVec<ReadRequest, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\n    key_validation_requests_and_generators: BoundedVec<KeyValidationRequestAndGenerator, MAX_KEY_VALIDATION_REQUESTS_PER_CALL>,\n\n    pub note_hashes: BoundedVec<NoteHash, MAX_NOTE_HASHES_PER_CALL>,\n    pub nullifiers: BoundedVec<Nullifier, MAX_NULLIFIERS_PER_CALL>,\n\n    pub private_call_requests: BoundedVec<PrivateCallRequest, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    pub public_call_requests: BoundedVec<Counted<PublicCallRequest>, MAX_ENQUEUED_CALLS_PER_CALL>,\n    pub public_teardown_call_request: PublicCallRequest,\n    pub l2_to_l1_msgs: BoundedVec<L2ToL1Message, MAX_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    pub historical_header: BlockHeader,\n\n    pub private_logs: BoundedVec<PrivateLogData, MAX_PRIVATE_LOGS_PER_CALL>,\n    pub contract_class_logs_hashes: BoundedVec<LogHash, MAX_CONTRACT_CLASS_LOGS_PER_CALL>,\n\n    // Contains the last key validation request for each key type. This is used to cache the last request and avoid\n    // fetching the same request multiple times.\n    // The index of the array corresponds to the key type (0 nullifier, 1 incoming, 2 outgoing, 3 tagging).\n    pub last_key_validation_requests: [Option<KeyValidationRequest>; NUM_KEY_TYPES],\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        PrivateContext {\n            inputs,\n            side_effect_counter: inputs.start_side_effect_counter + 1,\n            min_revertible_side_effect_counter: 0,\n            is_fee_payer: false,\n            args_hash,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            historical_header: inputs.historical_header,\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n\n    pub fn msg_sender(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    pub fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.contract_address\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.inputs.tx_context.chain_id\n    }\n\n    pub fn version(self) -> Field {\n        self.inputs.tx_context.version\n    }\n\n    pub fn gas_settings(self) -> GasSettings {\n        self.inputs.tx_context.gas_settings\n    }\n\n    pub fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    pub fn get_args_hash(self) -> Field {\n        self.args_hash\n    }\n\n    pub fn push_note_hash(&mut self, note_hash: Field) {\n        self.note_hashes.push(NoteHash { value: note_hash, counter: self.next_counter() });\n    }\n\n    pub fn push_nullifier(&mut self, nullifier: Field) {\n        notify_created_nullifier(nullifier);\n        self.nullifiers.push(\n            Nullifier { value: nullifier, note_hash: 0, counter: self.next_counter() },\n        );\n    }\n\n    pub fn push_nullifier_for_note_hash(&mut self, nullifier: Field, nullified_note_hash: Field) {\n        let nullifier_counter = self.next_counter();\n        notify_nullified_note(nullifier, nullified_note_hash, nullifier_counter);\n        self.nullifiers.push(\n            Nullifier {\n                value: nullifier,\n                note_hash: nullified_note_hash,\n                counter: nullifier_counter,\n            },\n        );\n    }\n\n    // Returns the header of a block whose state is used during private execution (not the block the transaction is\n    // included in).\n    pub fn get_block_header(self) -> BlockHeader {\n        self.historical_header\n    }\n\n    // Returns the header of an arbitrary block whose block number is less than or equal to the block number\n    // of historical header.\n    pub fn get_block_header_at(self, block_number: u32) -> BlockHeader {\n        get_block_header_at(block_number, self)\n    }\n\n    pub fn set_return_hash(&mut self, returns_hasher: ArgsHasher) {\n        self.return_hash = returns_hasher.hash();\n        execution_cache::store(returns_hasher.fields, self.return_hash);\n    }\n\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\n        PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            returns_hash: self.return_hash,\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\n            is_fee_payer: self.is_fee_payer,\n            max_block_number: self.max_block_number,\n            note_hash_read_requests: self.note_hash_read_requests.storage(),\n            nullifier_read_requests: self.nullifier_read_requests.storage(),\n            key_validation_requests_and_generators: self\n                .key_validation_requests_and_generators\n                .storage(),\n            note_hashes: self.note_hashes.storage(),\n            nullifiers: self.nullifiers.storage(),\n            private_call_requests: self.private_call_requests.storage(),\n            public_call_requests: self.public_call_requests.storage(),\n            public_teardown_call_request: self.public_teardown_call_request,\n            l2_to_l1_msgs: self.l2_to_l1_msgs.storage(),\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\n            end_side_effect_counter: self.side_effect_counter,\n            private_logs: self.private_logs.storage(),\n            contract_class_logs_hashes: self.contract_class_logs_hashes.storage(),\n            historical_header: self.historical_header,\n            tx_context: self.inputs.tx_context,\n        }\n    }\n\n    pub fn set_as_fee_payer(&mut self) {\n        dep::protocol_types::debug_log::debug_log_format(\n            \"Setting {0} as fee payer\",\n            [self.this_address().to_field()],\n        );\n        self.is_fee_payer = true;\n    }\n\n    pub fn end_setup(&mut self) {\n        // dep::protocol_types::debug_log::debug_log_format(\n        //     \"Ending setup at counter {0}\",\n        //     [self.side_effect_counter as Field]\n        // );\n        self.min_revertible_side_effect_counter = self.side_effect_counter;\n        notify_set_min_revertible_side_effect_counter(self.min_revertible_side_effect_counter);\n    }\n\n    // docs:start:max-block-number\n    pub fn set_tx_max_block_number(&mut self, max_block_number: u32) {\n        // docs:end:max-block-number\n        self.max_block_number =\n            MaxBlockNumber::min_with_u32(self.max_block_number, max_block_number);\n    }\n\n    pub fn push_note_hash_read_request(&mut self, note_hash: Field) {\n        let side_effect = ReadRequest { value: note_hash, counter: self.next_counter() };\n        self.note_hash_read_requests.push(side_effect);\n    }\n\n    pub fn push_nullifier_read_request(&mut self, nullifier: Field) {\n        let request = ReadRequest { value: nullifier, counter: self.next_counter() };\n        self.nullifier_read_requests.push(request);\n    }\n\n    pub fn request_nsk_app(&mut self, npk_m_hash: Field) -> Field {\n        self.request_sk_app(npk_m_hash, NULLIFIER_INDEX)\n    }\n\n    pub fn request_ovsk_app(&mut self, ovpk_m_hash: Field) -> Field {\n        self.request_sk_app(ovpk_m_hash, OUTGOING_INDEX)\n    }\n\n    fn request_sk_app(&mut self, pk_m_hash: Field, key_index: Field) -> Field {\n        let cached_request = self.last_key_validation_requests[key_index as u32].unwrap_or(\n            KeyValidationRequest::empty(),\n        );\n\n        if cached_request.pk_m.hash() == pk_m_hash {\n            // We get a match so the cached request is the latest one\n            cached_request.sk_app\n        } else {\n            // We didn't get a match meaning the cached result is stale\n            // Typically we'd validate keys by showing that they are the preimage of `pk_m_hash`, but that'd require\n            // the oracle returning the master secret keys, which could cause malicious contracts to leak it or learn\n            // about secrets from other contracts. We therefore silo secret keys, and rely on the private kernel to\n            // validate that we siloed secret key corresponds to correct siloing of the master secret key that hashes\n            // to `pk_m_hash`.\n\n            // Safety: Kernels verify that the key validation request is valid and below we verify that a request\n            // for the correct public key has been received.\n            let request = unsafe { get_key_validation_request(pk_m_hash, key_index) };\n            assert_eq(request.pk_m.hash(), pk_m_hash, \"Obtained invalid key validation request\");\n\n            self.key_validation_requests_and_generators.push(\n                KeyValidationRequestAndGenerator {\n                    request,\n                    sk_app_generator: sk_generators[key_index as u32],\n                },\n            );\n            self.last_key_validation_requests[key_index as u32] = Option::some(request);\n            request.sk_app\n        }\n    }\n\n    // docs:start:context_message_portal\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        // docs:end:context_message_portal\n        let message = L2ToL1Message { recipient, content, counter: self.next_counter() };\n        self.l2_to_l1_msgs.push(message);\n    }\n\n    // docs:start:context_consume_l1_to_l2_message\n    // docs:start:consume_l1_to_l2_message\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        // docs:end:context_consume_l1_to_l2_message\n        let nullifier = process_l1_to_l2_message(\n            self.historical_header.state.l1_to_l2_message_tree.root,\n            self.this_address(),\n            sender,\n            self.chain_id(),\n            self.version(),\n            content,\n            secret,\n            leaf_index,\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_nullifier(nullifier)\n    }\n    // docs:end:consume_l1_to_l2_message\n\n    pub fn emit_private_log(&mut self, log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS]) {\n        let counter = self.next_counter();\n        let private_log = PrivateLogData { log: Log::new(log), note_hash_counter: 0, counter };\n        self.private_logs.push(private_log);\n    }\n\n    pub fn emit_raw_note_log(\n        &mut self,\n        log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS],\n        note_hash_counter: u32,\n    ) {\n        let counter = self.next_counter();\n        let private_log = PrivateLogData { log: Log::new(log), note_hash_counter, counter };\n        self.private_logs.push(private_log);\n    }\n\n    pub fn call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) -> ReturnsHash {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args, args_hash);\n        self.call_private_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    pub fn static_call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) -> ReturnsHash {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args, args_hash);\n        self.call_private_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            true,\n        )\n    }\n\n    pub fn call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> ReturnsHash {\n        self.call_private_function_with_args_hash(contract_address, function_selector, 0, false)\n    }\n\n    pub fn static_call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> ReturnsHash {\n        self.call_private_function_with_args_hash(contract_address, function_selector, 0, true)\n    }\n\n    pub fn call_private_function_with_args_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) -> ReturnsHash {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let start_side_effect_counter = self.side_effect_counter;\n\n        // Safety: The oracle simulates the private call and returns the value of the side effects counter after\n        // execution of the call (which means that end_side_effect_counter - start_side_effect_counter is\n        // the number of side effects that took place), along with the hash of the return values. We validate these\n        // by requesting a private kernel iteration in which the return values are constrained to hash\n        // to `returns_hash` and the side effects counter to increment from start to end.\n        let (end_side_effect_counter, returns_hash) = unsafe {\n            call_private_function_internal(\n                contract_address,\n                function_selector,\n                args_hash,\n                start_side_effect_counter,\n                is_static_call,\n            )\n        };\n\n        self.private_call_requests.push(\n            PrivateCallRequest {\n                call_context: CallContext {\n                    msg_sender: self.this_address(),\n                    contract_address,\n                    function_selector,\n                    is_static_call,\n                },\n                args_hash,\n                returns_hash,\n                start_side_effect_counter,\n                end_side_effect_counter,\n            },\n        );\n\n        // TODO (fees) figure out why this crashes the prover and enable it\n        // we need this in order to pay fees inside child call contexts\n        // assert(\n        //     (item.public_inputs.min_revertible_side_effect_counter == 0 as u32)\n        //     | (item.public_inputs.min_revertible_side_effect_counter\n        //         > self.min_revertible_side_effect_counter)\n        // );\n        // if item.public_inputs.min_revertible_side_effect_counter\n        //     > self.min_revertible_side_effect_counter {\n        //     self.min_revertible_side_effect_counter = item.public_inputs.min_revertible_side_effect_counter;\n        // }\n        self.side_effect_counter = end_side_effect_counter + 1;\n        ReturnsHash::new(returns_hash)\n    }\n\n    pub fn call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let calldata = array_concat([function_selector.to_field()], args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, false)\n    }\n\n    pub fn static_call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let calldata = array_concat([function_selector.to_field()], args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, true)\n    }\n\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        let calldata_hash = hash_calldata_array([function_selector.to_field()]);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, false)\n    }\n\n    pub fn static_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        let calldata_hash = hash_calldata_array([function_selector.to_field()]);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, true)\n    }\n\n    pub fn call_public_function_with_calldata_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        calldata_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n\n        notify_enqueued_public_function_call(\n            contract_address,\n            calldata_hash,\n            counter,\n            is_static_call,\n        );\n\n        let call_request = PublicCallRequest {\n            msg_sender: self.this_address(),\n            contract_address,\n            is_static_call,\n            calldata_hash,\n        };\n\n        self.public_call_requests.push(Counted::new(call_request, counter));\n    }\n\n    pub fn set_public_teardown_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let calldata = array_concat([function_selector.to_field()], args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.set_public_teardown_function_with_calldata_hash(contract_address, calldata_hash, false)\n    }\n\n    pub fn set_public_teardown_function_with_calldata_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        calldata_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n\n        notify_set_public_teardown_function_call(\n            contract_address,\n            calldata_hash,\n            counter,\n            is_static_call,\n        );\n\n        self.public_teardown_call_request = PublicCallRequest {\n            msg_sender: self.this_address(),\n            contract_address,\n            is_static_call,\n            calldata_hash,\n        };\n    }\n\n    fn next_counter(&mut self) -> u32 {\n        let counter = self.side_effect_counter;\n        self.side_effect_counter += 1;\n        counter\n    }\n}\n\nimpl Empty for PrivateContext {\n    fn empty() -> Self {\n        PrivateContext {\n            inputs: PrivateContextInputs::empty(),\n            side_effect_counter: 0 as u32,\n            min_revertible_side_effect_counter: 0 as u32,\n            is_fee_payer: false,\n            args_hash: 0,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            historical_header: BlockHeader::empty(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n}\n","path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.2/noir-projects/aztec-nr/aztec/src/context/private_context.nr"},"61":{"source":"use crate::context::gas::GasOpts;\nuse crate::hash::{\n    compute_l1_to_l2_message_hash, compute_l1_to_l2_message_nullifier, compute_secret_hash,\n};\nuse dep::protocol_types::abis::function_selector::FunctionSelector;\nuse dep::protocol_types::address::{AztecAddress, EthAddress};\nuse dep::protocol_types::constants::MAX_FIELD_VALUE;\nuse dep::protocol_types::traits::{Empty, FromField, Packable, Serialize, ToField};\n\npub struct PublicContext {\n    pub args_hash: Option<Field>,\n    pub compute_args_hash: fn() -> Field,\n}\n\nimpl PublicContext {\n    pub fn new(compute_args_hash: fn() -> Field) -> Self {\n        PublicContext { args_hash: Option::none(), compute_args_hash }\n    }\n\n    pub fn emit_public_log<T, let N: u32>(_self: &mut Self, log: T)\n    where\n        T: Serialize<N>,\n    {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_public_log(Serialize::serialize(log).as_slice()) };\n    }\n\n    pub fn note_hash_exists(_self: Self, note_hash: Field, leaf_index: Field) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { note_hash_exists(note_hash, leaf_index) } == 1\n    }\n\n    pub fn l1_to_l2_msg_exists(_self: Self, msg_hash: Field, msg_leaf_index: Field) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { l1_to_l2_msg_exists(msg_hash, msg_leaf_index) } == 1\n    }\n\n    pub fn nullifier_exists(_self: Self, unsiloed_nullifier: Field, address: AztecAddress) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { nullifier_exists(unsiloed_nullifier, address.to_field()) } == 1\n    }\n\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        let secret_hash = compute_secret_hash(secret);\n        let message_hash = compute_l1_to_l2_message_hash(\n            sender,\n            self.chain_id(),\n            /*recipient=*/\n            self.this_address(),\n            self.version(),\n            content,\n            secret_hash,\n            leaf_index,\n        );\n        let nullifier = compute_l1_to_l2_message_nullifier(message_hash, secret);\n\n        assert(\n            !self.nullifier_exists(nullifier, self.this_address()),\n            \"L1-to-L2 message is already nullified\",\n        );\n        assert(\n            self.l1_to_l2_msg_exists(message_hash, leaf_index),\n            \"Tried to consume nonexistent L1-to-L2 message\",\n        );\n\n        self.push_nullifier(nullifier);\n    }\n\n    pub fn message_portal(_self: &mut Self, recipient: EthAddress, content: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { send_l2_to_l1_msg(recipient, content) };\n    }\n\n    pub unconstrained fn call_public_function(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let calldata = args.push_front(function_selector.to_field());\n\n        call(gas_for_call(gas_opts), contract_address, calldata);\n        // Use success_copy to determine whether the call succeeded\n        let success = success_copy();\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    pub unconstrained fn static_call_public_function(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let calldata = args.push_front(function_selector.to_field());\n\n        call_static(gas_for_call(gas_opts), contract_address, calldata);\n        // Use success_copy to determine whether the call succeeded\n        let success = success_copy();\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    pub fn push_note_hash(_self: &mut Self, note_hash: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_note_hash(note_hash) };\n    }\n    pub fn push_nullifier(_self: &mut Self, nullifier: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_nullifier(nullifier) };\n    }\n\n    pub fn this_address(_self: Self) -> AztecAddress {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            address()\n        }\n    }\n    pub fn msg_sender(_self: Self) -> AztecAddress {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            sender()\n        }\n    }\n    pub fn selector(_self: Self) -> FunctionSelector {\n        // The selector is the first element of the calldata when calling a public function through dispatch.\n        // Safety: AVM opcodes are constrained by the AVM itself\n        let raw_selector: [Field; 1] = unsafe { calldata_copy(0, 1) };\n        FunctionSelector::from_field(raw_selector[0])\n    }\n    pub fn get_args_hash(mut self) -> Field {\n        if !self.args_hash.is_some() {\n            self.args_hash = Option::some((self.compute_args_hash)());\n        }\n\n        self.args_hash.unwrap_unchecked()\n    }\n    pub fn transaction_fee(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            transaction_fee()\n        }\n    }\n\n    pub fn chain_id(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            chain_id()\n        }\n    }\n    pub fn version(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            version()\n        }\n    }\n    pub fn block_number(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            block_number()\n        }\n    }\n    pub fn timestamp(_self: Self) -> u64 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            timestamp()\n        }\n    }\n    pub fn fee_per_l2_gas(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            fee_per_l2_gas()\n        }\n    }\n    pub fn fee_per_da_gas(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            fee_per_da_gas()\n        }\n    }\n\n    pub fn l2_gas_left(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            l2_gas_left()\n        }\n    }\n    pub fn da_gas_left(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            da_gas_left()\n        }\n    }\n    pub fn is_static_call(_self: Self) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { is_static_call() } == 1\n    }\n\n    pub fn raw_storage_read<let N: u32>(_self: Self, storage_slot: Field) -> [Field; N] {\n        let mut out = [0; N];\n        for i in 0..N {\n            // Safety: AVM opcodes are constrained by the AVM itself\n            out[i] = unsafe { storage_read(storage_slot + i as Field) };\n        }\n        out\n    }\n\n    pub fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T\n    where\n        T: Packable<N>,\n    {\n        T::unpack(self.raw_storage_read(storage_slot))\n    }\n\n    pub fn raw_storage_write<let N: u32>(_self: Self, storage_slot: Field, values: [Field; N]) {\n        for i in 0..N {\n            // Safety: AVM opcodes are constrained by the AVM itself\n            unsafe { storage_write(storage_slot + i as Field, values[i]) };\n        }\n    }\n\n    pub fn storage_write<T, let N: u32>(self, storage_slot: Field, value: T)\n    where\n        T: Packable<N>,\n    {\n        self.raw_storage_write(storage_slot, value.pack());\n    }\n}\n\n// Helper functions\nfn gas_for_call(user_gas: GasOpts) -> [Field; 2] {\n    // It's ok to use the max possible gas here, because the gas will be\n    // capped by the gas left in the (STATIC)CALL instruction.\n    [user_gas.l2_gas.unwrap_or(MAX_FIELD_VALUE), user_gas.da_gas.unwrap_or(MAX_FIELD_VALUE)]\n}\n\n// Unconstrained opcode wrappers (do not use directly).\nunconstrained fn address() -> AztecAddress {\n    address_opcode()\n}\nunconstrained fn sender() -> AztecAddress {\n    sender_opcode()\n}\nunconstrained fn transaction_fee() -> Field {\n    transaction_fee_opcode()\n}\nunconstrained fn chain_id() -> Field {\n    chain_id_opcode()\n}\nunconstrained fn version() -> Field {\n    version_opcode()\n}\nunconstrained fn block_number() -> Field {\n    block_number_opcode()\n}\nunconstrained fn timestamp() -> u64 {\n    timestamp_opcode()\n}\nunconstrained fn fee_per_l2_gas() -> Field {\n    fee_per_l2_gas_opcode()\n}\nunconstrained fn fee_per_da_gas() -> Field {\n    fee_per_da_gas_opcode()\n}\nunconstrained fn l2_gas_left() -> Field {\n    l2_gas_left_opcode()\n}\nunconstrained fn da_gas_left() -> Field {\n    da_gas_left_opcode()\n}\nunconstrained fn is_static_call() -> Field {\n    is_static_call_opcode()\n}\nunconstrained fn note_hash_exists(note_hash: Field, leaf_index: Field) -> u1 {\n    note_hash_exists_opcode(note_hash, leaf_index)\n}\nunconstrained fn emit_note_hash(note_hash: Field) {\n    emit_note_hash_opcode(note_hash)\n}\nunconstrained fn nullifier_exists(nullifier: Field, address: Field) -> u1 {\n    nullifier_exists_opcode(nullifier, address)\n}\nunconstrained fn emit_nullifier(nullifier: Field) {\n    emit_nullifier_opcode(nullifier)\n}\nunconstrained fn emit_public_log(message: [Field]) {\n    emit_public_log_opcode(message)\n}\nunconstrained fn l1_to_l2_msg_exists(msg_hash: Field, msg_leaf_index: Field) -> u1 {\n    l1_to_l2_msg_exists_opcode(msg_hash, msg_leaf_index)\n}\nunconstrained fn send_l2_to_l1_msg(recipient: EthAddress, content: Field) {\n    send_l2_to_l1_msg_opcode(recipient, content)\n}\nunconstrained fn call(gas: [Field; 2], address: AztecAddress, args: [Field]) {\n    call_opcode(gas, address, args)\n}\n\nunconstrained fn call_static(gas: [Field; 2], address: AztecAddress, args: [Field]) {\n    call_static_opcode(gas, address, args)\n}\n\npub unconstrained fn calldata_copy<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {\n    calldata_copy_opcode(cdoffset, copy_size)\n}\n\n// `success_copy` is placed immediately after the CALL opcode to get the success value\nunconstrained fn success_copy() -> bool {\n    success_copy_opcode()\n}\n\nunconstrained fn returndata_size() -> u32 {\n    returndata_size_opcode()\n}\n\nunconstrained fn returndata_copy(rdoffset: u32, copy_size: u32) -> [Field] {\n    returndata_copy_opcode(rdoffset, copy_size)\n}\n\npub unconstrained fn avm_return(returndata: [Field]) {\n    return_opcode(returndata)\n}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\nunconstrained fn avm_revert(revertdata: [Field]) {\n    revert_opcode(revertdata)\n}\n\nunconstrained fn storage_read(storage_slot: Field) -> Field {\n    storage_read_opcode(storage_slot)\n}\n\nunconstrained fn storage_write(storage_slot: Field, value: Field) {\n    storage_write_opcode(storage_slot, value);\n}\n\nimpl Empty for PublicContext {\n    fn empty() -> Self {\n        PublicContext::new(|| 0)\n    }\n}\n\n// AVM oracles (opcodes) follow, do not use directly.\n#[oracle(avmOpcodeAddress)]\nunconstrained fn address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeSender)]\nunconstrained fn sender_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeTransactionFee)]\nunconstrained fn transaction_fee_opcode() -> Field {}\n\n#[oracle(avmOpcodeChainId)]\nunconstrained fn chain_id_opcode() -> Field {}\n\n#[oracle(avmOpcodeVersion)]\nunconstrained fn version_opcode() -> Field {}\n\n#[oracle(avmOpcodeBlockNumber)]\nunconstrained fn block_number_opcode() -> Field {}\n\n#[oracle(avmOpcodeTimestamp)]\nunconstrained fn timestamp_opcode() -> u64 {}\n\n#[oracle(avmOpcodeFeePerL2Gas)]\nunconstrained fn fee_per_l2_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeFeePerDaGas)]\nunconstrained fn fee_per_da_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeL2GasLeft)]\nunconstrained fn l2_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeDaGasLeft)]\nunconstrained fn da_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeIsStaticCall)]\nunconstrained fn is_static_call_opcode() -> Field {}\n\n#[oracle(avmOpcodeNoteHashExists)]\nunconstrained fn note_hash_exists_opcode(note_hash: Field, leaf_index: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNoteHash)]\nunconstrained fn emit_note_hash_opcode(note_hash: Field) {}\n\n#[oracle(avmOpcodeNullifierExists)]\nunconstrained fn nullifier_exists_opcode(nullifier: Field, address: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNullifier)]\nunconstrained fn emit_nullifier_opcode(nullifier: Field) {}\n\n// TODO(#11124): rename unencrypted to public in avm\n#[oracle(avmOpcodeEmitUnencryptedLog)]\nunconstrained fn emit_public_log_opcode(message: [Field]) {}\n\n#[oracle(avmOpcodeL1ToL2MsgExists)]\nunconstrained fn l1_to_l2_msg_exists_opcode(msg_hash: Field, msg_leaf_index: Field) -> u1 {}\n\n#[oracle(avmOpcodeSendL2ToL1Msg)]\nunconstrained fn send_l2_to_l1_msg_opcode(recipient: EthAddress, content: Field) {}\n\n#[oracle(avmOpcodeCalldataCopy)]\nunconstrained fn calldata_copy_opcode<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {}\n\n#[oracle(avmOpcodeReturndataSize)]\nunconstrained fn returndata_size_opcode() -> u32 {}\n\n#[oracle(avmOpcodeReturndataCopy)]\nunconstrained fn returndata_copy_opcode(rdoffset: u32, copy_size: u32) -> [Field] {}\n\n#[oracle(avmOpcodeReturn)]\nunconstrained fn return_opcode(returndata: [Field]) {}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\n#[oracle(avmOpcodeRevert)]\nunconstrained fn revert_opcode(revertdata: [Field]) {}\n\n#[oracle(avmOpcodeCall)]\nunconstrained fn call_opcode(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n) {}\n\n#[oracle(avmOpcodeStaticCall)]\nunconstrained fn call_static_opcode(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n) {}\n\n#[oracle(avmOpcodeSuccessCopy)]\nunconstrained fn success_copy_opcode() -> bool {}\n\n#[oracle(avmOpcodeStorageRead)]\nunconstrained fn storage_read_opcode(storage_slot: Field) -> Field {}\n\n#[oracle(avmOpcodeStorageWrite)]\nunconstrained fn storage_write_opcode(storage_slot: Field, value: Field) {}\n","path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.2/noir-projects/aztec-nr/aztec/src/context/public_context.nr"},"63":{"source":"use crate::oracle::{\n    execution::{get_block_number, get_chain_id, get_contract_address, get_version},\n    storage::storage_read,\n};\nuse dep::protocol_types::{address::AztecAddress, traits::Packable};\n\npub struct UtilityContext {\n    block_number: u32,\n    contract_address: AztecAddress,\n    version: Field,\n    chain_id: Field,\n}\n\nimpl UtilityContext {\n    pub unconstrained fn new() -> Self {\n        // We could call these oracles on the getters instead of at creation, which makes sense given that they might\n        // not even be accessed. However any performance gains are minimal, and we'd rather fail early if a user\n        // incorrectly attempts to create a UtilityContext in an environment in which these oracles are not\n        // available.\n        let block_number = get_block_number();\n        let contract_address = get_contract_address();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub unconstrained fn at(contract_address: AztecAddress) -> Self {\n        let block_number = get_block_number();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub unconstrained fn at_historical(contract_address: AztecAddress, block_number: u32) -> Self {\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub fn block_number(self) -> u32 {\n        self.block_number\n    }\n\n    pub fn this_address(self) -> AztecAddress {\n        self.contract_address\n    }\n\n    pub fn version(self) -> Field {\n        self.version\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.chain_id\n    }\n\n    pub unconstrained fn raw_storage_read<let N: u32>(\n        self: Self,\n        storage_slot: Field,\n    ) -> [Field; N] {\n        storage_read(self.this_address(), storage_slot, self.block_number())\n    }\n\n    pub unconstrained fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T\n    where\n        T: Packable<N>,\n    {\n        T::unpack(self.raw_storage_read(storage_slot))\n    }\n}\n","path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.2/noir-projects/aztec-nr/aztec/src/context/utility_context.nr"},"67":{"source":"use dep::protocol_types::{\n    address::{AztecAddress, EthAddress},\n    constants::{\n        GENERATOR_INDEX__FUNCTION_ARGS, GENERATOR_INDEX__MESSAGE_NULLIFIER,\n        GENERATOR_INDEX__PUBLIC_CALLDATA, GENERATOR_INDEX__SECRET_HASH,\n    },\n    hash::{poseidon2_hash_with_separator, poseidon2_hash_with_separator_slice, sha256_to_field},\n    point::Point,\n    traits::{Hash, ToField},\n};\n\npub use dep::protocol_types::hash::{compute_siloed_nullifier, pedersen_hash};\n\npub fn pedersen_commitment<let N: u32>(inputs: [Field; N], hash_index: u32) -> Point {\n    std::hash::pedersen_commitment_with_separator(inputs, hash_index)\n}\n\npub fn compute_secret_hash(secret: Field) -> Field {\n    poseidon2_hash_with_separator([secret], GENERATOR_INDEX__SECRET_HASH)\n}\n\npub fn compute_l1_to_l2_message_hash(\n    sender: EthAddress,\n    chain_id: Field,\n    recipient: AztecAddress,\n    version: Field,\n    content: Field,\n    secret_hash: Field,\n    leaf_index: Field,\n) -> Field {\n    let mut hash_bytes = [0 as u8; 224];\n    let sender_bytes: [u8; 32] = sender.to_field().to_be_bytes();\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\n    let recipient_bytes: [u8; 32] = recipient.to_field().to_be_bytes();\n    let version_bytes: [u8; 32] = version.to_be_bytes();\n    let content_bytes: [u8; 32] = content.to_be_bytes();\n    let secret_hash_bytes: [u8; 32] = secret_hash.to_be_bytes();\n    let leaf_index_bytes: [u8; 32] = leaf_index.to_be_bytes();\n\n    for i in 0..32 {\n        hash_bytes[i] = sender_bytes[i];\n        hash_bytes[i + 32] = chain_id_bytes[i];\n        hash_bytes[i + 64] = recipient_bytes[i];\n        hash_bytes[i + 96] = version_bytes[i];\n        hash_bytes[i + 128] = content_bytes[i];\n        hash_bytes[i + 160] = secret_hash_bytes[i];\n        hash_bytes[i + 192] = leaf_index_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\n// The nullifier of a l1 to l2 message is the hash of the message salted with the secret\npub fn compute_l1_to_l2_message_nullifier(message_hash: Field, secret: Field) -> Field {\n    poseidon2_hash_with_separator([message_hash, secret], GENERATOR_INDEX__MESSAGE_NULLIFIER)\n}\n\npub struct ArgsHasher {\n    pub fields: [Field],\n}\n\nimpl Hash for ArgsHasher {\n    fn hash(self) -> Field {\n        hash_args(self.fields)\n    }\n}\n\nimpl ArgsHasher {\n    pub fn new() -> Self {\n        Self { fields: [] }\n    }\n\n    pub fn add(&mut self, field: Field) {\n        self.fields = self.fields.push_back(field);\n    }\n\n    pub fn add_multiple<let N: u32>(&mut self, fields: [Field; N]) {\n        for i in 0..N {\n            self.fields = self.fields.push_back(fields[i]);\n        }\n    }\n}\n\n// Computes the hash of input arguments or return values for private functions, or for authwit creation.\npub fn hash_args_array<let N: u32>(args: [Field; N]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n// Same as `hash_args_array`, but takes a slice instead of an array.\npub fn hash_args(args: [Field]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator_slice(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n// Computes the hash of calldata for public functions.\npub fn hash_calldata_array<let N: u32>(calldata: [Field; N]) -> Field {\n    if calldata.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(calldata, GENERATOR_INDEX__PUBLIC_CALLDATA)\n    }\n}\n\n// Same as `hash_calldata_array`, but takes a slice instead of an array.\npub fn hash_calldata(calldata: [Field]) -> Field {\n    if calldata.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator_slice(calldata, GENERATOR_INDEX__PUBLIC_CALLDATA)\n    }\n}\n\n#[test]\nunconstrained fn compute_var_args_hash() {\n    let mut input = ArgsHasher::new();\n    for i in 0..100 {\n        input.add(i as Field);\n    }\n    let hash = input.hash();\n    dep::std::println(hash);\n    assert(hash == 0x19b0d74feb06ebde19edd85a28986c97063e84b3b351a8b666c7cac963ce655f);\n}\n","path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.2/noir-projects/aztec-nr/aztec/src/hash.nr"},"89":{"source":"use super::utils::compute_fn_selector;\nuse std::panic;\n\n/// Returns an `fn public_dispatch(...)` function for the given module that's assumed to be an Aztec contract.\npub comptime fn generate_public_dispatch(m: Module) -> Quoted {\n    let functions = m.functions();\n    let functions =\n        functions.filter(|function: FunctionDefinition| function.has_named_attribute(\"public\"));\n\n    let unit = get_type::<()>();\n\n    let ifs = functions.map(|function: FunctionDefinition| {\n        let parameters = function.parameters();\n        let return_type = function.return_type();\n\n        let selector: Field = compute_fn_selector(function);\n\n        let mut parameters_size = 0;\n        for param in parameters {\n            parameters_size += size_in_fields(param.1);\n        }\n\n        let initial_read = if parameters.len() == 0 {\n            quote {}\n        } else {\n            // The initial calldata_copy offset is 1 to skip the Field selector\n            // The expected calldata is the serialization of\n            // - FunctionSelector: the selector of the function intended to dispatch\n            // - Parameters: the parameters of the function intended to dispatch\n            // That is, exactly what is expected for a call to the target function,\n            // but with a selector added at the beginning.\n            quote {\n                let input_calldata: [Field; $parameters_size] = dep::aztec::context::public_context::calldata_copy(1, $parameters_size);\n                let mut reader = dep::aztec::protocol_types::utils::reader::Reader::new(input_calldata);\n            }\n        };\n\n        let parameter_index = &mut 0;\n        let reads = parameters.map(|param: (Quoted, Type)| {\n            let parameter_index_value = *parameter_index;\n            let param_name = f\"arg{parameter_index_value}\".quoted_contents();\n            let param_type = param.1;\n            let read = quote {\n                let $param_name: $param_type = reader.read_struct(dep::aztec::protocol_types::traits::Deserialize::deserialize);\n            };\n            *parameter_index += 1;\n            quote { $read }\n        });\n        let read = reads.join(quote { });\n\n        let mut args = &[];\n        for parameter_index in 0..parameters.len() {\n            let param_name = f\"arg{parameter_index}\".quoted_contents();\n            args = args.push_back(quote { $param_name });\n        }\n\n        let args = args.join(quote { , });\n        // name of the function is assigned just before the call so debug metadata doesn't span most of this macro when figuring out where the call comes from.\n        let name = function.name();\n        let call = quote { $name($args) };\n\n        let return_code = if return_type == unit {\n            quote {\n                $call;\n                // Force early return.\n                dep::aztec::context::public_context::avm_return([]);\n            }\n        } else {\n            quote {\n                let return_value = dep::aztec::protocol_types::traits::Serialize::serialize($call);\n                dep::aztec::context::public_context::avm_return(return_value.as_slice());\n            }\n        };\n\n        let if_ = quote {\n            if selector == $selector {\n                $initial_read\n                $read\n                $return_code\n            }\n        };\n        if_\n    });\n\n    if ifs.len() == 0 {\n        // No dispatch function if there are no public functions\n        quote {}\n    } else {\n        let ifs = ifs.push_back(quote { panic(f\"Unknown selector {selector}\") });\n        let dispatch = ifs.join(quote {  });\n\n        let body = quote {\n            // We mark this as public because our whole system depends on public\n            // functions having this attribute. However, the public MACRO will\n            // handle the public_dispatch function specially and do nothing.\n            #[public]\n            pub unconstrained fn public_dispatch(selector: Field) {\n                $dispatch\n            }\n        };\n\n        body\n    }\n}\n\ncomptime fn size_in_fields(typ: Type) -> u32 {\n    let size = array_size_in_fields(typ);\n    let size = size.or_else(|| bool_size_in_fields(typ));\n    let size = size.or_else(|| constant_size_in_fields(typ));\n    let size = size.or_else(|| field_size_in_fields(typ));\n    let size = size.or_else(|| int_size_in_fields(typ));\n    let size = size.or_else(|| str_size_in_fields(typ));\n    let size = size.or_else(|| struct_size_in_fields(typ));\n    let size = size.or_else(|| tuple_size_in_fields(typ));\n    if size.is_some() {\n        size.unwrap()\n    } else {\n        panic(f\"Can't determine size in fields of {typ}\")\n    }\n}\n\ncomptime fn array_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_array().and_then(|typ: (Type, Type)| {\n        let (typ, element_size) = typ;\n        element_size.as_constant().map(|x: u32| x * size_in_fields(typ))\n    })\n}\n\ncomptime fn bool_size_in_fields(typ: Type) -> Option<u32> {\n    if typ.is_bool() {\n        Option::some(1)\n    } else {\n        Option::none()\n    }\n}\n\ncomptime fn field_size_in_fields(typ: Type) -> Option<u32> {\n    if typ.is_field() {\n        Option::some(1)\n    } else {\n        Option::none()\n    }\n}\n\ncomptime fn int_size_in_fields(typ: Type) -> Option<u32> {\n    if typ.as_integer().is_some() {\n        Option::some(1)\n    } else {\n        Option::none()\n    }\n}\n\ncomptime fn constant_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_constant()\n}\n\ncomptime fn str_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_str().map(|typ| size_in_fields(typ))\n}\n\ncomptime fn struct_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_data_type().map(|typ: (TypeDefinition, [Type])| {\n        let struct_type = typ.0;\n        let generics = typ.1;\n        let mut size = 0;\n        for field in struct_type.fields(generics) {\n            size += size_in_fields(field.1);\n        }\n        size\n    })\n}\n\ncomptime fn tuple_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_tuple().map(|types: [Type]| {\n        let mut size = 0;\n        for typ in types {\n            size += size_in_fields(typ);\n        }\n        size\n    })\n}\n\ncomptime fn get_type<T>() -> Type {\n    let t: T = std::mem::zeroed();\n    std::meta::type_of(t)\n}\n","path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.2/noir-projects/aztec-nr/aztec/src/macros/dispatch.nr"},"93":{"source":"use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress,\n    constants::GENERATOR_INDEX__CONSTRUCTOR, hash::poseidon2_hash_with_separator, traits::ToField,\n};\n\nuse crate::{\n    context::{PrivateContext, PublicContext},\n    oracle::get_contract_instance::{\n        get_contract_instance, get_contract_instance_deployer_avm,\n        get_contract_instance_initialization_hash_avm,\n    },\n};\n\npub fn mark_as_initialized_public(context: &mut PublicContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn mark_as_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn assert_is_initialized_public(context: &mut PublicContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    assert(context.nullifier_exists(init_nullifier, context.this_address()), \"Not initialized\");\n}\n\npub fn assert_is_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    context.push_nullifier_read_request(init_nullifier);\n}\n\nfn compute_unsiloed_contract_initialization_nullifier(address: AztecAddress) -> Field {\n    address.to_field()\n}\n\npub fn assert_initialization_matches_address_preimage_public(context: PublicContext) {\n    let address = context.this_address();\n    let deployer = get_contract_instance_deployer_avm(address).unwrap();\n    let initialization_hash = get_contract_instance_initialization_hash_avm(address).unwrap();\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (deployer.is_zero()) | (deployer == context.msg_sender()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\npub fn assert_initialization_matches_address_preimage_private(context: PrivateContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance(address);\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\n/// This function is not only used in macros but it's also used by external people to check that an instance has been\n/// initialized with the correct constructor arguments. Don't hide this unless you implement factory functionality.\npub fn compute_initialization_hash(\n    init_selector: FunctionSelector,\n    init_args_hash: Field,\n) -> Field {\n    poseidon2_hash_with_separator(\n        [init_selector.to_field(), init_args_hash],\n        GENERATOR_INDEX__CONSTRUCTOR,\n    )\n}\n","path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.2/noir-projects/aztec-nr/aztec/src/macros/functions/initialization_utils.nr"},"96":{"source":"use crate::macros::{\n    functions::{abi_export::create_fn_abi_export, call_interface_stubs::stub_fn, stub_registry},\n    notes::NOTES,\n    utils::{\n        add_to_hasher, fn_has_noinitcheck, get_fn_visibility, is_fn_contract_library_method,\n        is_fn_initializer, is_fn_internal, is_fn_private, is_fn_public, is_fn_test, is_fn_utility,\n        is_fn_view, modify_fn_body, module_has_initializer, module_has_storage,\n    },\n};\nuse protocol_types::meta::generate_serialize_to_fields;\nuse std::meta::type_of;\n\npub(crate) comptime fn transform_private(f: FunctionDefinition) -> Quoted {\n    let fn_abi = create_fn_abi_export(f);\n    let fn_stub = stub_fn(f);\n    stub_registry::register(f.module(), fn_stub);\n\n    // If a function is further modified as unconstrained, we throw an error\n    if f.is_unconstrained() {\n        let name = f.name();\n        panic(\n            f\"Function {name} is annotated with #[private] but marked as unconstrained, remove unconstrained keyword\",\n        );\n    }\n\n    let module_has_initializer = module_has_initializer(f.module());\n    let module_has_storage = module_has_storage(f.module());\n\n    // Private functions undergo a lot of transformations from their Aztec.nr form into a circuit that can be fed to the\n    // Private Kernel Circuit.\n    // First we change the function signature so that it also receives `PrivateContextInputs`, which contain information\n    // about the execution context (e.g. the caller).\n    let original_params = f.parameters();\n    f.set_parameters(&[(\n        quote { inputs },\n        quote { crate::context::inputs::private_context_inputs::PrivateContextInputs }.as_type(),\n    )]\n        .append(original_params));\n\n    let mut body = f.body().as_block().unwrap();\n\n    // The original params are hashed and passed to the `context` object, so that the kernel can verify we've received\n    // the correct values.\n    // TODO: Optimize args_hasher for small number of arguments\n    let args_hasher_name = quote { args_hasher };\n    let args_hasher = original_params.fold(\n        quote {\n            let mut $args_hasher_name = dep::aztec::hash::ArgsHasher::new();\n        },\n        |args_hasher, param: (Quoted, Type)| {\n            let (name, typ) = param;\n            let appended_arg = add_to_hasher(args_hasher_name, name, typ);\n            quote {\n                $args_hasher\n                $appended_arg\n            }\n        },\n    );\n\n    let context_creation = quote {\n        let mut context = dep::aztec::context::private_context::PrivateContext::new(inputs, dep::aztec::protocol_types::traits::Hash::hash($args_hasher_name));\n    };\n\n    // Modifications introduced by the different marker attributes.\n    let internal_check = if is_fn_internal(f) {\n        create_internal_check(f)\n    } else {\n        quote {}\n    };\n\n    let view_check = if is_fn_view(f) {\n        create_view_check(f)\n    } else {\n        quote {}\n    };\n\n    let (assert_initializer, mark_as_initialized) = if is_fn_initializer(f) {\n        (create_assert_correct_initializer_args(f), create_mark_as_initialized(f))\n    } else {\n        (quote {}, quote {})\n    };\n\n    let storage_init = if module_has_storage {\n        quote {\n            // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n            // referenced. We instead ignore 'unused variable' warnings for it.\n            #[allow(unused_variables)]\n            let storage = Storage::init(&mut context);\n        }\n    } else {\n        quote {}\n    };\n\n    // Initialization checks are not included in contracts that don't have initializers.\n    let init_check = if module_has_initializer & !is_fn_initializer(f) & !fn_has_noinitcheck(f) {\n        create_init_check(f)\n    } else {\n        quote {}\n    };\n\n    // All private functions perform message discovery, since they may need to access notes. This is slightly\n    // inefficient and could be improved by only doing it once we actually attempt to read any.\n    let message_discovery_call = if NOTES.len() > 0 {\n        create_message_discovery_call()\n    } else {\n        quote {}\n    };\n\n    // Finally, we need to change the return type to be `PrivateCircuitPublicInputs`, which is what the Private Kernel\n    // circuit expects.\n    let return_value_var_name = quote { macro__returned__values };\n\n    let return_value_type = f.return_type();\n    let return_value = if body.len() == 0 {\n        quote {}\n    } else if return_value_type != type_of(()) {\n        // The original return value is passed to a second args hasher which the context receives.\n        let (body_without_return, last_body_expr) = body.pop_back();\n        let return_value = last_body_expr.quoted();\n        let return_value_assignment =\n            quote { let $return_value_var_name: $return_value_type = $return_value; };\n        let return_hasher_name = quote { return_hasher };\n        let return_value_into_hasher =\n            add_to_hasher(return_hasher_name, return_value_var_name, return_value_type);\n\n        body = body_without_return;\n\n        quote {\n            let mut $return_hasher_name = dep::aztec::hash::ArgsHasher::new();\n            $return_value_assignment\n            $return_value_into_hasher\n            context.set_return_hash($return_hasher_name);\n        }\n    } else {\n        let (body_without_return, last_body_expr) = body.pop_back();\n        if !last_body_expr.has_semicolon()\n            & last_body_expr.as_for().is_none()\n            & last_body_expr.as_assert().is_none()\n            & last_body_expr.as_for_range().is_none()\n            & last_body_expr.as_assert_eq().is_none()\n            & last_body_expr.as_let().is_none() {\n            let unused_return_value_name = f\"_{return_value_var_name}\".quoted_contents();\n            body = body_without_return.push_back(\n                quote { let $unused_return_value_name = $last_body_expr; }.as_expr().unwrap(),\n            );\n        }\n        quote {}\n    };\n\n    let context_finish = quote { context.finish() };\n\n    let to_prepend = quote {\n        $args_hasher\n        $context_creation\n        $assert_initializer\n        $init_check\n        $internal_check\n        $view_check\n        $storage_init\n        $message_discovery_call\n    };\n\n    let to_append = quote {\n        $return_value\n        $mark_as_initialized\n        $context_finish\n    };\n    let modified_body = modify_fn_body(body, to_prepend, to_append);\n    f.set_body(modified_body);\n    f.set_return_type(\n        quote { dep::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs }\n            .as_type(),\n    );\n    f.set_return_data();\n\n    fn_abi\n}\n\npub(crate) comptime fn transform_public(f: FunctionDefinition) -> Quoted {\n    let fn_abi = create_fn_abi_export(f);\n    let fn_stub = stub_fn(f);\n    stub_registry::register(f.module(), fn_stub);\n\n    // If a function is further modified as unconstrained, we throw an error\n    if f.is_unconstrained() {\n        let name = f.name();\n        panic(\n            f\"Function {name} is annotated with #[public] but marked as unconstrained, remove unconstrained keyword\",\n        );\n    }\n\n    let module_has_initializer = module_has_initializer(f.module());\n    let module_has_storage = module_has_storage(f.module());\n\n    // Public functions undergo a lot of transformations from their Aztec.nr form.\n    let original_params = f.parameters();\n    let args_len = original_params\n        .map(|(name, typ): (Quoted, Type)| {\n            generate_serialize_to_fields(name, typ, &[], false).0.len()\n        })\n        .fold(0, |acc: u32, val: u32| acc + val);\n\n    // Unlike in the private case, in public the `context` does not need to receive the hash of the original params.\n    let context_creation = quote {\n        let mut context = dep::aztec::context::public_context::PublicContext::new(|| {\n        // We start from 1 because we skip the selector for the dispatch function.\n        let serialized_args : [Field; $args_len] = dep::aztec::context::public_context::calldata_copy(1, $args_len);\n        dep::aztec::hash::hash_args_array(serialized_args)\n        });\n    };\n\n    // Modifications introduced by the different marker attributes.\n    let internal_check = if is_fn_internal(f) {\n        create_internal_check(f)\n    } else {\n        quote {}\n    };\n\n    let view_check = if is_fn_view(f) {\n        create_view_check(f)\n    } else {\n        quote {}\n    };\n\n    let (assert_initializer, mark_as_initialized) = if is_fn_initializer(f) {\n        (create_assert_correct_initializer_args(f), create_mark_as_initialized(f))\n    } else {\n        (quote {}, quote {})\n    };\n\n    let storage_init = if module_has_storage {\n        // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n        // referenced. We instead ignore 'unused variable' warnings for it.\n        quote {\n            #[allow(unused_variables)]\n            let storage = Storage::init(&mut context);\n        }\n    } else {\n        quote {}\n    };\n\n    // Initialization checks are not included in contracts that don't have initializers.\n    let init_check = if module_has_initializer & !fn_has_noinitcheck(f) & !is_fn_initializer(f) {\n        create_init_check(f)\n    } else {\n        quote {}\n    };\n\n    let to_prepend = quote {\n        $context_creation\n        $assert_initializer\n        $init_check\n        $internal_check\n        $view_check\n        $storage_init\n    };\n\n    let to_append = quote {\n        $mark_as_initialized\n    };\n\n    let body = f.body().as_block().unwrap();\n    let modified_body = modify_fn_body(body, to_prepend, to_append);\n    f.set_body(modified_body);\n\n    // All public functions are automatically made unconstrained, even if they were not marked as such. This is because\n    // instead of compiling into a circuit, they will compile to bytecode that will be later transpiled into AVM\n    // bytecode.\n    f.set_unconstrained(true);\n    f.set_return_public(true);\n\n    fn_abi\n}\n\npub(crate) comptime fn transform_utility(f: FunctionDefinition) {\n    // Check if function is marked as unconstrained\n    if !f.is_unconstrained() {\n        let name = f.name();\n        panic(\n            f\"Function {name} is annotated with #[utility] but not marked as unconstrained, add unconstrained keyword\",\n        );\n    }\n\n    // Create utility context\n    let context_creation =\n        quote { let mut context = dep::aztec::context::utility_context::UtilityContext::new(); };\n    let module_has_storage = module_has_storage(f.module());\n\n    // Initialize Storage if module has storage\n    let storage_init = if module_has_storage {\n        quote {\n            // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n            // referenced. We instead ignore 'unused variable' warnings for it.\n            #[allow(unused_variables)]\n            let storage = Storage::init(context);\n        }\n    } else {\n        quote {}\n    };\n\n    // All utility functions perform message discovery, since they may need to access private notes that would be\n    // found during this process. This is slightly inefficient and could be improved by only doing it once we actually\n    // attempt to read any.\n    let message_discovery_call = if NOTES.len() > 0 {\n        create_message_discovery_call()\n    } else {\n        quote {}\n    };\n\n    // Inject context creation, storage initialization, and message discovery call at the beginning of the function\n    // body.\n    let to_prepend = quote {\n        $context_creation\n        $storage_init\n        $message_discovery_call\n    };\n    let body = f.body().as_block().unwrap();\n    let modified_body = modify_fn_body(body, to_prepend, quote {});\n    f.set_body(modified_body);\n\n    f.set_return_public(true);\n}\n\ncomptime fn create_internal_check(f: FunctionDefinition) -> Quoted {\n    let name = f.name();\n    let assertion_message = f\"Function {name} can only be called internally\";\n    quote { assert(context.msg_sender() == context.this_address(), $assertion_message); }\n}\n\ncomptime fn create_view_check(f: FunctionDefinition) -> Quoted {\n    let name = f.name();\n    let assertion_message = f\"Function {name} can only be called statically\";\n    if is_fn_private(f) {\n        // Here `context` is of type context::PrivateContext\n        quote { assert(context.inputs.call_context.is_static_call == true, $assertion_message); }\n    } else {\n        // Here `context` is of type context::PublicContext\n        quote { assert(context.is_static_call(), $assertion_message); }\n    }\n}\n\ncomptime fn create_assert_correct_initializer_args(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::assert_initialization_matches_address_preimage_{fn_visibility}(context);\"\n        .quoted_contents()\n}\n\ncomptime fn create_mark_as_initialized(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::mark_as_initialized_{fn_visibility}(&mut context);\"\n        .quoted_contents()\n}\n\ncomptime fn create_init_check(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::assert_is_initialized_{fn_visibility}(&mut context);\"\n        .quoted_contents()\n}\n\n/// Injects a call to `aztec::messages::discovery::discover_new_messages`, causing for new notes to be added to PXE and made\n/// available for the current execution.\npub(crate) comptime fn create_message_discovery_call() -> Quoted {\n    quote {\n        /// Safety: message discovery returns nothing and is performed solely for its side-effects. It is therefore\n        /// always safe to call.\n        unsafe {\n            dep::aztec::messages::discovery::discover_new_messages(\n                context.this_address(),\n                _compute_note_hash_and_nullifier,\n            );\n        };\n    }\n}\n\n/// Checks if each function in the module is marked with either #[private], #[public], #[utility],\n/// #[contract_library_method], or #[test]. Non-macroified functions are not allowed in contracts.\npub(crate) comptime fn check_each_fn_macroified(m: Module) {\n    for f in m.functions() {\n        let name = f.name();\n        if !is_fn_private(f)\n            & !is_fn_public(f)\n            & !is_fn_utility(f)\n            & !is_fn_contract_library_method(f)\n            & !is_fn_test(f) {\n            panic(\n                f\"Function {name} must be marked as either #[private], #[public], #[utility], #[contract_library_method], or #[test]\",\n            );\n        }\n    }\n}\n","path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.2/noir-projects/aztec-nr/aztec/src/macros/functions/utils.nr"},"99":{"source":"use poseidon::poseidon2::Poseidon2Hasher;\nuse std::{collections::umap::UHashMap, hash::BuildHasherDefault};\n\nuse super::utils::AsStrQuote;\nuse super::utils::get_storage_size;\nuse super::utils::is_note;\n\n/// Stores a map from a module to the name of the struct that describes its storage layout.\n/// This is then used when generating a `storage_layout()` getter on the contract struct.\npub comptime mut global STORAGE_LAYOUT_NAME: UHashMap<Module, Quoted, BuildHasherDefault<Poseidon2Hasher>> =\n    UHashMap::default();\n\n/// Marks a struct as the one describing the storage layout of a contract. Only a single struct in the entire contract\n/// should have this macro (or `storage_no_init`) applied to it.\n/// The contract's storage is accessed via the `storage` variable, which will will automatically be made available in\n/// all functions as an instance of the struct this macro was applied to.\npub comptime fn storage(s: TypeDefinition) -> Quoted {\n    // This macro performs three things:\n    //  - it marks the contract as having storage, so that `macros::utils::module_has_storage` will return true and\n    //    functions will have the storage variable injected and initialized via the `init` function.\n    //  - it implements said `init` function by allocating appropriate storage slots to each state variable.\n    //  - it exposes the storage layout by creating a `StorageLayout` struct that is exposed via the `abi(storage)`\n    //    macro.\n    let mut slot: u32 = 1;\n    let mut storage_vars_constructors = &[];\n    let mut storage_layout_fields = &[];\n    let mut storage_layout_constructors = &[];\n\n    // TODO(#8658): uncomment the code below to inject the Context type parameter.\n    //let mut new_storage_fields = &[];\n    //let context_generic = s.add_generic(\"Context\");\n    for field in s.fields_as_written() {\n        // FIXME: This doesn't handle field types with generics\n        let (name, typ) = field;\n        let (storage_field_constructor, storage_size) =\n            generate_storage_field_constructor(typ, quote { $slot }, false);\n        storage_vars_constructors =\n            storage_vars_constructors.push_back(quote { $name: $storage_field_constructor });\n        // We have `Storable` in a separate `.nr` file instead of defining it in the last quote of this function\n        // because that way a dev gets a more reasonable error if he defines a struct with the same name in\n        // a contract.\n        storage_layout_fields =\n            storage_layout_fields.push_back(quote { pub $name: dep::aztec::prelude::Storable });\n        storage_layout_constructors = storage_layout_constructors.push_back(\n            quote { $name: dep::aztec::prelude::Storable { slot: $slot } },\n        );\n        //let with_context_generic = add_context_generic(typ, context_generic);\n        //println(with_context_generic);\n        //new_storage_fields = new_storage_fields.push_back((name,  with_context_generic ));\n        slot += storage_size;\n    }\n\n    //s.set_fields(new_storage_fields);\n    let storage_vars_constructors = storage_vars_constructors.join(quote {,});\n    let storage_impl = quote {\n        impl<Context> Storage<Context> {\n            fn init(context: Context) -> Self {\n                Self {\n                    $storage_vars_constructors\n                }\n            }\n        }\n    };\n\n    let storage_layout_fields = storage_layout_fields.join(quote {,});\n    let storage_layout_constructors = storage_layout_constructors.join(quote {,});\n\n    let module = s.module();\n    let module_name = module.name();\n    let storage_layout_name = f\"STORAGE_LAYOUT_{module_name}\".quoted_contents();\n    let (module_name_str, module_name_len) = module_name.as_str_quote();\n    STORAGE_LAYOUT_NAME.insert(module, storage_layout_name);\n\n    quote {\n        $storage_impl\n\n        pub struct StorageLayoutFields {\n            $storage_layout_fields\n        }\n\n        pub struct StorageLayout<let N: u32> {\n            pub contract_name: str<N>,\n            pub fields: StorageLayoutFields\n        }\n\n        #[abi(storage)]\n        pub global $storage_layout_name: StorageLayout<$module_name_len> = StorageLayout {\n            contract_name: $module_name_str,\n            fields: StorageLayoutFields { $storage_layout_constructors }\n        };\n    }\n}\n\n/// Same as `storage`, except the user is in charge of providing an implementation of the `init` constructor function\n/// with signature `fn init<Context>(context: Context) -> Self`, which allows for manual control of storage slot\n/// allocation. Similarly, no `StorageLayout` struct will be created.\n/// Only a single struct in the entire contract should have this macro (or `storage`) applied to it.\npub comptime fn storage_no_init(_s: TypeDefinition) {\n    // All `storage` does is provide the `init` implementation, so we don't need to do anything here. Applying this\n    // macro however will cause for `macros::utils::module_has_storage` to return true, resulting in the injection of\n    // the `storage` variable.\n}\n\n/// Returns the expression required to initialize a state variable with a given slot, along with its serialization size,\n/// i.e. how many contiguous storage slots the variable requires.\ncomptime fn generate_storage_field_constructor(\n    typ: Type,\n    slot: Quoted,\n    parent_is_map: bool,\n) -> (Quoted, u32) {\n    assert(\n        typ.as_data_type().is_some(),\n        \"Storage containers must be generic structs of the form `Container<_, Context>`, or Map<Key, _, Context>\",\n    );\n    let (container_struct, generics) = typ.as_data_type().unwrap();\n    let struct_name = container_struct.name();\n\n    if is_storage_map(typ) {\n        // Map state variables recursively initialize their contents - this includes nested maps.\n        let (value_constructor, _) =\n            generate_storage_field_constructor(generics[1], quote { slot }, true);\n        (quote { $struct_name::new(context, $slot, | context, slot | { $value_constructor }) }, 1)\n    } else {\n        let storage_size = if parent_is_map {\n            // Variables inside a map do not require contiguous slots since the map slot derivation is assumed to result\n            // in slots very far away from one another.\n            1\n        } else {\n            let (_, container_struct_generics) = typ.as_data_type().unwrap();\n            let stored_struct = container_struct_generics[0];\n\n            if is_note(stored_struct) {\n                // Private notes always occupy a single slot, since the slot is only used as a state variable\n                // identifier.\n                1\n            } else {\n                get_storage_size(typ)\n            }\n        };\n\n        // We assume below that all state variables implement `fn new<Context>(context: Context, slot: Field) -> Self`.\n        (quote { $struct_name::new(context, $slot)}, storage_size)\n    }\n}\n\n/// Returns true if `typ` is `state_vars::map::Map`.\ncomptime fn is_storage_map(typ: Type) -> bool {\n    if typ.as_data_type().is_some() {\n        let (def, generics) = typ.as_data_type().unwrap();\n        let maybe_map = if (def.name() == quote { Map }) & (generics.len() == 3) {\n            let maybe_key = generics[0];\n            let maybe_value = generics[1];\n            let maybe_context = generics[2];\n            quote { crate::state_vars::map::Map<$maybe_key, $maybe_value, $maybe_context> }.as_type()\n        } else {\n            quote {()}.as_type()\n        };\n        typ == maybe_map\n    } else {\n        false\n    }\n}\n\ncomptime fn add_context_generic(typ: Type, context_generic: Type) -> Type {\n    let (def, mut generics) = typ.as_data_type().expect(\n        f\"Storage containers must be generic structs of the form `Container<..., Context>`\",\n    );\n    let name = def.name();\n\n    if is_storage_map(typ) {\n        generics[generics.len() - 2] = add_context_generic(generics[1], context_generic);\n        generics[generics.len() - 1] = context_generic;\n    } else {\n        generics[generics.len() - 1] = context_generic;\n    }\n\n    let generics = generics.map(|typ: Type| quote {$typ}).join(quote {,});\n    quote { $name<$generics> }.as_type()\n}\n","path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.2/noir-projects/aztec-nr/aztec/src/macros/storage.nr"},"137":{"source":"use dep::protocol_types::address::AztecAddress;\n\n#[oracle(notifyEnqueuedPublicFunctionCall)]\nunconstrained fn notify_enqueued_public_function_call_oracle(\n    _contract_address: AztecAddress,\n    _calldata_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n) {}\n\nunconstrained fn notify_enqueued_public_function_call_wrapper(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    notify_enqueued_public_function_call_oracle(\n        contract_address,\n        calldata_hash,\n        side_effect_counter,\n        is_static_call,\n    )\n}\n\npub fn notify_enqueued_public_function_call(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    // Safety: Notifies the simulator that a public call has been enqueued, allowing it to prepare hints for the AVM to process this call.\n    unsafe {\n        notify_enqueued_public_function_call_wrapper(\n            contract_address,\n            calldata_hash,\n            side_effect_counter,\n            is_static_call,\n        )\n    }\n}\n\n#[oracle(notifySetPublicTeardownFunctionCall)]\nunconstrained fn notify_set_public_teardown_function_call_oracle(\n    _contract_address: AztecAddress,\n    _calldata_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n) {}\n\nunconstrained fn notify_set_public_teardown_function_call_wrapper(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    notify_set_public_teardown_function_call_oracle(\n        contract_address,\n        calldata_hash,\n        side_effect_counter,\n        is_static_call,\n    )\n}\n\npub fn notify_set_public_teardown_function_call(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    // Safety: Notifies the simulator that a teardown call has been set, allowing it to prepare hints for the AVM to process this call.\n    unsafe {\n        notify_set_public_teardown_function_call_wrapper(\n            contract_address,\n            calldata_hash,\n            side_effect_counter,\n            is_static_call,\n        )\n    }\n}\n\npub fn notify_set_min_revertible_side_effect_counter(counter: u32) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter) };\n}\n\npub unconstrained fn notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter: u32) {\n    notify_set_min_revertible_side_effect_counter_oracle(counter);\n}\n\n#[oracle(notifySetMinRevertibleSideEffectCounter)]\nunconstrained fn notify_set_min_revertible_side_effect_counter_oracle(_counter: u32) {}\n","path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.2/noir-projects/aztec-nr/aztec/src/oracle/enqueue_public_function_call.nr"},"138":{"source":"use dep::protocol_types::address::AztecAddress;\n\n#[oracle(getContractAddress)]\nunconstrained fn get_contract_address_oracle() -> AztecAddress {}\n\n#[oracle(getBlockNumber)]\nunconstrained fn get_block_number_oracle() -> u32 {}\n\n#[oracle(getChainId)]\nunconstrained fn get_chain_id_oracle() -> Field {}\n\n#[oracle(getVersion)]\nunconstrained fn get_version_oracle() -> Field {}\n\npub unconstrained fn get_contract_address() -> AztecAddress {\n    get_contract_address_oracle()\n}\n\npub unconstrained fn get_block_number() -> u32 {\n    get_block_number_oracle()\n}\n\npub unconstrained fn get_chain_id() -> Field {\n    get_chain_id_oracle()\n}\n\npub unconstrained fn get_version() -> Field {\n    get_version_oracle()\n}\n","path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.2/noir-projects/aztec-nr/aztec/src/oracle/execution.nr"},"139":{"source":"/// Stores values represented as slice in execution cache to be later obtained by its hash.\npub fn store(values: [Field], hash: Field) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call. When loading the values, however, the caller must check that the values are indeed the preimage.\n    unsafe { store_in_execution_cache_oracle_wrapper(values, hash) };\n}\n\nunconstrained fn store_in_execution_cache_oracle_wrapper(values: [Field], hash: Field) {\n    store_in_execution_cache_oracle(values, hash);\n}\n\npub unconstrained fn load<let N: u32>(hash: Field) -> [Field; N] {\n    load_from_execution_cache_oracle(hash)\n}\n\n#[oracle(storeInExecutionCache)]\nunconstrained fn store_in_execution_cache_oracle(_values: [Field], _hash: Field) {}\n\n#[oracle(loadFromExecutionCache)]\nunconstrained fn load_from_execution_cache_oracle<let N: u32>(_hash: Field) -> [Field; N] {}\n","path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.2/noir-projects/aztec-nr/aztec/src/oracle/execution_cache.nr"},"140":{"source":"use protocol_types::{\n    address::AztecAddress, contract_class_id::ContractClassId, contract_instance::ContractInstance,\n    traits::FromField,\n};\n\n// NOTE: this is for use in private only\n#[oracle(getContractInstance)]\nunconstrained fn get_contract_instance_oracle(_address: AztecAddress) -> ContractInstance {}\n\n// NOTE: this is for use in private only\nunconstrained fn get_contract_instance_internal(address: AztecAddress) -> ContractInstance {\n    get_contract_instance_oracle(address)\n}\n\n// NOTE: this is for use in private only\npub fn get_contract_instance(address: AztecAddress) -> ContractInstance {\n    // Safety: The to_address function combines all values in the instance object to produce an address,\n    // so by checking that we get the expected address we validate the entire struct.\n    let instance = unsafe { get_contract_instance_internal(address) };\n    assert_eq(instance.to_address(), address);\n\n    instance\n}\n\n// These oracles each return a ContractInstance member\n// plus a boolean indicating whether the instance was found.\n#[oracle(avmOpcodeGetContractInstanceDeployer)]\nunconstrained fn get_contract_instance_deployer_oracle_avm(\n    _address: AztecAddress,\n) -> (Field, bool) {}\n#[oracle(avmOpcodeGetContractInstanceClassId)]\nunconstrained fn get_contract_instance_class_id_oracle_avm(\n    _address: AztecAddress,\n) -> (Field, bool) {}\n#[oracle(avmOpcodeGetContractInstanceInitializationHash)]\nunconstrained fn get_contract_instance_initialization_hash_oracle_avm(\n    _address: AztecAddress,\n) -> (Field, bool) {}\n\npub unconstrained fn get_contract_instance_deployer_internal_avm(\n    address: AztecAddress,\n) -> (Field, bool) {\n    get_contract_instance_deployer_oracle_avm(address)\n}\npub unconstrained fn get_contract_instance_class_id_internal_avm(\n    address: AztecAddress,\n) -> (Field, bool) {\n    get_contract_instance_class_id_oracle_avm(address)\n}\npub unconstrained fn get_contract_instance_initialization_hash_internal_avm(\n    address: AztecAddress,\n) -> (Field, bool) {\n    get_contract_instance_initialization_hash_oracle_avm(address)\n}\n\npub fn get_contract_instance_deployer_avm(address: AztecAddress) -> Option<AztecAddress> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let (member, exists) = unsafe { get_contract_instance_deployer_internal_avm(address) };\n    if exists {\n        Option::some(AztecAddress::from_field(member))\n    } else {\n        Option::none()\n    }\n}\npub fn get_contract_instance_class_id_avm(address: AztecAddress) -> Option<ContractClassId> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let (member, exists) = unsafe { get_contract_instance_class_id_internal_avm(address) };\n    if exists {\n        Option::some(ContractClassId::from_field(member))\n    } else {\n        Option::none()\n    }\n}\npub fn get_contract_instance_initialization_hash_avm(address: AztecAddress) -> Option<Field> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let (member, exists) =\n        unsafe { get_contract_instance_initialization_hash_internal_avm(address) };\n    if exists {\n        Option::some(member)\n    } else {\n        Option::none()\n    }\n}\n","path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.2/noir-projects/aztec-nr/aztec/src/oracle/get_contract_instance.nr"},"155":{"source":"use crate::state_vars::storage::Storage;\nuse dep::protocol_types::{storage::map::derive_storage_slot_in_map, traits::{Packable, ToField}};\n\n// docs:start:map\npub struct Map<K, V, Context> {\n    context: Context,\n    storage_slot: Field,\n    state_var_constructor: fn(Context, Field) -> V,\n}\n// docs:end:map\n\nimpl<K, T, Context, let N: u32> Storage<N> for Map<K, T, Context>\nwhere\n    T: Packable<N>,\n{\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<K, V, Context> Map<K, V, Context> {\n    // docs:start:new\n    pub fn new(\n        context: Context,\n        storage_slot: Field,\n        state_var_constructor: fn(Context, Field) -> V,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Map { context, storage_slot, state_var_constructor }\n    }\n    // docs:end:new\n\n    // docs:start:at\n    pub fn at(self, key: K) -> V\n    where\n        K: ToField,\n    {\n        // TODO(#1204): use a generator index for the storage slot\n        let derived_storage_slot = derive_storage_slot_in_map(self.storage_slot, key);\n\n        let state_var_constructor = self.state_var_constructor;\n        state_var_constructor(self.context, derived_storage_slot)\n    }\n    // docs:end:at\n}\n","path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.2/noir-projects/aztec-nr/aztec/src/state_vars/map.nr"},"164":{"source":"use crate::context::{PublicContext, UtilityContext};\nuse crate::state_vars::storage::Storage;\nuse dep::protocol_types::traits::Packable;\n\n// docs:start:public_mutable_struct\npub struct PublicMutable<T, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:public_mutable_struct\n\nimpl<T, Context, let N: u32> Storage<N> for PublicMutable<T, Context>\nwhere\n    T: Packable<N>,\n{\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<T, Context> PublicMutable<T, Context> {\n    // docs:start:public_mutable_struct_new\n    pub fn new(\n        // Note: Passing the contexts to new(...) just to have an interface compatible with a Map.\n        context: Context,\n        storage_slot: Field,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PublicMutable { context, storage_slot }\n    }\n    // docs:end:public_mutable_struct_new\n}\n\nimpl<T> PublicMutable<T, &mut PublicContext> {\n    // docs:start:public_mutable_struct_read\n    pub fn read<let T_PACKED_LEN: u32>(self) -> T\n    where\n        T: Packable<T_PACKED_LEN>,\n    {\n        self.context.storage_read(self.storage_slot)\n    }\n    // docs:end:public_mutable_struct_read\n\n    // docs:start:public_mutable_struct_write\n    pub fn write<let T_PACKED_LEN: u32>(self, value: T)\n    where\n        T: Packable<T_PACKED_LEN>,\n    {\n        self.context.storage_write(self.storage_slot, value);\n    }\n    // docs:end:public_mutable_struct_write\n}\n\nimpl<T> PublicMutable<T, UtilityContext> {\n    pub unconstrained fn read<let T_PACKED_LEN: u32>(self) -> T\n    where\n        T: Packable<T_PACKED_LEN>,\n    {\n        self.context.storage_read(self.storage_slot)\n    }\n}\n","path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.2/noir-projects/aztec-nr/aztec/src/state_vars/public_mutable.nr"},"219":{"source":"use crate::traits::{Deserialize, Empty, FromField, Serialize, ToField};\n\npub struct FunctionSelector {\n    // 1st 4-bytes of abi-encoding of function.\n    pub inner: u32,\n}\n\nimpl Eq for FunctionSelector {\n    fn eq(self, function_selector: FunctionSelector) -> bool {\n        function_selector.inner == self.inner\n    }\n}\n\nimpl Serialize<1> for FunctionSelector {\n    fn serialize(self: Self) -> [Field; 1] {\n        [self.inner as Field]\n    }\n}\n\nimpl Deserialize<1> for FunctionSelector {\n    fn deserialize(fields: [Field; 1]) -> Self {\n        Self { inner: fields[0] as u32 }\n    }\n}\n\nimpl FromField for FunctionSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for FunctionSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for FunctionSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl FunctionSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = crate::hash::poseidon2_hash_bytes(bytes);\n\n        // `hash` is automatically truncated to fit within 32 bits.\n        FunctionSelector::from_field(hash)\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n\n#[test]\nfn test_is_valid_selector() {\n    let selector = FunctionSelector::from_signature(\"IS_VALID()\");\n    assert_eq(selector.to_field(), 0x73cdda47);\n}\n\n#[test]\nfn test_long_selector() {\n    let selector =\n        FunctionSelector::from_signature(\"foo_and_bar_and_baz_and_foo_bar_baz_and_bar_foo\");\n    assert_eq(selector.to_field(), 0x7590a997);\n}\n","path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.2/noir-projects/noir-protocol-circuits/crates/types/src/abis/function_selector.nr"},"262":{"source":"use crate::{\n    address::{\n        partial_address::PartialAddress, salted_initialization_hash::SaltedInitializationHash,\n    },\n    constants::{\n        AZTEC_ADDRESS_LENGTH, GENERATOR_INDEX__CONTRACT_ADDRESS_V1, MAX_FIELD_VALUE,\n        MAX_PROTOCOL_CONTRACTS,\n    },\n    contract_class_id::ContractClassId,\n    hash::poseidon2_hash_with_separator,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, ToPoint, TpkM},\n    traits::{Deserialize, Empty, FromField, Packable, Serialize, ToField},\n    utils::field::{pow, sqrt},\n};\n\n// We do below because `use crate::point::Point;` does not work\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\n\nuse crate::public_keys::AddressPoint;\nuse std::{\n    embedded_curve_ops::{EmbeddedCurveScalar, fixed_base_scalar_mul as derive_public_key},\n    ops::Add,\n};\n\n// Aztec address\npub struct AztecAddress {\n    pub inner: Field,\n}\n\nimpl Eq for AztecAddress {\n    fn eq(self, other: Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self { inner: 0 }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for AztecAddress {\n    fn from_field(value: Field) -> AztecAddress {\n        AztecAddress { inner: value }\n    }\n}\n\nimpl Serialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn serialize(self: Self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn deserialize(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        FromField::from_field(fields[0])\n    }\n}\n\n/// We implement the Packable trait for AztecAddress because it can be stored in contract's storage (and there\n/// the implementation of Packable is required).\nimpl Packable<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn pack(self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        self.serialize()\n    }\n\n    fn unpack(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        Self::deserialize(fields)\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn to_address_point(self) -> AddressPoint {\n        // We compute the address point by taking our address, setting it to x, and then solving for y in the\n        // equation which defines our bn curve:\n        // y^2 = x^3 - 17; x = address\n        let x = self.inner;\n        let y_squared = pow(x, 3) - 17;\n\n        // TODO (#8970): Handle cases where we cannot recover a point from an address\n        let mut y = sqrt(y_squared);\n\n        // If we get a negative y coordinate (any y where y > MAX_FIELD_VALUE / 2), we pin it to the\n        // positive one (any value where y <= MAX_FIELD_VALUE / 2) by subtracting it from the Field modulus\n        // note: The field modulus is MAX_FIELD_VALUE + 1\n        if (!(y.lt(MAX_FIELD_VALUE / 2) | y.eq(MAX_FIELD_VALUE / 2))) {\n            y = (MAX_FIELD_VALUE + 1) - y;\n        }\n\n        AddressPoint { inner: Point { x: self.inner, y, is_infinite: false } }\n    }\n\n    pub fn compute(public_keys: PublicKeys, partial_address: PartialAddress) -> AztecAddress {\n        let public_keys_hash = public_keys.hash();\n\n        let pre_address = poseidon2_hash_with_separator(\n            [public_keys_hash.to_field(), partial_address.to_field()],\n            GENERATOR_INDEX__CONTRACT_ADDRESS_V1,\n        );\n\n        let address_point = derive_public_key(EmbeddedCurveScalar::from_field(pre_address)).add(\n            public_keys.ivpk_m.to_point(),\n        );\n\n        // Note that our address is only the x-coordinate of the full address_point. This is okay because when people want to encrypt something and send it to us\n        // they can recover our full point using the x-coordinate (our address itself). To do this, they recompute the y-coordinate according to the equation y^2 = x^3 - 17.\n        // When they do this, they may get a positive y-coordinate (a value that is less than or equal to MAX_FIELD_VALUE / 2) or\n        // a negative y-coordinate (a value that is more than MAX_FIELD_VALUE), and we cannot dictate which one they get and hence the recovered point may sometimes be different than the one\n        // our secret can decrypt. Regardless though, they should and will always encrypt using point with the positive y-coordinate by convention.\n        // This ensures that everyone encrypts to the same point given an arbitrary x-coordinate (address). This is allowed because even though our original point may not have a positive y-coordinate,\n        // with our original secret, we will be able to derive the secret to the point with the flipped (and now positive) y-coordinate that everyone encrypts to.\n        AztecAddress::from_field(address_point.x)\n    }\n\n    pub fn compute_from_class_id(\n        contract_class_id: ContractClassId,\n        salted_initialization_hash: SaltedInitializationHash,\n        public_keys: PublicKeys,\n    ) -> Self {\n        let partial_address = PartialAddress::compute_from_salted_initialization_hash(\n            contract_class_id,\n            salted_initialization_hash,\n        );\n\n        AztecAddress::compute(public_keys, partial_address)\n    }\n\n    pub fn is_protocol_contract(self) -> bool {\n        self.inner.lt(MAX_PROTOCOL_CONTRACTS as Field)\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n\n#[test]\nfn compute_address_from_partial_and_pub_keys() {\n    let public_keys = PublicKeys {\n        npk_m: NpkM {\n            inner: Point {\n                x: 0x22f7fcddfa3ce3e8f0cc8e82d7b94cdd740afa3e77f8e4a63ea78a239432dcab,\n                y: 0x0471657de2b6216ade6c506d28fbc22ba8b8ed95c871ad9f3e3984e90d9723a7,\n                is_infinite: false,\n            },\n        },\n        ivpk_m: IvpkM {\n            inner: Point {\n                x: 0x111223493147f6785514b1c195bb37a2589f22a6596d30bb2bb145fdc9ca8f1e,\n                y: 0x273bbffd678edce8fe30e0deafc4f66d58357c06fd4a820285294b9746c3be95,\n                is_infinite: false,\n            },\n        },\n        ovpk_m: OvpkM {\n            inner: Point {\n                x: 0x09115c96e962322ffed6522f57194627136b8d03ac7469109707f5e44190c484,\n                y: 0x0c49773308a13d740a7f0d4f0e6163b02c5a408b6f965856b6a491002d073d5b,\n                is_infinite: false,\n            },\n        },\n        tpk_m: TpkM {\n            inner: Point {\n                x: 0x00d3d81beb009873eb7116327cf47c612d5758ef083d4fda78e9b63980b2a762,\n                y: 0x2f567d22d2b02fe1f4ad42db9d58a36afd1983e7e2909d1cab61cafedad6193a,\n                is_infinite: false,\n            },\n        },\n    };\n\n    let partial_address = PartialAddress::from_field(\n        0x0a7c585381b10f4666044266a02405bf6e01fa564c8517d4ad5823493abd31de,\n    );\n\n    let address = AztecAddress::compute(public_keys, partial_address);\n\n    // The following value was generated by `derivation.test.ts`.\n    // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n    let expected_computed_address_from_partial_and_pubkeys =\n        0x24e4646f58b9fbe7d38e317db8d5636c423fbbdfbe119fc190fe9c64747e0c62;\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkeys);\n}\n\n#[test]\nfn compute_preaddress_from_partial_and_pub_keys() {\n    let pre_address = poseidon2_hash_with_separator([1, 2], GENERATOR_INDEX__CONTRACT_ADDRESS_V1);\n    let expected_computed_preaddress_from_partial_and_pubkey =\n        0x23ce9be3fa3c846b0f9245cc796902e731d04f086e8a42473bb29e405fc98075;\n    assert(pre_address == expected_computed_preaddress_from_partial_and_pubkey);\n}\n\n#[test]\nfn from_field_to_field() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(FromField::from_field(address.to_field()), address);\n}\n\n#[test]\nfn serde() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(Deserialize::deserialize(address.serialize()), address);\n}\n","path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.2/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr"},"280":{"source":"use crate::{\n    abis::{\n        contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n        contract_class_log::ContractClassLog,\n        function_selector::FunctionSelector,\n        note_hash::ScopedNoteHash,\n        nullifier::ScopedNullifier,\n        private_log::{PrivateLog, PrivateLogData},\n        side_effect::{OrderedValue, scoped::Scoped},\n    },\n    address::{AztecAddress, EthAddress},\n    constants::{\n        FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__NOTE_HASH_NONCE, GENERATOR_INDEX__OUTER_NULLIFIER,\n        GENERATOR_INDEX__SILOED_NOTE_HASH, GENERATOR_INDEX__UNIQUE_NOTE_HASH, TWO_POW_64,\n    },\n    merkle_tree::root::root_from_sibling_path,\n    messaging::l2_to_l1_message::{L2ToL1Message, ScopedL2ToL1Message},\n    poseidon2::Poseidon2Sponge,\n    traits::{FromField, Hash, ToField},\n    utils::{\n        arrays::{array_concat, unsafe_padded_array_length},\n        field::{field_from_bytes, field_from_bytes_32_trunc},\n    },\n};\n\npub fn sha256_to_field<let N: u32>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = sha256::digest(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT],\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(\n        function_leaf,\n        function_leaf_index,\n        function_leaf_sibling_path,\n    )\n}\n\npub fn compute_note_hash_nonce(first_nullifier_in_tx: Field, note_index_in_tx: u32) -> Field {\n    // Hashing the first nullifier with note index in tx is guaranteed to be unique (because all nullifiers are also\n    // unique).\n    poseidon2_hash_with_separator(\n        [first_nullifier_in_tx, note_index_in_tx as Field],\n        GENERATOR_INDEX__NOTE_HASH_NONCE,\n    )\n}\n\npub fn compute_unique_note_hash(nonce: Field, siloed_note_hash: Field) -> Field {\n    let inputs = [nonce, siloed_note_hash];\n    poseidon2_hash_with_separator(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\npub fn compute_siloed_note_hash(app: AztecAddress, note_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), note_hash],\n        GENERATOR_INDEX__SILOED_NOTE_HASH,\n    )\n}\n\n/// Computes unique note hashes from siloed note hashes\npub fn compute_unique_siloed_note_hash(\n    siloed_note_hash: Field,\n    first_nullifier: Field,\n    note_index_in_tx: u32,\n) -> Field {\n    if siloed_note_hash == 0 {\n        0\n    } else {\n        let nonce = compute_note_hash_nonce(first_nullifier, note_index_in_tx);\n        compute_unique_note_hash(nonce, siloed_note_hash)\n    }\n}\n\n/// Siloing in the context of Aztec refers to the process of hashing a note hash with a contract address (this way\n/// the note hash is scoped to a specific contract). This is used to prevent intermingling of notes between contracts.\npub fn silo_note_hash(note_hash: ScopedNoteHash) -> Field {\n    if note_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_note_hash(note_hash.contract_address, note_hash.value())\n    }\n}\n\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), nullifier],\n        GENERATOR_INDEX__OUTER_NULLIFIER,\n    )\n}\n\npub fn silo_nullifier(nullifier: ScopedNullifier) -> Field {\n    if nullifier.contract_address.is_zero() {\n        nullifier.value() // Return value instead of 0 because the first nullifier's contract address is zero.\n    } else {\n        compute_siloed_nullifier(nullifier.contract_address, nullifier.value())\n    }\n}\n\npub fn compute_siloed_private_log_field(contract_address: AztecAddress, field: Field) -> Field {\n    poseidon2_hash([contract_address.to_field(), field])\n}\n\npub fn silo_private_log(private_log: Scoped<PrivateLogData>) -> PrivateLog {\n    if private_log.contract_address.is_zero() {\n        private_log.inner.log\n    } else {\n        let mut fields = private_log.inner.log.fields;\n        fields[0] = compute_siloed_private_log_field(private_log.contract_address, fields[0]);\n        PrivateLog { fields }\n    }\n}\n\nfn compute_siloed_contract_class_log_field(\n    contract_address: AztecAddress,\n    first_field: Field,\n) -> Field {\n    poseidon2_hash([contract_address.to_field(), first_field])\n}\n\npub fn silo_contract_class_log(contract_class_log: ContractClassLog) -> ContractClassLog {\n    if contract_class_log.contract_address.is_zero() {\n        contract_class_log\n    } else {\n        let mut log = contract_class_log;\n        log.log.fields[0] = compute_siloed_contract_class_log_field(\n            contract_class_log.contract_address,\n            log.log.fields[0],\n        );\n        log\n    }\n}\n\npub fn compute_contract_class_log_hash(contract_class_log: ContractClassLog) -> Field {\n    let array = contract_class_log.log.fields;\n    // Safety: The below length is constrained in the base rollup.\n    let length = unsafe { unsafe_padded_array_length(array) };\n    if length == 0 {\n        0\n    } else {\n        poseidon2_hash(array)\n    }\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    poseidon2_hash([left, right])\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    recipient: EthAddress,\n    content: Field,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    let mut bytes: [u8; 160] = std::mem::zeroed();\n\n    let inputs =\n        [contract_address.to_field(), rollup_version_id, recipient.to_field(), chain_id, content];\n    for i in 0..5 {\n        // TODO are bytes be in fr.to_buffer() ?\n        let item_bytes: [u8; 32] = inputs[i].to_be_bytes();\n        for j in 0..32 {\n            bytes[32 * i + j] = item_bytes[j];\n        }\n    }\n\n    sha256_to_field(bytes)\n}\n\npub fn silo_l2_to_l1_message(\n    msg: ScopedL2ToL1Message,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    if msg.contract_address.is_zero() {\n        0\n    } else {\n        compute_l2_to_l1_hash(\n            msg.contract_address,\n            msg.message.recipient,\n            msg.message.content,\n            rollup_version_id,\n            chain_id,\n        )\n    }\n}\n\n// Computes sha256 hash of 2 input hashes.\n//\n// NB: This method now takes in two 31 byte fields - it assumes that any input\n// is the result of a sha_to_field hash and => is truncated\n//\n// TODO(Jan and David): This is used for the encrypted_log hashes.\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\n//\npub fn accumulate_sha256(input: [Field; 2]) -> Field {\n    // This is a note about the cpp code, since it takes an array of Fields\n    // instead of a u128.\n    // 4 Field elements when converted to bytes will usually\n    // occupy 4 * 32 = 128 bytes.\n    // However, this function is making the assumption that each Field\n    // only occupies 128 bits.\n    //\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\n    // Concatentate two fields into 32x2 = 64 bytes\n    // accumulate_sha256 assumes that the inputs are pre-truncated 31 byte numbers\n    let mut hash_input_flattened = [0; 64];\n    for offset in 0..input.len() {\n        let input_as_bytes: [u8; 32] = input[offset].to_be_bytes();\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n\n    sha256_to_field(hash_input_flattened)\n}\n\npub fn verification_key_hash<let N: u32>(key: [Field; N]) -> Field {\n    crate::hash::poseidon2_hash(key)\n}\n\n#[inline_always]\npub fn pedersen_hash<let N: u32>(inputs: [Field; N], hash_index: u32) -> Field {\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<let N: u32>(inputs: [Field; N]) -> Field {\n    std::hash::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[no_predicates]\npub fn poseidon2_hash_with_separator<let N: u32, T>(inputs: [Field; N], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let inputs_with_separator = array_concat([separator.to_field()], inputs);\n    poseidon2_hash(inputs_with_separator)\n}\n\n// Performs a fixed length hash with a subarray of the given input.\n// Useful for SpongeBlob in which we aborb M things and want to check it vs a hash of M elts of an N-len array.\n// Using stdlib poseidon, this will always absorb an extra 1 as a 'variable' hash, and not match spongeblob.squeeze()\n// or any ts implementation. Also checks that any remaining elts not hashed are empty.\n#[no_predicates]\npub fn poseidon2_hash_subarray<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_chunks(input, in_len, false);\n    sponge.squeeze()\n}\n\n// NB the below is the same as std::hash::poseidon2::Poseidon2::hash(), but replacing a range check with a bit check,\n// and absorbing in chunks of 3 below.\n#[no_predicates]\npub fn poseidon2_cheaper_variable_hash<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_chunks(input, in_len, true);\n    // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n    // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n    // fixed-length and variable-length hashes do not collide)\n    if in_len != N {\n        sponge.absorb(1);\n    }\n    sponge.squeeze()\n}\n\n// The below fn reduces gates of a conditional poseidon2 hash by approx 3x (thank you ~* Giant Brain Dev @IlyasRidhuan *~ for the idea)\n// Why? Because when we call stdlib poseidon, we call absorb for each item. When absorbing is conditional, it seems the compiler does not know\n// what cache_size will be when calling absorb, so it assigns the permutation gates for /each i/ rather than /every 3rd i/, which is actually required.\n// The below code forces the compiler to:\n//  - absorb normally up to 2 times to set cache_size to 1\n//  - absorb in chunks of 3 to ensure perm. only happens every 3rd absorb\n//  - absorb normally up to 2 times to add any remaining values to the hash\n// In fixed len hashes, the compiler is able to tell that it will only need to perform the permutation every 3 absorbs.\n// NB: it also replaces unnecessary range checks (i < thing) with a bit check (&= i != thing), which alone reduces the gates of a var. hash by half.\n\n#[no_predicates]\nfn poseidon2_absorb_chunks<let N: u32>(\n    input: [Field; N],\n    in_len: u32,\n    variable: bool,\n) -> Poseidon2Sponge {\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    // Even though shift is always 1 here, if we input in_len = 0 we get an underflow\n    // since we cannot isolate computation branches. The below is just to avoid that.\n    let shift = if in_len == 0 { 0 } else { 1 };\n    if in_len != 0 {\n        // cache_size = 0, init absorb\n        sponge.cache[0] = input[0];\n        sponge.cache_size = 1;\n        // shift = num elts already added to make cache_size 1 = 1 for a fresh sponge\n        // M = max_chunks = (N - 1 - (N - 1) % 3) / 3: (must be written as a fn of N to compile)\n        // max_remainder = (N - 1) % 3;\n        // max_chunks = (N - 1 - max_remainder) / 3;\n        sponge = poseidon2_absorb_chunks_loop::<N, (N - 1 - (N - 1) % 3) / 3>(\n            sponge,\n            input,\n            in_len,\n            variable,\n            shift,\n        );\n    }\n    sponge\n}\n\n// NB: If it's not required to check that the non-absorbed elts of 'input' are 0s, set skip_0_check=true\n#[no_predicates]\npub fn poseidon2_absorb_chunks_existing_sponge<let N: u32>(\n    in_sponge: Poseidon2Sponge,\n    input: [Field; N],\n    in_len: u32,\n    skip_0_check: bool,\n) -> Poseidon2Sponge {\n    let mut sponge = in_sponge;\n    // 'shift' is to account for already added inputs\n    let mut shift = 0;\n    // 'stop' is to avoid an underflow when inputting in_len = 0\n    let mut stop = false;\n    for i in 0..3 {\n        if shift == in_len {\n            stop = true;\n        }\n        if (sponge.cache_size != 1) & (!stop) {\n            sponge.absorb(input[i]);\n            shift += 1;\n        }\n    }\n    sponge = if stop {\n        sponge\n    } else {\n        // max_chunks = (N - (N % 3)) / 3;\n        poseidon2_absorb_chunks_loop::<N, (N - (N % 3)) / 3>(\n            sponge,\n            input,\n            in_len,\n            skip_0_check,\n            shift,\n        )\n    };\n    sponge\n}\n\n// The below is the loop to absorb elts into a poseidon sponge in chunks of 3\n// shift - the num of elts already absorbed to ensure the sponge's cache_size = 1\n// M - the max number of chunks required to absorb N things (must be comptime to compile)\n// NB: The 0 checks ('Found non-zero field...') are messy, but having a separate loop over N to check\n// for 0s costs 3N gates. Current approach is approx 2N gates.\n#[no_predicates]\nfn poseidon2_absorb_chunks_loop<let N: u32, let M: u32>(\n    in_sponge: Poseidon2Sponge,\n    input: [Field; N],\n    in_len: u32,\n    variable: bool,\n    shift: u32,\n) -> Poseidon2Sponge {\n    assert(in_len <= N, \"Given in_len to absorb is larger than the input array len\");\n    // When we have an existing sponge, we may have a shift of 0, and the final 'k+2' below = N\n    // The below avoids an overflow\n    let skip_last = 3 * M == N;\n    // Writing in_sponge: &mut does not compile\n    let mut sponge = in_sponge;\n    let mut should_add = true;\n    // The num of things left over after absorbing in 3s\n    let remainder = (in_len - shift) % 3;\n    // The num of chunks of 3 to absorb (maximum M)\n    let chunks = (in_len - shift - remainder) / 3;\n    for i in 0..M {\n        // Now we loop through cache size = 1 -> 3\n        should_add &= i != chunks;\n        // This is the index at the start of the chunk (for readability)\n        let k = 3 * i + shift;\n        if should_add {\n            // cache_size = 1, 2 => just assign\n            sponge.cache[1] = input[k];\n            sponge.cache[2] = input[k + 1];\n            // cache_size = 3 => duplex + perm\n            for j in 0..3 {\n                sponge.state[j] += sponge.cache[j];\n            }\n            sponge.state = std::hash::poseidon2_permutation(sponge.state, 4);\n            sponge.cache[0] = input[k + 2];\n            // cache_size is now 1 again, repeat loop\n        } else if (!variable) & (i != chunks) {\n            // if we are hashing a fixed len array which is a subarray, we check the remaining elts are 0\n            // NB: we don't check at i == chunks, because that chunk contains elts to be absorbed or checked below\n            let last_0 = if (i == M - 1) & (skip_last) {\n                0\n            } else {\n                input[k + 2]\n            };\n            let all_0 = (input[k] == 0) & (input[k + 1] == 0) & (last_0 == 0);\n            assert(all_0, \"Found non-zero field after breakpoint\");\n        }\n    }\n    // we have 'remainder' num of items left to absorb\n    should_add = true;\n    // below is to avoid overflows (i.e. if inlen is close to N)\n    let mut should_check = !variable;\n    for i in 0..3 {\n        should_add &= i != remainder;\n        should_check &= in_len - remainder + i != N;\n        if should_add {\n            // we want to absorb the final 'remainder' items\n            sponge.absorb(input[in_len - remainder + i]);\n        } else if should_check {\n            assert(input[in_len - remainder + i] == 0, \"Found non-zero field after breakpoint\");\n        }\n    }\n    sponge\n}\n\npub fn poseidon2_hash_with_separator_slice<T>(inputs: [Field], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let in_len = inputs.len() + 1;\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs[i]);\n    }\n\n    sponge.squeeze()\n}\n\n#[no_predicates]\npub fn poseidon2_hash_bytes<let N: u32>(inputs: [u8; N]) -> Field {\n    let mut fields = [0; (N + 30) / 31];\n    let mut field_index = 0;\n    let mut current_field = [0; 31];\n    for i in 0..inputs.len() {\n        let index = i % 31;\n        current_field[index] = inputs[i];\n        if index == 30 {\n            fields[field_index] = field_from_bytes(current_field, false);\n            current_field = [0; 31];\n            field_index += 1;\n        }\n    }\n    if field_index != fields.len() {\n        fields[field_index] = field_from_bytes(current_field, false);\n    }\n    poseidon2_hash(fields)\n}\n\n#[test]\nfn poseidon_chunks_matches_fixed() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut fixed_input = [3; 501];\n    assert(in_len == fixed_input.len()); // sanity check\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let sub_chunk_hash = poseidon2_hash_subarray(input, in_len);\n    let fixed_len_hash = std::hash::poseidon2::Poseidon2::hash(fixed_input, fixed_input.len());\n    assert(sub_chunk_hash == fixed_len_hash);\n}\n\n#[test]\nfn poseidon_chunks_matches_variable() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let variable_chunk_hash = poseidon2_cheaper_variable_hash(input, in_len);\n    let variable_len_hash = std::hash::poseidon2::Poseidon2::hash(input, in_len);\n    assert(variable_chunk_hash == variable_len_hash);\n}\n\n#[test]\nfn existing_sponge_poseidon_chunks_matches_fixed() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut fixed_input = [3; 501];\n    assert(in_len == fixed_input.len()); // sanity check\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    // absorb 250 of the 501 things\n    let empty_sponge = Poseidon2Sponge::new((in_len as Field) * TWO_POW_64);\n    let first_sponge = poseidon2_absorb_chunks_existing_sponge(empty_sponge, input, 250, true);\n    // now absorb the final 251 (since they are all 3s, im being lazy and not making a new array)\n    let mut final_sponge = poseidon2_absorb_chunks_existing_sponge(first_sponge, input, 251, true);\n    let fixed_len_hash = Poseidon2Sponge::hash(fixed_input, fixed_input.len());\n    assert(final_sponge.squeeze() == fixed_len_hash);\n}\n\n#[test]\nfn poseidon_chunks_empty_inputs() {\n    let in_len = 0;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut constructed_empty_sponge = poseidon2_absorb_chunks(input, in_len, true);\n    let mut first_sponge =\n        poseidon2_absorb_chunks_existing_sponge(constructed_empty_sponge, input, in_len, true);\n    assert(first_sponge.squeeze() == constructed_empty_sponge.squeeze());\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n        25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,\n        48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70,\n        71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93,\n        94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112,\n        113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130,\n        131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148,\n        149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159,\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = sha256::digest(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result =\n        compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\n    assert(hash_result == 0xb393978842a0fa3d3e1470196f098f473f9678e72463cb65ec4ab5581856c2);\n\n    // Non-zero case\n    let hash_result = compute_l2_to_l1_hash(\n        AztecAddress::from_field(1),\n        EthAddress::from_field(3),\n        5,\n        2,\n        4,\n    );\n    assert(hash_result == 0x3f88c1044a05e5340ed20466276500f6d45ca5603913b9091e957161734e16);\n}\n\n#[test]\nfn silo_l2_to_l1_message_matches_typescript() {\n    let version = 4;\n    let chainId = 5;\n\n    let hash = silo_l2_to_l1_message(\n        ScopedL2ToL1Message {\n            message: L2ToL1Message { recipient: EthAddress::from_field(1), content: 2, counter: 0 },\n            contract_address: AztecAddress::from_field(3),\n        },\n        version,\n        chainId,\n    );\n\n    // The following value was generated by `l2_to_l1_message.test.ts`\n    let hash_from_typescript = 0x00c6155d69febb9d5039b374dd4f77bf57b7c881709aa524a18acaa0bd57476a;\n\n    assert_eq(hash, hash_from_typescript);\n}\n","path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.2/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr"},"297":{"source":"use crate::constants::TWO_POW_64;\n\n// NB: This is a clone of noir/noir-repo/noir_stdlib/src/hash/poseidon2.nr\n// It exists as we sometimes need to perform custom absorption, but the stdlib version\n// has a private absorb() method (it's also designed to just be a hasher)\n// Can be removed when standalone noir poseidon lib exists: See noir#6679\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2Sponge {\n    pub cache: [Field; 3],\n    pub state: [Field; 4],\n    pub cache_size: u32,\n    pub squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2Sponge {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2Sponge::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2Sponge {\n        let mut result =\n            Poseidon2Sponge { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = std::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    pub fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    pub fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let iv: Field = (in_len as Field) * TWO_POW_64;\n        let mut sponge = Poseidon2Sponge::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n","path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.2/noir-projects/noir-protocol-circuits/crates/types/src/poseidon2.nr"},"317":{"source":"use crate::{hash::poseidon2_hash, traits::ToField};\n\npub fn derive_storage_slot_in_map<K>(storage_slot: Field, key: K) -> Field\nwhere\n    K: ToField,\n{\n    poseidon2_hash([storage_slot, key.to_field()])\n}\n\nmod test {\n    use crate::{address::AztecAddress, storage::map::derive_storage_slot_in_map, traits::FromField};\n\n    #[test]\n    fn test_derive_storage_slot_in_map_matches_typescript() {\n        let map_slot = 0x132258fb6962c4387ba659d9556521102d227549a386d39f0b22d1890d59c2b5;\n        let key = AztecAddress::from_field(\n            0x302dbc2f9b50a73283d5fb2f35bc01eae8935615817a0b4219a057b2ba8a5a3f,\n        );\n\n        let slot = derive_storage_slot_in_map(map_slot, key);\n\n        // The following value was generated by `map_slot.test.ts`\n        let slot_from_typescript =\n            0x15b9fe39449affd8b377461263e9d2b610b9ad40580553500b4e41d9cbd887ac;\n\n        assert_eq(slot, slot_from_typescript);\n    }\n}\n","path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.2/noir-projects/noir-protocol-circuits/crates/types/src/storage/map.nr"},"336":{"source":"use crate::traits::{Deserialize, Serialize};\n\nglobal BOOL_SERIALIZED_LEN: u32 = 1;\nglobal U8_SERIALIZED_LEN: u32 = 1;\nglobal U16_SERIALIZED_LEN: u32 = 1;\nglobal U32_SERIALIZED_LEN: u32 = 1;\nglobal U64_SERIALIZED_LEN: u32 = 1;\nglobal U128_SERIALIZED_LEN: u32 = 1;\nglobal FIELD_SERIALIZED_LEN: u32 = 1;\nglobal I8_SERIALIZED_LEN: u32 = 1;\nglobal I16_SERIALIZED_LEN: u32 = 1;\nglobal I32_SERIALIZED_LEN: u32 = 1;\nglobal I64_SERIALIZED_LEN: u32 = 1;\n\nimpl Serialize<BOOL_SERIALIZED_LEN> for bool {\n    fn serialize(self) -> [Field; BOOL_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<BOOL_SERIALIZED_LEN> for bool {\n    fn deserialize(fields: [Field; BOOL_SERIALIZED_LEN]) -> bool {\n        fields[0] as bool\n    }\n}\n\nimpl Serialize<U8_SERIALIZED_LEN> for u8 {\n    fn serialize(self) -> [Field; U8_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U8_SERIALIZED_LEN> for u8 {\n    fn deserialize(fields: [Field; U8_SERIALIZED_LEN]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Serialize<U16_SERIALIZED_LEN> for u16 {\n    fn serialize(self) -> [Field; U16_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U16_SERIALIZED_LEN> for u16 {\n    fn deserialize(fields: [Field; U16_SERIALIZED_LEN]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Serialize<U32_SERIALIZED_LEN> for u32 {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U32_SERIALIZED_LEN> for u32 {\n    fn deserialize(fields: [Field; U32_SERIALIZED_LEN]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Serialize<U64_SERIALIZED_LEN> for u64 {\n    fn serialize(self) -> [Field; U64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U64_SERIALIZED_LEN> for u64 {\n    fn deserialize(fields: [Field; U64_SERIALIZED_LEN]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Serialize<U128_SERIALIZED_LEN> for u128 {\n    fn serialize(self) -> [Field; U128_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U128_SERIALIZED_LEN> for u128 {\n    fn deserialize(fields: [Field; U128_SERIALIZED_LEN]) -> Self {\n        fields[0] as u128\n    }\n}\n\nimpl Serialize<FIELD_SERIALIZED_LEN> for Field {\n    fn serialize(self) -> [Field; FIELD_SERIALIZED_LEN] {\n        [self]\n    }\n}\n\nimpl Deserialize<FIELD_SERIALIZED_LEN> for Field {\n    fn deserialize(fields: [Field; FIELD_SERIALIZED_LEN]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Serialize<I8_SERIALIZED_LEN> for i8 {\n    fn serialize(self) -> [Field; I8_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I8_SERIALIZED_LEN> for i8 {\n    fn deserialize(fields: [Field; I8_SERIALIZED_LEN]) -> Self {\n        fields[0] as i8\n    }\n}\n\nimpl Serialize<I16_SERIALIZED_LEN> for i16 {\n    fn serialize(self) -> [Field; I16_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I16_SERIALIZED_LEN> for i16 {\n    fn deserialize(fields: [Field; I16_SERIALIZED_LEN]) -> Self {\n        fields[0] as i16\n    }\n}\n\nimpl Serialize<I32_SERIALIZED_LEN> for i32 {\n    fn serialize(self) -> [Field; I32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I32_SERIALIZED_LEN> for i32 {\n    fn deserialize(fields: [Field; I32_SERIALIZED_LEN]) -> Self {\n        fields[0] as i32\n    }\n}\n\nimpl Serialize<I64_SERIALIZED_LEN> for i64 {\n    fn serialize(self) -> [Field; I64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I64_SERIALIZED_LEN> for i64 {\n    fn deserialize(fields: [Field; I64_SERIALIZED_LEN]) -> Self {\n        fields[0] as i64\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Serialize<N * M> for [T; N]\nwhere\n    T: Serialize<M>,\n{\n    fn serialize(self) -> [Field; N * M] {\n        let mut result: [Field; N * M] = std::mem::zeroed();\n        let mut serialized: [Field; M] = std::mem::zeroed();\n        for i in 0..N {\n            serialized = self[i].serialize();\n            for j in 0..M {\n                result[i * M + j] = serialized[j];\n            }\n        }\n        result\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Deserialize<N * M> for [T; N]\nwhere\n    T: Deserialize<M>,\n{\n    fn deserialize(fields: [Field; N * M]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; N] = std::mem::zeroed();\n        reader.read_struct_array::<T, M, N>(Deserialize::deserialize, result)\n    }\n}\n\n#[test]\nfn test_u16_serialization() {\n    let a: u16 = 10;\n    assert_eq(a, u16::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i8_serialization() {\n    let a: i8 = -10;\n    assert_eq(a, i8::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i16_serialization() {\n    let a: i16 = -10;\n    assert_eq(a, i16::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i32_serialization() {\n    let a: i32 = -10;\n    assert_eq(a, i32::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i64_serialization() {\n    let a: i64 = -10;\n    assert_eq(a, i64::deserialize(a.serialize()));\n}\n","path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.2/noir-projects/noir-protocol-circuits/crates/types/src/type_serialization.nr"},"352":{"source":"pub mod assert_array_appended;\npub mod assert_array_prepended;\npub mod assert_combined_array;\npub mod assert_combined_transformed_array;\npub mod assert_exposed_sorted_transformed_value_array;\npub mod assert_sorted_array;\npub mod assert_sorted_transformed_value_array;\npub mod assert_split_sorted_transformed_value_arrays;\npub mod assert_split_transformed_value_arrays;\npub mod get_sorted_result;\npub mod get_sorted_tuple;\npub mod sort_by;\npub mod sort_by_counter;\n\n// Re-exports.\npub use assert_array_appended::{\n    assert_array_appended, assert_array_appended_and_scoped, assert_array_appended_reversed,\n    assert_array_appended_scoped,\n};\npub use assert_array_prepended::assert_array_prepended;\npub use assert_combined_array::{assert_combined_array, combine_arrays};\npub use assert_combined_transformed_array::{\n    assert_combined_transformed_array, combine_and_transform_arrays,\n};\npub use assert_exposed_sorted_transformed_value_array::{\n    assert_exposed_sorted_transformed_value_array,\n    get_order_hints::{get_order_hints_asc, get_order_hints_desc, OrderHint},\n};\npub use assert_sorted_array::assert_sorted_array;\npub use assert_sorted_transformed_value_array::{\n    assert_sorted_transformed_value_array, assert_sorted_transformed_value_array_capped_size,\n};\npub use assert_split_sorted_transformed_value_arrays::{\n    assert_split_sorted_transformed_value_arrays_asc,\n    assert_split_sorted_transformed_value_arrays_desc,\n    get_split_order_hints::{get_split_order_hints_asc, get_split_order_hints_desc, SplitOrderHints},\n};\npub use assert_split_transformed_value_arrays::assert_split_transformed_value_arrays;\npub use get_sorted_result::{get_sorted_result, SortedResult};\npub use sort_by_counter::{sort_by_counter_asc, sort_by_counter_desc};\n\nuse crate::traits::{Empty, is_empty};\n\npub fn subarray<let SRC_LEN: u32, let DST_LEN: u32>(\n    src: [Field; SRC_LEN],\n    offset: u32,\n) -> [Field; DST_LEN] {\n    assert(offset + DST_LEN <= SRC_LEN, \"offset too large\");\n\n    let mut dst: [Field; DST_LEN] = std::mem::zeroed();\n    for i in 0..DST_LEN {\n        dst[i] = src[i + offset];\n    }\n\n    dst\n}\n\n// Helper function to convert a validated array to BoundedVec.\n// Important: Only use it for validated arrays: validate_array(array) should be true.\npub unconstrained fn array_to_bounded_vec<T, let N: u32>(array: [T; N]) -> BoundedVec<T, N>\nwhere\n    T: Empty + Eq,\n{\n    let len = array_length(array);\n    BoundedVec::from_parts_unchecked(array, len)\n}\n\n// Helper function to find the index of the first element in an array that satisfies a given predicate. If the element\n// is not found, the function returns N as the index.\npub unconstrained fn find_index_hint<T, let N: u32, Env>(\n    array: [T; N],\n    find: fn[Env](T) -> bool,\n) -> u32 {\n    let mut index = N;\n    for i in 0..N {\n        // We check `index == N` to ensure that we only update the index if we haven't found a match yet.\n        if (index == N) & find(array[i]) {\n            index = i;\n        }\n    }\n    index\n}\n\n// Routine which validates that all zero values of an array form a contiguous region at the end, i.e.,\n// of the form: [*,*,*...,0,0,0,0] where any * is non-zero. Note that a full array of non-zero values is\n// valid.\npub fn validate_array<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    let mut seen_empty = false;\n    let mut length = 0;\n    for i in 0..N {\n        if is_empty(array[i]) {\n            seen_empty = true;\n        } else {\n            assert(seen_empty == false, \"invalid array\");\n            length += 1;\n        }\n    }\n    length\n}\n\n// Helper function to count the number of non-empty elements in a validated array.\n// Important: Only use it for validated arrays where validate_array(array) returns true,\n// which ensures that:\n// 1. All elements before the first empty element are non-empty\n// 2. All elements after and including the first empty element are empty\n// 3. The array forms a contiguous sequence of non-empty elements followed by empty elements\npub fn array_length<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    // We get the length by checking the index of the first empty element.\n\n    // Safety: This is safe because we have validated the array (see function doc above) and the emptiness\n    // of the element and non-emptiness of the previous element is checked below.\n    let length = unsafe { find_index_hint(array, |elem: T| is_empty(elem)) };\n    if length != 0 {\n        assert(!is_empty(array[length - 1]));\n    }\n    if length != N {\n        assert(is_empty(array[length]));\n    }\n    length\n}\n\npub fn array_concat<T, let N: u32, let M: u32>(array1: [T; N], array2: [T; M]) -> [T; N + M] {\n    let mut result = [array1[0]; N + M];\n    for i in 1..N {\n        result[i] = array1[i];\n    }\n    for i in 0..M {\n        result[i + N] = array2[i];\n    }\n    result\n}\n/// This function assumes that `array1` and `array2` contain no more than N non-empty elements between them,\n/// if this is not the case then elements from the end of `array2` will be dropped.\npub fn array_merge<T, let N: u32>(array1: [T; N], array2: [T; N]) -> [T; N]\nwhere\n    T: Empty + Eq,\n{\n    // Safety: we constrain this array below\n    let result = unsafe { array_merge_helper(array1, array2) };\n    // We assume arrays have been validated. The only use cases so far are with previously validated arrays.\n    let array1_len = array_length(array1);\n    let mut add_from_left = true;\n    for i in 0..N {\n        add_from_left &= i != array1_len;\n        if add_from_left {\n            assert_eq(result[i], array1[i]);\n        } else {\n            assert_eq(result[i], array2[i - array1_len]);\n        }\n    }\n    result\n}\n\nunconstrained fn array_merge_helper<T, let N: u32>(array1: [T; N], array2: [T; N]) -> [T; N]\nwhere\n    T: Empty + Eq,\n{\n    let mut result: [T; N] = [T::empty(); N];\n    let mut i = 0;\n    for elem in array1 {\n        if !is_empty(elem) {\n            result[i] = elem;\n            i += 1;\n        }\n    }\n    for elem in array2 {\n        if !is_empty(elem) {\n            result[i] = elem;\n            i += 1;\n        }\n    }\n    result\n}\n\n// Helper fn to create a subarray from a given array\npub fn array_splice<T, let N: u32, let M: u32>(array: [T; N], offset: u32) -> [T; M]\nwhere\n    T: Empty,\n{\n    assert(M + offset <= N, \"Subarray length larger than array length\");\n    let mut result: [T; M] = [T::empty(); M];\n    for i in 0..M {\n        result[i] = array[offset + i];\n    }\n    result\n}\n\npub fn check_permutation<T, let N: u32>(\n    original_array: [T; N],\n    permuted_array: [T; N],\n    original_indexes: [u32; N],\n)\nwhere\n    T: Eq + Empty,\n{\n    let mut seen_value = [false; N];\n    for i in 0..N {\n        let index = original_indexes[i];\n        let original_value = original_array[index];\n        assert(permuted_array[i].eq(original_value), \"Invalid index\");\n        assert(!seen_value[index], \"Duplicated index\");\n        seen_value[index] = true;\n    }\n}\n\n// Helper function to find the index of the last element in an array, allowing empty elements.\n// e.g. useful for removing trailing 0s from [1, 0, 2, 0, 0, 0] -> [1, 0, 2]\n// Nothing to do with validated arrays. Correctness constrained by padded_array_length.\npub unconstrained fn find_last_value_index<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    let mut index = N;\n    for i in 0..N {\n        let j = N - i - 1;\n        // We check `index == N` to ensure that we only update the index if we haven't found a match yet.\n        if (index == N) & !is_empty(array[j]) {\n            index = j;\n        }\n    }\n    index\n}\n\n// Routine which returns the length of an array right padded by empty elements\n// of the form: [*,*,*...,0,0,0,0] where * is any value (zeroes allowed).\n// See smoke_validate_array_trailing for examples.\n// Nothing to do with validated arrays. Correctness constrained by padded_array_length.\npub unconstrained fn unsafe_padded_array_length<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    let index = find_last_value_index(array);\n    if index == N {\n        0\n    } else {\n        index + 1\n    }\n}\n\n// Routine which validates that zero values of an array form a contiguous region at the end, i.e.,\n// of the form: [*,*,*...,0,0,0,0] where * is any value (zeroes allowed).\npub fn padded_array_length<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    // Safety: this value is constrained in the below loop.\n    let length = unsafe { unsafe_padded_array_length(array) };\n    // Check the elt just before length is non-zero:\n    if length != 0 {\n        assert(!is_empty(array[length - 1]), \"invalid right padded array\");\n    }\n    // Check all beyond length are zero:\n    let mut check_zero = false;\n    for i in 0..N {\n        check_zero |= i == length;\n        if check_zero {\n            assert(is_empty(array[i]), \"invalid right padded array\");\n        }\n    }\n    length\n}\n\n#[test]\nfn smoke_validate_array() {\n    let valid_array: [Field; 0] = [];\n    assert(validate_array(valid_array) == 0);\n\n    let valid_array = [0];\n    assert(validate_array(valid_array) == 0);\n\n    let valid_array = [3];\n    assert(validate_array(valid_array) == 1);\n\n    let valid_array = [1, 2, 3];\n    assert(validate_array(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0];\n    assert(validate_array(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0, 0];\n    assert(validate_array(valid_array) == 3);\n}\n\n#[test]\nfn smoke_validate_array_trailing() {\n    let valid_array: [Field; 0] = [];\n    assert(padded_array_length(valid_array) == 0);\n\n    let valid_array = [0];\n    assert(padded_array_length(valid_array) == 0);\n\n    let valid_array = [3];\n    assert(padded_array_length(valid_array) == 1);\n\n    let valid_array = [1, 0, 3];\n    assert(padded_array_length(valid_array) == 3);\n\n    let valid_array = [1, 0, 3, 0];\n    assert(padded_array_length(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0, 0];\n    assert(padded_array_length(valid_array) == 3);\n\n    let valid_array = [0, 0, 3, 0, 0];\n    assert(padded_array_length(valid_array) == 3);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case0() {\n    let invalid_array = [0, 1];\n    let _ = validate_array(invalid_array);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case1() {\n    let invalid_array = [1, 0, 0, 1, 0];\n    let _ = validate_array(invalid_array);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case2() {\n    let invalid_array = [0, 0, 0, 0, 1];\n    let _ = validate_array(invalid_array);\n}\n\n#[test]\nfn test_empty_array_length() {\n    assert_eq(array_length([0]), 0);\n    assert_eq(array_length([0, 0, 0]), 0);\n}\n\n#[test]\nfn test_array_length() {\n    assert_eq(array_length([123]), 1);\n    assert_eq(array_length([123, 0, 0]), 1);\n    assert_eq(array_length([123, 456]), 2);\n    assert_eq(array_length([123, 456, 0]), 2);\n}\n\n#[test]\nfn test_array_length_invalid_arrays() {\n    // Result can be misleading (but correct) for invalid arrays.\n    assert_eq(array_length([0, 0, 123]), 0);\n    assert_eq(array_length([0, 123, 0]), 0);\n    assert_eq(array_length([0, 123, 456]), 0);\n    assert_eq(array_length([123, 0, 456]), 1);\n}\n\n#[test]\nunconstrained fn find_index_greater_than_min() {\n    let values = [10, 20, 30, 40];\n    let min = 22;\n    let index = find_index_hint(values, |v: Field| min.lt(v));\n    assert_eq(index, 2);\n}\n\n#[test]\nunconstrained fn find_index_not_found() {\n    let values = [10, 20, 30, 40];\n    let min = 100;\n    let index = find_index_hint(values, |v: Field| min.lt(v));\n    assert_eq(index, 4);\n}\n\n#[test]\nfn test_array_concat() {\n    let array0 = [1, 2, 3];\n    let array1 = [4, 5];\n    let concatenated = array_concat(array0, array1);\n    assert_eq(concatenated, [1, 2, 3, 4, 5]);\n}\n\n#[test]\nfn check_permutation_basic_test() {\n    let original_array = [1, 2, 3];\n    let permuted_array = [3, 1, 2];\n    let indexes = [2, 0, 1];\n    check_permutation(original_array, permuted_array, indexes);\n}\n\n#[test(should_fail_with = \"Duplicated index\")]\nfn check_permutation_duplicated_index() {\n    let original_array = [0, 1, 0];\n    let permuted_array = [1, 0, 0];\n    let indexes = [1, 0, 0];\n    check_permutation(original_array, permuted_array, indexes);\n}\n\n#[test(should_fail_with = \"Invalid index\")]\nfn check_permutation_invalid_index() {\n    let original_array = [0, 1, 2];\n    let permuted_array = [1, 0, 0];\n    let indexes = [1, 0, 2];\n    check_permutation(original_array, permuted_array, indexes);\n}\n","path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.2/noir-projects/noir-protocol-circuits/crates/types/src/utils/arrays.nr"},"355":{"source":"pub struct Reader<let N: u32> {\n    data: [Field; N],\n    offset: u32,\n}\n\nimpl<let N: u32> Reader<N> {\n    pub fn new(data: [Field; N]) -> Self {\n        Self { data, offset: 0 }\n    }\n\n    pub fn read(&mut self) -> Field {\n        let result = self.data[self.offset];\n        self.offset += 1;\n        result\n    }\n\n    pub fn read_u32(&mut self) -> u32 {\n        self.read() as u32\n    }\n\n    pub fn read_bool(&mut self) -> bool {\n        self.read() as bool\n    }\n\n    pub fn read_array<let K: u32>(&mut self) -> [Field; K] {\n        let mut result = [0; K];\n        for i in 0..K {\n            result[i] = self.data[self.offset + i];\n        }\n        self.offset += K;\n        result\n    }\n\n    pub fn read_struct<T, let K: u32>(&mut self, deserialise: fn([Field; K]) -> T) -> T {\n        let result = deserialise(self.read_array());\n        result\n    }\n\n    pub fn read_struct_array<T, let K: u32, let C: u32>(\n        &mut self,\n        deserialise: fn([Field; K]) -> T,\n        mut result: [T; C],\n    ) -> [T; C] {\n        for i in 0..C {\n            result[i] = self.read_struct(deserialise);\n        }\n        result\n    }\n\n    pub fn finish(self) {\n        assert(self.offset == self.data.len(), \"Reader did not read all data\");\n    }\n}\n","path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0-alpha-testnet.2/noir-projects/noir-protocol-circuits/crates/types/src/utils/reader.nr"}}}